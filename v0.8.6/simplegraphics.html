<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simple graphics · Luxor</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Luxor logo"/></a><h1>Luxor</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction to Luxor</a></li><li><a class="toctext" href="examples.html">A few examples</a></li><li><a class="toctext" href="basics.html">Basic concepts</a></li><li class="current"><a class="toctext" href="simplegraphics.html">Simple graphics</a><ul class="internal"><li><a class="toctext" href="#Rectangles-and-boxes-1">Rectangles and boxes</a></li><li><a class="toctext" href="#Circles-and-ellipses-1">Circles and ellipses</a></li><li><a class="toctext" href="#More-curved-shapes:-sectors,-spirals,-and-squircles-1">More curved shapes: sectors, spirals, and squircles</a></li><li><a class="toctext" href="#Paths-and-positions-1">Paths and positions</a></li><li><a class="toctext" href="#Lines-1">Lines</a></li><li><a class="toctext" href="#Arcs-and-curves-1">Arcs and curves</a></li><li><a class="toctext" href="#Geometry-tools-1">Geometry tools</a></li><li><a class="toctext" href="#Arrows-1">Arrows</a></li><li><a class="toctext" href="#Julia-graphics-1">Julia graphics</a></li><li><a class="toctext" href="#Miscellaneous-1">Miscellaneous</a></li></ul></li><li><a class="toctext" href="colors-styles.html">Colors and styles</a></li><li><a class="toctext" href="polygons.html">Polygons</a></li><li><a class="toctext" href="text.html">Text</a></li><li><a class="toctext" href="transforms.html">Transforms and matrices</a></li><li><a class="toctext" href="clipping.html">Clipping</a></li><li><a class="toctext" href="images.html">Images</a></li><li><a class="toctext" href="turtle.html">Turtle graphics</a></li><li><a class="toctext" href="animation.html">Animation</a></li><li><a class="toctext" href="moreexamples.html">More examples</a></li><li><a class="toctext" href="functionindex.html">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="simplegraphics.html">Simple graphics</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/docs/src/simplegraphics.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Simple graphics</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Simple-graphics-1" href="#Simple-graphics-1">Simple graphics</a></h1><p>In Luxor, there are different ways of working with graphical items. Some, such as lines, rectangles and circles, are drawn immediately (ie placed on the drawing and then &quot;forgotten&quot;). Others can be constructed and then converted to lists of points for further processing. For these, watch out for a <code>vertices=true</code> option.</p><h2><a class="nav-anchor" id="Rectangles-and-boxes-1" href="#Rectangles-and-boxes-1">Rectangles and boxes</a></h2><p><img src="assets/figures/rects.png" alt="rects"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.rect" href="#Luxor.rect"><code>Luxor.rect</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rect(xmin, ymin, w, h, action)</code></pre><p>Create a rectangle with one corner at (<code>xmin</code>/<code>ymin</code>) with width <code>w</code> and height <code>h</code> and then do an action.</p><p>See <code>box()</code> for more ways to do similar things, such as supplying two opposite corners, placing by centerpoint and dimensions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/shapes.jl#L1-L9">source</a><br/><div><pre><code class="language-none">rect(cornerpoint, w, h, action)</code></pre><p>Create a rectangle with one corner at <code>cornerpoint</code> with width <code>w</code> and height <code>h</code> and do an action.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/shapes.jl#L18-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">box(cornerpoint1, cornerpoint2, action=:nothing)</code></pre><p>Create a rectangle between two points and do an action.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/shapes.jl#L27-L31">source</a><br/><div><pre><code class="language-none">box(points::Array, action=:nothing)</code></pre><p>Create a box/rectangle using the first two points of an array of Points to defined opposite corners.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/shapes.jl#L35-L40">source</a><br/><div><pre><code class="language-none">box(pt::Point, width, height, action=:nothing; vertices=false)</code></pre><p>Create a box/rectangle centered at point <code>pt</code> with width and height. Use <code>vertices=true</code> to return an array of the four corner points rather than draw the box.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/shapes.jl#L43-L48">source</a><br/><div><pre><code class="language-none">box(x, y, width, height, action=:nothing)</code></pre><p>Create a box/rectangle centered at point <code>x/y</code> with width and height.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/shapes.jl#L59-L63">source</a><br/><div><pre><code class="language-none">box(x, y, width, height, cornerradius, action=:nothing)</code></pre><p>Create a box/rectangle centered at point <code>x/y</code> with <code>width</code> and <code>height</code>. Round each corner by <code>cornerradius</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/shapes.jl#L67-L72">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polybbox" href="#Luxor.polybbox"><code>Luxor.polybbox</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Find the bounding box of a polygon (array of points).</p><pre><code class="language-none">polybbox(pointlist::Array)</code></pre><p>Return the two opposite corners (suitable for <code>box()</code>, for example).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/polygons.jl#L30-L36">source</a><br/></section><p>For regular polygons, see the next section on Polygons.</p><h2><a class="nav-anchor" id="Circles-and-ellipses-1" href="#Circles-and-ellipses-1">Circles and ellipses</a></h2><p>There are various ways to make circles, including by center and radius, or passing through two points:</p><div><pre><code class="language-julia">p1 = O
p2 = Point(100, 0)
sethue(&quot;red&quot;)
circle(p1, 40, :fill)
sethue(&quot;green&quot;)
circle(p1, p2, :stroke)
sethue(&quot;black&quot;)
arrow(O, Point(0, -40))
map(p -&gt; circle(p, 4, :fill), [p1, p2])</code></pre></div><p><img src="assets/figures/circles.png" alt="circles"/></p><p>Or passing through three points. The <code>center3pts()</code> function returns the center position and radius of a circle passing through three points:</p><div><pre><code class="language-julia">sethue(&quot;black&quot;)
p1 = Point(0, -50)
p2 = Point(100, 0)
p3 = Point(0, 65)
map(p -&gt; circle(p, 4, :fill), [p1, p2, p3])
circle(center3pts(p1, p2, p3)..., :stroke)</code></pre></div><p><img src="assets/figures/center3.png" alt="center and radius of 3 points"/></p><p>With <code>ellipse()</code> you can place ellipses (and circles) by defining the center point and the width and height.</p><div><pre><code class="language-julia">tiles = Tiler(500, 300, 5, 5)
width = 20
height = 25
for (pos, n) in tiles
    randomhue()
    ellipse(pos, width, height, :fill)
    sethue(&quot;black&quot;)
    label = string(round(width/height, 2))
    textcentered(label, pos.x, pos.y + 25)
    width += 2
end</code></pre></div><p><img src="assets/figures/ellipses.png" alt="ellipses"/></p><p>It&#39;s also possible to construct polygons that are approximations to ellipses with two focal points and a distance.</p><div><pre><code class="language-julia">f1 = Point(-100, 0)
f2 = Point(100, 0)
ellipsepoly = ellipse(f1, f2, 170, :none, vertices=true)
[ begin
    setgray(rescale(c, 150, 1, 0, 1))
    poly(offsetpoly(ellipsepoly, c), close=true, :fill);
    rotate(pi/20)
  end
     for c in 150:-10:1 ]</code></pre></div><p><img src="assets/figures/ellipses_1.png" alt="more ellipses"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.circle" href="#Luxor.circle"><code>Luxor.circle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">circle(x, y, r, action=:nothing)</code></pre><p>Make a circle of radius <code>r</code> centered at <code>x</code>/<code>y</code>.</p><p><code>action</code> is one of the actions applied by <code>do_action</code>, defaulting to <code>:nothing</code>. You can also use <code>ellipse()</code> to draw circles and place them by their centerpoint.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L3-L10">source</a><br/><div><pre><code class="language-none">circle(pt, r, action)</code></pre><p>Make a circle centered at <code>pt</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L19-L23">source</a><br/><div><pre><code class="language-none">circle(pt1::Point, pt2::Point, action=:nothing)</code></pre><p>Make a circle that passes through two points that define the diameter:</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L27-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.ellipse" href="#Luxor.ellipse"><code>Luxor.ellipse</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Make an ellipse, centered at <code>xc/yc</code>, fitting in a box of width <code>w</code> and height <code>h</code>.</p><pre><code class="language-none">ellipse(xc, yc, w, h, action=:none)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L69-L73">source</a><br/><div><p>Make an ellipse, centered at point <code>c</code>, with width <code>w</code>, and height <code>h</code>.</p><pre><code class="language-none">ellipse(cpt, w, h, action=:none)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L92-L96">source</a><br/><div><pre><code class="language-none">ellipse(focus1::Point, focus2::Point, k, action=:none;
        stepvalue=pi/100,
        vertices=false,
        reversepath=false)</code></pre><p>Build a polygon approximation to an ellipse, given two points and a distance, <code>k</code>, which is the sum of the distances to the focii of any points on the ellipse (or the shortest length of string required to go from one focus to the perimeter and on to the other focus).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L402-L411">source</a><br/></section><p><code>circlepath()</code> constructs a circular path from Bèzier curves, which allows you to use circles as paths.</p><div><pre><code class="language-julia">setline(4)
tiles = Tiler(600, 250, 1, 5)
for (pos, n) in tiles
    randomhue()
    circlepath(pos, tiles.tilewidth/2, :path)
    newsubpath()
    circlepath(pos, rand(5:tiles.tilewidth/2 - 1), :fill, reversepath=true)
end</code></pre></div><p><img src="assets/figures/circle-path.png" alt="circles as paths"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.circlepath" href="#Luxor.circlepath"><code>Luxor.circlepath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">circlepath(center::Point, radius, action=:none;
    reversepath=false,
    kappa = 0.5522847)</code></pre><p>Draw a circle using Bézier curves.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L339-L345">source</a><br/></section><h2><a class="nav-anchor" id="More-curved-shapes:-sectors,-spirals,-and-squircles-1" href="#More-curved-shapes:-sectors,-spirals,-and-squircles-1">More curved shapes: sectors, spirals, and squircles</a></h2><p>A sector (technically an &quot;annular sector&quot;) has an inner and outer radius, as well as start and end angles.</p><div><pre><code class="language-julia">sethue(&quot;tomato&quot;)
sector(50, 90, pi/2, 0, :fill)
sethue(&quot;olive&quot;)
sector(Point(O.x + 200, O.y), 50, 90, 0, pi/2, :fill)</code></pre></div><p><img src="assets/figures/sector.png" alt="sector"/></p><p>You can also supply a value for a corner radius. The same sector is drawn but with rounded corners.</p><div><pre><code class="language-julia">sethue(&quot;tomato&quot;)
sector(50, 90, pi/2, 0, 15, :fill)
sethue(&quot;olive&quot;)
sector(Point(O.x + 200, O.y), 50, 90, 0, pi/2, 15, :fill)</code></pre></div><p><img src="assets/figures/sectorrounded.png" alt="sector"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.sector" href="#Luxor.sector"><code>Luxor.sector</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sector(centerpoint::Point, innerradius, outerradius, startangle, endangle, action:none)</code></pre><p>Draw an annular sector centered at <code>centerpoint</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L189-L193">source</a><br/><div><p>Draw an annular sector centered at the origin.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L209">source</a><br/><div><pre><code class="language-none">sector(centerpoint::Point, innerradius, outerradius, startangle, endangle, cornerradius, action:none)</code></pre><p>Draw an annular sector with rounded corners, basically a bent sausage shape, centered at <code>centerpoint</code>.</p><p>TODO: The results aren&#39;t 100% accurate at the moment. There are small discontinuities where the curves join.</p><p>The cornerradius is reduced from the supplied value if neceesary to prevent overshoots.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L214-L223">source</a><br/><div><p>Draw an annular sector with rounded corners, centered at the current origin.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L290">source</a><br/></section><p>A pie (or wedge) has start and end angles.</p><div><pre><code class="language-julia">pie(0, 0, 100, pi/2, pi, :fill)</code></pre></div><p><img src="assets/figures/pie.png" alt="pie"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.pie" href="#Luxor.pie"><code>Luxor.pie</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pie(x, y, radius, startangle, endangle, action=:none)</code></pre><p>Draw a pie shape centered at <code>x</code>/<code>y</code>. Angles start at the positive x-axis and are measured clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L295-L300">source</a><br/><div><pre><code class="language-none">pie(centerpoint, radius, startangle, endangle, action=:none)</code></pre><p>Draw a pie shape centered at <code>centerpoint</code>.</p><p>Angles start at the positive x-axis and are measured clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L313-L319">source</a><br/><div><p>Draw a pie shape centered at the origin</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L323">source</a><br/></section><p>To construct spirals, use the <code>spiral()</code> function. These can be drawn directly, or used as polygons. The default is to draw Archimedes (non-logarithmic) spirals.</p><div><pre><code class="language-julia">sp = spiral(4, 1, stepby=pi/24, period=12pi, vertices=true)

for i in 1:10
    setgray(i/10)
    setline(22-2i)
    poly(sp, :stroke)
end</code></pre></div><p><img src="assets/figures/spiral.png" alt="spiral"/></p><p>Use the <code>log=true</code> option to draw logarithmic spirals.</p><div><pre><code class="language-julia">sp = spiral(2, .12, log=true, stepby=pi/24, period=12pi, vertices=true)

for i in 1:10
    setgray(i/10)
    setline(22-2i)
    poly(sp, :stroke)
end</code></pre></div><p><img src="assets/figures/spiral-log.png" alt="spiral log"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.spiral" href="#Luxor.spiral"><code>Luxor.spiral</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">spiral(a, b, action::Symbol=:none;
                 stepby = 0.01,
                 period = 4pi,
                 vertices = false,
                 log=false)</code></pre><p>Make a spiral. The two primary parameters <code>a</code> and <code>b</code> determine the start radius, and the tightness.</p><p>For linear spirals (<code>log=false</code>), <code>b</code> values are:</p><pre><code class="language-none">lituus: -2

hyperbolic spiral: -1

Archimedes&#39; spiral: 1

Fermat&#39;s spiral: 2</code></pre><p>For logarithmic spirals (<code>log=true</code>):</p><pre><code class="language-none">golden spiral: b = ln(phi)/ (pi/2) (about 0.30)</code></pre><p>Values of <code>b</code> around 0.1 produce tighter, staircase-like spirals.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L521-L546">source</a><br/></section><p>A <em>squircle</em> is a cross between a square and a circle. You can adjust the squariness and circularity of it to taste by supplying a value for keyword <code>rt</code>:</p><div><pre><code class="language-julia">setline(2)
tiles = Tiler(600, 250, 1, 3)
for (pos, n) in tiles
    sethue(&quot;lavender&quot;)
    squircle(pos, 80, 80, rt=[0.3, 0.5, 0.7][n], :fillpreserve)
    sethue(&quot;grey20&quot;)
    strokepath()
    textcentered(&quot;rt = $([0.3, 0.5, 0.7][n])&quot;, pos)
end</code></pre></div><p><img src="assets/figures/squircle.png" alt="squircles"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.squircle" href="#Luxor.squircle"><code>Luxor.squircle</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Make a squircle (basically a rectangle with rounded corners). Specify the center position, horizontal radius (distance from center to a side), and vertical radius (distance from center to top or bottom):</p><pre><code class="language-none">squircle(center::Point, hradius, vradius, action=:none; rt = 0.5, vertices=false)</code></pre><p>The <code>rt</code> option defaults to 0.5, and gives an intermediate shape. Values less than 0.5 make the shape more square. Values above make the shape more round.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L99-L105">source</a><br/></section><p>To draw a simple rounded rectangle, supply a corner radius:</p><div><pre><code class="language-julia">setline(4)
box(O, 200, 150, 10, :stroke)</code></pre></div><p><img src="assets/figures/round-rect-1.png" alt="rounded rect 1"/></p><p>Or you could smooth the corners of a box, like so:</p><div><pre><code class="language-julia">setline(4)
polysmooth(box(O, 200, 150, vertices=true), 10, :stroke)</code></pre></div><p><img src="assets/figures/round-rect.png" alt="rounded rect"/></p><h2><a class="nav-anchor" id="Paths-and-positions-1" href="#Paths-and-positions-1">Paths and positions</a></h2><p>A path is a sequence of lines and curves. You can add lines and curves to the current path, then use <code>closepath()</code> to join the last point to the first.</p><p>A path can have subpaths, created with<code>newsubpath()</code>, which can form holes.</p><p>There is a &#39;current position&#39; which you can set with <code>move()</code>, and can use implicitly in functions like <code>line()</code>, <code>text()</code>, <code>arc()</code> and <code>curve()</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.move" href="#Luxor.move"><code>Luxor.move</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">move(x, y)
move(pt)</code></pre><p>Move to a point.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/basics.jl#L321-L326">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.rmove" href="#Luxor.rmove"><code>Luxor.rmove</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rmove(x, y)</code></pre><p>Move by an amount from the current point. Move relative to current position by <code>x</code> and <code>y</code>:</p><p>Move relative to current position by the <code>pt</code>&#39;s x and y:</p><pre><code class="language-none">rmove(pt)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/basics.jl#L330-L338">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.newpath" href="#Luxor.newpath"><code>Luxor.newpath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">newpath()</code></pre><p>Create a new path. This is Cairo&#39;s <code>new_path()</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/basics.jl#L155-L159">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.newsubpath" href="#Luxor.newsubpath"><code>Luxor.newsubpath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">newsubpath()</code></pre><p>Add a new subpath to the current path. This is Cairo&#39;s <code>new_sub_path()</code> function. It can be used for example to make holes in shapes.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/basics.jl#L162-L167">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.closepath" href="#Luxor.closepath"><code>Luxor.closepath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">closepath()</code></pre><p>Close the current path. This is Cairo&#39;s <code>close_path()</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/basics.jl#L170-L174">source</a><br/></section><h2><a class="nav-anchor" id="Lines-1" href="#Lines-1">Lines</a></h2><p>Use <code>line()</code> and <code>rline()</code> to draw straight lines.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.line" href="#Luxor.line"><code>Luxor.line</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">line(x, y)
line(x, y, :action)
line(pt)</code></pre><p>Create a line from the current position to the <code>x/y</code> position and optionally apply an action:</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/basics.jl#L342-L348">source</a><br/><div><pre><code class="language-none">line(pt1::Point, pt2::Point, action=:nothing)</code></pre><p>Make a line between two points, <code>pt1</code> and <code>pt2</code> and do an action.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/basics.jl#L352-L356">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.rline" href="#Luxor.rline"><code>Luxor.rline</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rline(x, y)
rline(x, y, :action)
rline(pt)</code></pre><p>Create a line relative to the current position to the <code>x/y</code> position and optionally apply an action:</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/basics.jl#L363-L370">source</a><br/></section><p>You can use <code>rule()</code> to draw a line across the entire drawing through a point, at an angle to the current x-axis.</p><div><pre><code class="language-julia">y = 10
for x in logspace(0, 2.75, 40)
    circle(Point(x, y), 2, :fill)
    rule(Point(x, y), -pi/2)
    y += 2
end</code></pre></div><p><img src="assets/figures/rule.png" alt="arc"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.rule" href="#Luxor.rule"><code>Luxor.rule</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rule(pos::Point, theta=0.0)</code></pre><p>Draw a line across the entire drawing passing through <code>pos</code>, at an angle of <code>theta</code> to the x-axis. Returns the two points.</p><p>The end points are not calculated exactly, they&#39;re just a long way apart.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/basics.jl#L374-L381">source</a><br/></section><h2><a class="nav-anchor" id="Arcs-and-curves-1" href="#Arcs-and-curves-1">Arcs and curves</a></h2><p>There are a few standard arc-drawing commands, such as <code>curve()</code>, <code>arc()</code>, <code>carc()</code>, and <code>arc2r()</code>.</p><p><code>curve()</code> constructs Bèzier curves from control points:</p><div><pre><code class="language-julia">setline(.5)
pt1 = Point(0, -125)
pt2 = Point(200, 125)
pt3 = Point(200, -125)

sethue(&quot;red&quot;)
map(p -&gt; circle(p, 4, :fill), [O, pt1, pt2, pt3])

line(O, pt1, :stroke)
line(pt2, pt3, :stroke)

sethue(&quot;black&quot;)
setline(3)

move(O)
curve(pt1, pt2, pt3)
strokepath()</code></pre></div><p><img src="assets/figures/curve.png" alt="curve"/></p><p><code>arc2r()</code> draws a circular arc that joins two points:  </p><div><pre><code class="language-julia">tiles = Tiler(700, 200, 1, 6)
for (pos, n) in tiles
    c1, pt2, pt3 = ngon(pos, rand(10:50), 3, rand(0:pi/12:2pi), vertices=true)
    sethue(&quot;black&quot;)
    map(pt -&gt; circle(pt, 4, :fill), [c1, pt3])
    sethue(&quot;red&quot;)
    circle(pt2, 4, :fill)
    randomhue()
    arc2r(c1, pt2, pt3, :stroke)
end</code></pre></div><p><img src="assets/figures/arc2r.png" alt="arc"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.arc" href="#Luxor.arc"><code>Luxor.arc</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going clockwise.</p><pre><code class="language-none">arc(xc, yc, radius, angle1, angle2, action=:nothing)</code></pre><p>Angles are defined relative to the x-axis, positive clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L119-L125">source</a><br/><div><p>Arc with centerpoint.</p><pre><code class="language-none">arc(centerpoint::Point, radius, angle1, angle2, action=:nothing)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L131-L135">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.arc2r" href="#Luxor.arc2r"><code>Luxor.arc2r</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">  arc2r(c1::Point, p2::Point, p3::Point, action=:nothing)</code></pre><p>Make a circular arc centered at <code>c1</code> that starts at <code>p2</code> and ends at <code>p3</code>, going clockwise.</p><p><code>c1</code>-<code>p2</code> really determines the radius. If <code>p3</code> doesn&#39;t lie on the circular path, it will be used only as an indication of the arc&#39;s length, rather than its position.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L155-L161">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.carc" href="#Luxor.carc"><code>Luxor.carc</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going counterclockwise.</p><pre><code class="language-none">carc(xc, yc, radius, angle1, angle2, action=:nothing)</code></pre><p>Angles are defined relative to the x-axis, positive clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L139-L145">source</a><br/><div><p>Add an arc centered at <code>centerpoint</code> to the current path from <code>angle1</code> to <code>angle2</code> going counterclockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L151">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.carc2r" href="#Luxor.carc2r"><code>Luxor.carc2r</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">carc2r(c1::Point, p2::Point, p3::Point, action=:nothing)</code></pre><p>Make a circular arc centered at <code>c1</code> that starts at <code>p2</code> and ends at <code>p3</code>, going counterclockwise.</p><p><code>c1</code>-<code>p2</code> really determines the radius. If <code>p3</code> doesn&#39;t lie on the circular path, it will be used only as an indication of the arc&#39;s length, rather than its position.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L172-L178">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.curve" href="#Luxor.curve"><code>Luxor.curve</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Add a Bézier curve.</p><pre><code class="language-none"> curve(x1, y1, x2, y2, x3, y3)
 curve(p1, p2, p3)</code></pre><p>The spline starts at the current position, finishing at <code>x3/y3</code> (<code>p3</code>), following two  control points <code>x1/y1</code> (<code>p1</code>) and <code>x2/y2</code> (<code>p2</code>)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L326-L335">source</a><br/></section><h2><a class="nav-anchor" id="Geometry-tools-1" href="#Geometry-tools-1">Geometry tools</a></h2><p>You can find the midpoint between two points using <code>midpoint()</code>.</p><p>The following code places a small pentagon (using <code>ngon()</code>) at the midpoint of each side of a larger pentagon:</p><div><pre><code class="language-julia">sethue(&quot;red&quot;)
ngon(O, 100, 5, 0, :stroke)

sethue(&quot;darkgreen&quot;)
p5 = ngon(O, 100, 5, 0, vertices=true)

for i in eachindex(p5)
    pt1 = p5[mod1(i, 5)]
    pt2 = p5[mod1(i + 1, 5)]
    ngon(midpoint(pt1, pt2), 20, 5, 0, :fill)
end</code></pre></div><p><img src="assets/figures/midpoint.png" alt="arc"/></p><p>A more general function, <code>between()</code>, finds for a value <code>x</code> between 0 and 1 the corresponding point on a line defined by two points. So <code>midpoint(p1, p2)</code> and <code>between(p1, p2, 0.5)</code> should return the same point.</p><div><pre><code class="language-julia">sethue(&quot;red&quot;)
p1 = Point(-150, 0)
p2 = Point(150, 40)
line(p1, p2)
strokepath()
for i in -0.5:0.1:1.5
    randomhue()
    circle(between(p1, p2, i), 5, :fill)
end</code></pre></div><p><img src="assets/figures/betweenpoint.png" alt="arc"/></p><p>Values less than 0.0 and greater than 1.0 appear to work well too, placing the point on the line if extended.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.midpoint" href="#Luxor.midpoint"><code>Luxor.midpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">midpoint(p1, p2)</code></pre><p>Find the midpoint between two points.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/point.jl#L119-L123">source</a><br/><div><pre><code class="language-none">midpoint(a)</code></pre><p>Find midpoint between the first two elements of an array of points.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/point.jl#L126-L130">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.between" href="#Luxor.between"><code>Luxor.between</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">between(p1::Point, p2::Point, x)
between((p1::Point, p2::Point), x)</code></pre><p>Find the point between point <code>p1</code> and point <code>p2</code> for <code>x</code>, where <code>x</code> is typically between 0 and 1, so these two should be equivalent:</p><pre><code class="language-none">between(p1, p2, 0.5)</code></pre><p>and</p><pre><code class="language-none">midpoint(p1, p2)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/point.jl#L133-L145">source</a><br/></section><p><code>center3pts()</code> finds the radius and center point of a circle passing through three points which you can then use with functions such as <code>circle()</code> or <code>arc2r()</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.center3pts" href="#Luxor.center3pts"><code>Luxor.center3pts</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">center3pts(a::Point, b::Point, c::Point)</code></pre><p>Find the radius and center point for three points lying on a circle.</p><p>returns <code>(centerpoint, radius)</code> of a circle. Then you can use <code>circle()</code> to place a circle, or <code>arc()</code> to draw an arc passing through those points.</p><p>If there&#39;s no such circle, then you&#39;ll see an error message in the console and the function returns <code>(Point(0,0), 0)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L38-L48">source</a><br/></section><p><code>intersection()</code> finds the intersection of two lines.</p><div><pre><code class="language-julia">pt1, pt2, pt3, pt4 = ngon(O, 100, 5, vertices=true)
line(pt1, pt2, :stroke)
line(pt3, pt4, :stroke)
flag, ip =  intersection(pt1, pt2, pt3, pt4)
if flag
    circle(ip, 5, :fill)
end</code></pre></div><p><img src="assets/figures/intersection.png" alt="arc"/></p><p><code>intersection_line_circle()</code> finds the intersection of a line and a circle. There can be 0, 1, or 2 intersection points.</p><div><pre><code class="language-julia">l1 = Point(-100.0, -75.0)
l2 = Point(300.0, 100.0)
rad = 100
cpoint = Point(0, 0)
line(l1, l2, :stroke)
circle(cpoint, rad, :stroke)
nints, ip1, ip2 =  intersection_line_circle(l1, l2, cpoint, rad)
sethue(&quot;black&quot;)
if nints == 2
    circle(ip1, 8, :stroke)
    circle(ip2, 8, :stroke)
end</code></pre></div><p><img src="assets/figures/intersection_line_circle.png" alt="arc"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.intersection" href="#Luxor.intersection"><code>Luxor.intersection</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">intersection(p1::Point, p2::Point, p3::Point, p4::Point)</code></pre><p>Find intersection of two lines <code>p1</code>-<code>p2</code> and <code>p3</code>-<code>p4</code></p><p>This returns a tuple: <code>(boolean, point(x, y))</code>.</p><p>Keyword options and default values:</p><pre><code class="language-none">crossingonly = false</code></pre><p>returns <code>(true, Point(x, y))</code> if the lines intersect somewhere. If <code>crossingonly = true</code>, returns <code>(false, intersectionpoint)</code> if the lines don&#39;t cross, but would intersect at <code>intersectionpoint</code> if continued beyond their current endpoints.</p><pre><code class="language-none">commonendpoints = false</code></pre><p>If <code>commonendpoints= true</code>, will return <code>(false, Point(0, 0))</code> if the lines share a common end point (because that&#39;s not so much an intersection, more a meeting).</p><p>Function returns <code>(false, Point(0, 0))</code> if the lines are undefined,</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/point.jl#L223-L244">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.intersection_line_circle" href="#Luxor.intersection_line_circle"><code>Luxor.intersection_line_circle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">intersection_line_circle(p1::Point, p2::Point, cpoint::Point, r)</code></pre><p>Find the intersection points of a line (extended through points <code>p1</code> and <code>p2</code>) and a circle.</p><p>Return a tuple of <code>(n, pt1, pt2)</code></p><p>where</p><ul><li><p><code>n</code> is the number of intersections, <code>0</code>, <code>1</code>, or <code>2</code></p></li><li><p><code>pt1</code> is first intersection point, or <code>Point(0, 0)</code> if none</p></li><li><p><code>pt2</code> is the second intersection point, or <code>Point(0, 0)</code> if none</p></li></ul><p>The calculated intersection points wont necessarily lie on the line segment between <code>p1</code> and <code>p2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/point.jl#L321-L335">source</a><br/></section><p><code>getnearestpointonline()</code> finds perpendiculars.</p><div><pre><code class="language-julia">end1, end2, pt3 = ngon(O, 100, 3, vertices=true)
map(pt -&gt; circle(pt, 5, :fill), [end1, end2, pt3])
line(end1, end2, :stroke)
arrow(pt3, getnearestpointonline(end1, end2, pt3))</code></pre></div><p><img src="assets/figures/perpendicular.png" alt="arc"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.getnearestpointonline" href="#Luxor.getnearestpointonline"><code>Luxor.getnearestpointonline</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getnearestpointonline(pt1::Point, pt2::Point, startpt::Point)</code></pre><p>Given a line from <code>pt1</code> to <code>pt2</code>, and <code>startpt</code> is the start of a perpendicular heading to meet the line, at what point does it hit the line?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/point.jl#L100-L105">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.pointlinedistance" href="#Luxor.pointlinedistance"><code>Luxor.pointlinedistance</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pointlinedistance(p::Point, a::Point, b::Point)</code></pre><p>Find the distance between a point <code>p</code> and a line between two points <code>a</code> and <code>b</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/point.jl#L85-L89">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.slope" href="#Luxor.slope"><code>Luxor.slope</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">slope(pointA::Point, pointB::Point)</code></pre><p>Find angle of a line starting at <code>pointA</code> and ending at <code>pointB</code>.</p><p>Return a value between 0 and 2pi. Value will be relative to the current axes.</p><pre><code class="language-none">slope(O, Point(0, 100)) |&gt; rad2deg # y is positive down the page
90.0

slope(Point(0, 100), O) |&gt; rad2deg
270.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/point.jl#L303-L316">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.perpendicular" href="#Luxor.perpendicular"><code>Luxor.perpendicular</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">perpendicular(p::Point)</code></pre><p>Returns point <code>Point(p.y, -p.x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/point.jl#L155-L159">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.@polar" href="#Luxor.@polar"><code>Luxor.@polar</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@polar (p)</code></pre><p>Convert a tuple of two numbers to a Point of x, y Cartesian coordinates.</p><pre><code class="language-none">@polar (10, pi/4)
@polar [10, pi/4]</code></pre><p>produces</p><pre><code class="language-none">Luxor.Point(7.0710678118654755,7.071067811865475)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/point.jl#L365-L376">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polar" href="#Luxor.polar"><code>Luxor.polar</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">polar(r, theta)</code></pre><p>Convert point in polar form (radius and angle) to a Point.</p><pre><code class="language-none">polar(10, pi/4)                                                                   09:19:38  v5   src</code></pre><p>produces</p><pre><code class="language-none">Luxor.Point(7.071067811865475,7.0710678118654755)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/point.jl#L383-L393">source</a><br/></section><h2><a class="nav-anchor" id="Arrows-1" href="#Arrows-1">Arrows</a></h2><p>You can draw lines or arcs with arrows at the end with <code>arrow()</code>. For straight arrows, supply the start and end points. For arrows as circular arcs, you provide center, radius, and start and finish angles. You can optionally provide dimensions for the <code>arrowheadlength</code> and <code>arrowheadangle</code> of the tip of the arrow (angle in radians between side and center). The default line weight is 1.0, equivalent to <code>setline(1)</code>), but you can specify another.</p><div><pre><code class="language-julia">arrow(O, Point(0, -65))
arrow(O, Point(100, -65), arrowheadlength=20, arrowheadangle=pi/4, linewidth=.3)
arrow(O, 100, pi, pi/2, arrowheadlength=25,   arrowheadangle=pi/12, linewidth=1.25)</code></pre></div><p><img src="assets/figures/arrow.png" alt="arrows"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.arrow" href="#Luxor.arrow"><code>Luxor.arrow</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">arrow(startpoint::Point, endpoint::Point;
    linewidth = 1.0,
    arrowheadlength = 10,
    arrowheadangle = pi/8)</code></pre><p>Draw a line between two points and add an arrowhead at the end. The arrowhead length will be the length of the side of the arrow&#39;s head, and the arrowhead angle is the angle between the sloping side of the arrowhead and the arrow&#39;s shaft.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>), and defaults to 1, but you can specify another value. It doesn&#39;t need stroking/filling, the shaft is stroked and the head filled with the current color.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/arrows.jl#L1-L15">source</a><br/><div><pre><code class="language-none">arrow(centerpos::Point, radius, startangle, endangle;
    linewidth = 1.0,
    arrowheadlength = 10,
    arrowheadangle = pi/8)</code></pre><p>Draw a curved arrow, an arc centered at <code>centerpos</code> starting at <code>startangle</code> and ending at <code>endangle</code> with an arrowhead at the end. Angles are measured clockwise from the positive x-axis.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>); you can specify the linewidth.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/arrows.jl#L55-L66">source</a><br/></section><h2><a class="nav-anchor" id="Julia-graphics-1" href="#Julia-graphics-1">Julia graphics</a></h2><p>A couple of functions in Luxor provide you with instant access to the Julia logo, and the three colored circles:</p><div><pre><code class="language-julia">for (pos, n) in Tiler(750, 250, 1, 2)
    gsave()
    translate(pos - Point(150, 100))
    if n == 1
        julialogo()
    elseif n == 2
        julialogo(action=:clip)
        for i in 1:500
            gsave()
            translate(rand(0:400), rand(0:250))
            juliacircles(10)
            grestore()
        end
        clipreset()
    end
    grestore()
end</code></pre></div><p><img src="assets/figures/julia-logo.png" alt="get path"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.julialogo" href="#Luxor.julialogo"><code>Luxor.julialogo</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">julialogo(;action=:fill, color=true)</code></pre><p>Draw the Julia logo. The default action is to fill the logo and use the colors:</p><pre><code class="language-none">julialogo()</code></pre><p>If <code>color</code> is <code>false</code>, the logo will use the current color, and the dots won&#39;t be colored in the usual way.</p><p>The logo&#39;s dimensions are about 330 wide and 240 high, and the <code>0/0</code> point is at the bottom left corner. To place the logo by locating its center, do this:</p><pre><code class="language-none">gsave()
translate(-165, -120)
julialogo() # locate center at 0/0
grestore()</code></pre><p>To use the logo as a clipping mask:</p><pre><code class="language-none">julialogo(action=:clip)</code></pre><p>(In this case the <code>color</code> setting is automatically ignored.)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/juliagraphics.jl#L3-L28">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.juliacircles" href="#Luxor.juliacircles"><code>Luxor.juliacircles</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">juliacircles(radius=100)</code></pre><p>Draw the three Julia circles in color centered at the origin.</p><p>The distance of the centers of the circles from the origin is <code>radius</code>. The optional keyword arguments <code>outercircleratio</code> (default 0.75) and <code>innercircleratio</code>  (default 0.65) control the radius of the individual colored circles relative to the <code>radius</code>.  So you can get relatively smaller or larger circles by adjusting the ratios.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/juliagraphics.jl#L188-L197">source</a><br/></section><h2><a class="nav-anchor" id="Miscellaneous-1" href="#Miscellaneous-1">Miscellaneous</a></h2><h3><a class="nav-anchor" id="Hypotrochoids-1" href="#Hypotrochoids-1">Hypotrochoids</a></h3><p><code>hypotrochoid()</code> makes hypotrochoids. The result is a polygon. You can either draw it directly, or pass it on for further polygon fun, as here, which uses <code>offsetpoly()</code> to trace round it a few times.</p><div><pre><code class="language-julia">origin()
background(&quot;grey15&quot;)
sethue(&quot;antiquewhite&quot;)
setline(1)
p = hypotrochoid(100, 25, 55, :stroke, stepby=0.01, vertices=true)
for i in 0:3:15
    poly(offsetpoly(p, i), :stroke, close=true)
end</code></pre></div><p><img src="assets/figures/hypotrochoid.png" alt="hypotrochoid"/></p><p>There&#39;s a matching <code>epitrochoid()</code> function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.hypotrochoid" href="#Luxor.hypotrochoid"><code>Luxor.hypotrochoid</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hypotrochoid(R, r, d, action=:none;
        stepby=0.01,
        period=0,
        vertices=false)</code></pre><p>Make a hypotrochoid with short line segments. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius <code>r</code> rolling around the inside  of a fixed circle of radius <code>R</code>, where the point is a distance <code>d</code> from  the center of the interior circle. Things get interesting if you supply non-integral values.</p><p>Special cases include the hypocycloid, if <code>d</code> = <code>r</code>, and an ellipse, if <code>R</code> = <code>2r</code>.</p><p><code>stepby</code>, the angular step value, controls the amount of detail, ie the smoothness of the polygon,</p><p>If <code>period</code> is not supplied, or 0, the lowest period is calculated for you.</p><p>The function can return a polygon (a list of points), or draw the points directly using the supplied <code>action</code>. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of <code>pi</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L431-L452">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.epitrochoid" href="#Luxor.epitrochoid"><code>Luxor.epitrochoid</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">epitrochoid(R, r, d, action=:none;
        stepby=0.01,
        period=0,
        vertices=false)</code></pre><p>Make a epitrochoid with short line segments. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius <code>r</code> rolling around the outside of a fixed circle of radius <code>R</code>, where the point is a distance <code>d</code> from the center of the circle. Things get interesting if you supply non-integral values.</p><p><code>stepby</code>, the angular step value, controls the amount of detail, ie the smoothness of the polygon.</p><p>If <code>period</code> is not supplied, or 0, the lowest period is calculated for you.</p><p>The function can return a polygon (a list of points), or draw the points directly using the supplied <code>action</code>. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of <code>pi</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/curves.jl#L477-L496">source</a><br/></section><h3><a class="nav-anchor" id="Grids-1" href="#Grids-1">Grids</a></h3><p>If you have to position items regularly, you might find a use for a grid. Luxor provides a simple grid utility. Grids are lazy: they&#39;ll supply the next point on the grid when you ask for it.</p><p>Define a rectangular grid with <code>GridRect</code>, and a hexagonal grid with <code>GridHex</code>. Get the next grid point from a grid with <code>nextgridpoint(grid)</code>.</p><div><pre><code class="language-julia">grid = GridRect(O, 40, 80, (10 - 1) * 40)
for i in 1:20
    randomhue()
    p = nextgridpoint(grid)
    squircle(p, 20, 20, :fill)
    sethue(&quot;white&quot;)
    text(string(i), p, halign=:center)
end</code></pre></div><p><img src="assets/figures/grids.png" alt="grids"/></p><div><pre><code class="language-julia">radius = 70
grid = GridHex(O, radius, 600)

arrow(O, Point(O.x + (sqrt(3) * radius)/2, 0))

for i in 1:15
    randomhue()
    p = nextgridpoint(grid)
    ngon(p, radius-5, 6, pi/2, :fillstroke)
    sethue(&quot;white&quot;)
    text(string(i), p, halign=:center)
end</code></pre></div><p><img src="assets/figures/grid-hex.png" alt="grids"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.GridRect" href="#Luxor.GridRect"><code>Luxor.GridRect</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GridRect(startpoint, xspacing, yspacing, width, height)</code></pre><p>Define a rectangular grid, to start at <code>startpoint</code> and proceed along the x-axis in steps of <code>xspacing</code>, then along the y-axis in steps of <code>yspacing</code>.</p><pre><code class="language-none">GridRect(startpoint, xspacing=100.0, yspacing=100.0, width=1200.0, height=1200.0)</code></pre><p>For a column, set the <code>xspacing</code> to 0:</p><pre><code class="language-none">grid = GridRect(O, 0, 40)</code></pre><p>To get points from the grid, use <code>nextgridpoint(g::Grid)</code>.</p><pre><code class="language-none">julia&gt; grid = GridRect(O, 0, 40);
julia&gt; nextgridpoint(grid)
Luxor.Point(0.0,0.0)

julia&gt; nextgridpoint(grid)
Luxor.Point(0.0,40.0)</code></pre><p>When you run out of grid points, you&#39;ll wrap round and start again.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/tiles-grids.jl#L99-L121">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.GridHex" href="#Luxor.GridHex"><code>Luxor.GridHex</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">GridHex(startpoint, radius, width=1200.0, height=1200.0)</code></pre><p>Define a hexagonal grid, to start at <code>startpoint</code> and proceed along the x-axis and then along the y-axis, <code>radius</code> is the radius of a circle that encloses each hexagon. The distance in <code>x</code> between the centers of successive hexagons is:</p><div>\[\frac{\sqrt{(3)} radius}{2}\]</div><p>To get the next point from the grid, use <code>nextgridpoint(g::Grid)</code>.</p><p>When you run out of grid points, you&#39;ll wrap round and start again.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/tiles-grids.jl#L141">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.nextgridpoint" href="#Luxor.nextgridpoint"><code>Luxor.nextgridpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">nextgridpoint(g::GridRect)</code></pre><p>Returns the next available (or even the first) grid point of a grid.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/tiles-grids.jl#L173-L177">source</a><br/><div><pre><code class="language-none">nextgridpoint(g::GridHex)</code></pre><p>Returns the next available grid point of a hexagonal grid.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/tiles-grids.jl#L201-L205">source</a><br/></section><h3><a class="nav-anchor" id="Cropmarks-1" href="#Cropmarks-1">Cropmarks</a></h3><p>If you want cropmarks (aka trim marks), use the <code>cropmarks()</code> function, supplying the centerpoint, followed by the width and height:</p><pre><code class="language-none">cropmarks(O, 1200, 1600)
cropmarks(O, paper_sizes[&quot;A0&quot;]...)</code></pre><div><pre><code class="language-julia">sethue(&quot;red&quot;)
box(O, 150, 150, :stroke)
cropmarks(O, 150, 150)</code></pre></div><p><img src="assets/figures/cropmarks.png" alt="cropmarks"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.cropmarks" href="#Luxor.cropmarks"><code>Luxor.cropmarks</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cropmarks(center, width, height)</code></pre><p>Draw cropmarks (also known as trim marks).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/18f71b83cdbaeaf69755c67d657d48f15a8e2b1b/src/shapes.jl#L213-L217">source</a><br/></section><footer><hr/><a class="previous" href="basics.html"><span class="direction">Previous</span><span class="title">Basic concepts</span></a><a class="next" href="colors-styles.html"><span class="direction">Next</span><span class="title">Colors and styles</span></a></footer></article></body></html>

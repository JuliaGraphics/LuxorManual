var documenterSearchIndex = {"docs":
[{"location":"turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"turtle/#Turtle-graphics","page":"Turtle graphics","title":"Turtle graphics","text":"","category":"section"},{"location":"turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"Some simple \"turtle graphics\" functions are included. Functions to control the turtle begin with a capital letter: Forward, Turn, Circle, Orientation, Towards, Rectangle, Pendown, Penup, Pencolor, Penwidth, and Reposition, and so on, and angles are specified in degrees.","category":"page"},{"location":"turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"using Luxor, Colors\nDrawing(600, 400, \"assets/figures/turtles.png\")  \norigin()  \nbackground(\"midnightblue\")  \n\nüê¢ = Turtle() # you can type the turtle emoji with \\:turtle:\nPencolor(üê¢, \"cyan\")\nPenwidth(üê¢, 1.5)\nn = 5\nfor i in 1:400\n    global n\n    Forward(üê¢, n)\n    Turn(üê¢, 89.5)\n    HueShift(üê¢)\n    n += 0.75\nend\nfontsize(20)\nMessage(üê¢, \"finished\")\nfinish()  \nnothing # hide","category":"page"},{"location":"turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"(Image: turtles)","category":"page"},{"location":"turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"The turtle commands expect a reference to a turtle as the first argument (it doesn't have to be a turtle emoji!), and you can have any number of turtles active at a time.","category":"page"},{"location":"turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"using Luxor, Colors # hide\nDrawing(800, 800, \"assets/figures/manyturtles.svg\") # hide\norigin() # hide\nbackground(\"white\") # hide\nquantity = 9\nturtles = [Turtle(O, true, 2œÄ * rand(), (rand(), rand(), 0.5)...) for i in 1:quantity]\nReposition.(turtles, first.(collect(Tiler(800, 800, 3, 3))))\nn = 10\nPenwidth.(turtles, 0.5)\nfor i in 1:300\n    global n\n    Forward.(turtles, n)\n    HueShift.(turtles)\n    Turn.(turtles, [60.1, 89.5, 110, 119.9, 120.1, 135.1, 145.1, 176, 190])\n    n += 0.5\nend\nfinish() # hide  \nnothing # hide","category":"page"},{"location":"turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"(Image: many turtles)","category":"page"},{"location":"turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"A turtle graphics approach lends itself well to recursive programming. This short recursive function draws a Hilbert curve.","category":"page"},{"location":"turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"using Luxor, Colors # hide\nDrawing(400, 400, \"assets/figures/hilbertturtle.svg\") # hide\norigin() # hide\nbackground(\"black\") # hide\n\nfunction hilbert(t::Turtle, level, angle, lengthstep)\n    level == 0 && return\n\n    HueShift(t, 0.1)\n\n    Turn(t, angle)\n    hilbert(t, level-1, -angle, lengthstep)\n\n    Forward(t, lengthstep)\n    Turn(t, -angle)\n    hilbert(t, level-1, angle, lengthstep)\n\n    Forward(t, lengthstep)\n    hilbert(t, level-1, angle, lengthstep)\n\n    Turn(t, -angle)\n    Forward(t, lengthstep)\n    hilbert(t, level-1, -angle, lengthstep)\n\n    Turn(t, angle)\nend\n\n@draw begin\nbackground(\"black\")\nsetline(2)\nsetlinecap(\"round\")\n\nhilbert(Turtle(first(BoundingBox()) + (12, 12), true, 0, (1, 0, 0)),\n        6,  # level\n        90, # turn angle, in degrees\n        6   # steplength\n        )\nend\nnothing # hide","category":"page"},{"location":"turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"(Image: hilbert turtle)","category":"page"},{"location":"turtle/","page":"Turtle graphics","title":"Turtle graphics","text":"Turtle\nForward\nTurn\nCircle\nHueShift\nMessage\nOrientation\nTowards\nRandomize_saturation\nRectangle\nPen_opacity_random\nPendown\nPenup\nPencolor\nPenwidth\nPoint\nPop\nPush\nReposition","category":"page"},{"location":"turtle/#Luxor.Turtle","page":"Turtle graphics","title":"Luxor.Turtle","text":"Turtle()\nTurtle(O)\nTurtle(0, 0)\nTurtle(O, pendown=true, orientation=0, pencolor=(1.0, 0.25, 0.25))\n\nCreate a Turtle. You can command a turtle to move and draw \"turtle graphics\".\n\nThe commands (unusually for Julia) start with a capital letter, and angles are specified in degrees.\n\nBasic commands are Forward(), Turn(), Pendown(), Penup(), Pencolor(), Penwidth(), Circle(), Orientation(), Rectangle(), and Reposition().\n\nOthers include Push(), Pop(), Message(), HueShift(), Randomize_saturation(), Reposition(), and Pen_opacity_random().\n\n\n\n\n\n","category":"type"},{"location":"turtle/#Luxor.Forward","page":"Turtle graphics","title":"Luxor.Forward","text":"Forward(t::Turtle, d=1)\n\nMove the turtle forward by d units. The stored position is updated.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Turn","page":"Turtle graphics","title":"Luxor.Turn","text":"Turn(t::Turtle, r=5.0)\n\nIncrease the turtle's rotation by r degrees. See also Orientation.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Circle","page":"Turtle graphics","title":"Luxor.Circle","text":"Circle(t::Turtle, radius=1.0)\n\nDraw a filled circle centered at the current position with the given radius.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.HueShift","page":"Turtle graphics","title":"Luxor.HueShift","text":"HueShift(t::Turtle, inc=1.0)\n\nShift the Hue of the turtle's pen forward by inc. Hue values range between 0 and 360. (Don't start with black, otherwise the saturation and brightness values will be black.)\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Message","page":"Turtle graphics","title":"Luxor.Message","text":"Message(t::Turtle, txt)\n\nWrite some text at the current position.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Orientation","page":"Turtle graphics","title":"Luxor.Orientation","text":"Orientation(t::Turtle, r=0.0)\n\nSet the turtle's orientation to r degrees. See also Turn.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Towards","page":"Turtle graphics","title":"Luxor.Towards","text":"Towards(t::Turtle, pos::Point)\n\nRotate the turtle to face towards a given point.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Randomize_saturation","page":"Turtle graphics","title":"Luxor.Randomize_saturation","text":"Randomize_saturation(t::Turtle)\n\nRandomize the saturation of the turtle's pen color.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Rectangle","page":"Turtle graphics","title":"Luxor.Rectangle","text":"Rectangle(t::Turtle, width=10.0, height=10.0)\n\nDraw a filled rectangle centered at the current position with the given radius.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Pen_opacity_random","page":"Turtle graphics","title":"Luxor.Pen_opacity_random","text":"Pen_opacity_random(t::Turtle)\n\nChange the opacity of the pen to some value at random.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Pendown","page":"Turtle graphics","title":"Luxor.Pendown","text":"Pendown(t::Turtle)\n\nPut that pen down and start drawing.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Penup","page":"Turtle graphics","title":"Luxor.Penup","text":"Penup(t::Turtle)\n\nPick that pen up and stop drawing.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Pencolor","page":"Turtle graphics","title":"Luxor.Pencolor","text":"Pencolor(t::Turtle, r, g, b)\n\nSet the Red, Green, and Blue colors of the turtle.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Penwidth","page":"Turtle graphics","title":"Luxor.Penwidth","text":"Penwidth(t::Turtle, w)\n\nSet the width of the line drawn.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Point","page":"Turtle graphics","title":"Luxor.Point","text":"The Point type holds two coordinates. It's immutable, you can't change the values of the x and y values directly.\n\n\n\n\n\n","category":"type"},{"location":"turtle/#Luxor.Pop","page":"Turtle graphics","title":"Luxor.Pop","text":"Pop(t::Turtle)\n\nLift the turtle's position and orientation off a stack.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Push","page":"Turtle graphics","title":"Luxor.Push","text":"Push(t::Turtle)\n\nSave the turtle's position and orientation on a stack.\n\n\n\n\n\n","category":"function"},{"location":"turtle/#Luxor.Reposition","page":"Turtle graphics","title":"Luxor.Reposition","text":"Reposition(t::Turtle, pos::Point)\nReposition(t::Turtle, x, y)\n\nReposition: pick the turtle up and place it at another position.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"colors-styles/#Colors-and-styles","page":"Colors and styles","title":"Colors and styles","text":"","category":"section"},{"location":"colors-styles/#Color-and-opacity","page":"Colors and styles","title":"Color and opacity","text":"","category":"section"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"For color definitions and conversions, you can use Colors.jl.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"setcolor() and sethue() will apply a single solid or transparent color to new graphics.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"setblend() will apply a smooth transition between two or more colors to new graphics.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"setmesh() will apply a color mesh to new graphics.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"The difference between the setcolor() and sethue() functions is that sethue() doesn't change alpha opacity (transparency), so you can change the hue without changing the current alpha opacity (transparency) value.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"Named colors, such as \"gold\", or \"lavender\", can be found in Colors.color_names dictionary.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor, Colors # hide\nDrawing(800, 800, \"assets/figures/colors.svg\") # hide\n\norigin() # hide\nbackground(\"white\") # hide\nfontface(\"AvenirNextCondensed-Regular\") # hide\nfontsize(8)\ncols = sort(collect(Colors.color_names))\nncols = 15\nnrows = convert(Int, ceil(length(cols) / ncols))\ntable = Table(nrows, ncols, 800/ncols, 800/nrows)\ngamma = 2.2\nfor n in 1:length(cols)\n    col = cols[n][1]\n    r, g, b = sethue(col)\n    box(table[n], table.colwidths[1], table.rowheights[1], :fill)\n    luminance = 0.2126 * r^gamma + 0.7152 * g^gamma + 0.0722 * b^gamma\n    (luminance > 0.5^gamma) ? sethue(\"black\") : sethue(\"white\")\n    text(string(cols[n][1]), table[n], halign=:center, valign=:middle)\nend\nfinish() # hide\n\nnothing #hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: line endings)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(To make the label stand out against the background, the luminance is calculated, then used to choose the label's color.)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"sethue\nsetcolor\nsetgray\nsetopacity\nrandomhue\nrandomcolor\nsetblend\nsetantialias","category":"page"},{"location":"colors-styles/#Luxor.sethue","page":"Colors and styles","title":"Luxor.sethue","text":"sethue(\"black\")\nsethue(0.3, 0.7, 0.9)\nsetcolor(sethue(\"red\")..., .2)\n\nSet the color without changing opacity.\n\nsethue() is like setcolor(), but we sometimes want to change the current color without changing alpha/opacity. Using sethue() rather than setcolor() doesn't change the current alpha opacity.\n\nSee also setcolor.\n\n\n\n\n\nsethue(col::Colors.Colorant)\n\nSet the color without changing the current alpha/opacity:\n\n\n\n\n\nsethue(0.3, 0.7, 0.9)\n\nSet the color's r, g, b values. Use setcolor(r, g, b, a) to set transparent colors.\n\n\n\n\n\nsethue((r, g, b))\n\nSet the color to the tuple's values.\n\n\n\n\n\nsethue((r, g, b, a))\n\nSet the color to the tuple's values.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.setcolor","page":"Colors and styles","title":"Luxor.setcolor","text":"setcolor(\"gold\")\nsetcolor(\"darkturquoise\")\n\nSet the current color to a named color. This use the definitions in Colors.jl to convert a string to RGBA eg setcolor(\"gold\") or \"green\", \"darkturquoise\", \"lavender\", etc. The list is at Colors.color_names.\n\nUse sethue() for changing colors without changing current opacity level.\n\nsethue() and setcolor() return the three or four values that were used:\n\njulia> setcolor(sethue(\"red\")..., .8)\n\n(1.0, 0.0, 0.0, 0.8)\n\njulia> sethue(setcolor(\"red\")[1:3]...)\n\n(1.0, 0.0, 0.0)\n\nYou can also do:\n\nusing Colors\nsethue(colorant\"red\")\n\nSee also setcolor.\n\n\n\n\n\nsetcolor(r, g, b)\nsetcolor(r, g, b, alpha)\nsetcolor(color)\nsetcolor(col::Colors.Colorant)\nsetcolor(sethue(\"red\")..., .2)\n\nSet the current color.\n\nExamples:\n\nsetcolor(convert(Colors.HSV, Colors.RGB(0.5, 1, 1)))\nsetcolor(.2, .3, .4, .5)\nsetcolor(convert(Colors.HSV, Colors.RGB(0.5, 1, 1)))\n\nfor i in 1:15:360\n   setcolor(convert(Colors.RGB, Colors.HSV(i, 1, 1)))\n   ...\nend\n\nSee also sethue.\n\n\n\n\n\nsetcolor((r, g, b))\n\nSet the color to the tuple's values.\n\n\n\n\n\nsetcolor((r, g, b, a))\n\nSet the color to the tuple's values.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.setgray","page":"Colors and styles","title":"Luxor.setgray","text":"setgray(n)\nsetgrey(n)\n\nSet the color to a gray level of n, where n is between 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.setopacity","page":"Colors and styles","title":"Luxor.setopacity","text":"setopacity(alpha)\n\nSet the current opacity to a value between 0 and 1. This modifies the alpha value of the current color.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.randomhue","page":"Colors and styles","title":"Luxor.randomhue","text":"randomhue()\n\nSet a random hue, without changing the current alpha opacity.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.randomcolor","page":"Colors and styles","title":"Luxor.randomcolor","text":"randomcolor()\n\nSet a random color. This may change the current alpha opacity too.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.setblend","page":"Colors and styles","title":"Luxor.setblend","text":"setblend(blend)\n\nStart using the named blend for filling graphics.\n\nThis aligns the original coordinates of the blend definition with the current axes.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.setantialias","page":"Colors and styles","title":"Luxor.setantialias","text":"setantialias(n)\n\nSet the current antialiasing to a value between 0 and 6:\n\nantialias_default  = 0, the default antialiasing for the subsystem and target device\nantialias_none     = 1, use a bilevel alpha mask\nantialias_gray     = 2, use single-color antialiasing (using shades of gray for black text on a white background, for example)\nantialias_subpixel = 3, take advantage of the order of subpixel elements on devices such as LCD panels\nantialias_fast     = 4, perform some antialiasing but prefer speed over quality\nantialias_good     = 5, balance quality against performance\nantialias_best     = 6, render at the highest quality, sacrificing speed if necessary\n\nThis affects graphics, but not text, and it doesn't apply to all types of output file.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Line-styles","page":"Colors and styles","title":"Line styles","text":"","category":"section"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"There are set- functions for controlling subsequent lines' width, end shape, join behavior, and dash pattern:","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(400, 250, \"assets/figures/line-ends.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\ntranslate(-100, -60) # hide\nfontsize(18) # hide\nfor l in 1:3\n    sethue(\"black\")\n    setline(20)\n    setlinecap([\"butt\", \"square\", \"round\"][l])\n    textcentred([\"butt\", \"square\", \"round\"][l], 80l, 80)\n    setlinejoin([\"round\", \"miter\", \"bevel\"][l])\n    textcentred([\"round\", \"miter\", \"bevel\"][l], 80l, 120)\n    poly(ngon(Point(80l, 0), 20, 3, 0, vertices=true), :strokepreserve, close=false)\n    sethue(\"white\")\n    setline(1)\n    strokepath()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: line endings)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/dashes.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nfontsize(14) # hide\nsethue(\"black\") # hide\n\npatterns = [\"solid\", \"dotted\", \"dot\", \"dotdashed\", \"longdashed\",\n  \"shortdashed\", \"dash\", \"dashed\", \"dotdotdashed\", \"dotdotdotdashed\"]\nsetline(12)\n\ntable = Table(fill(20, length(patterns)), [50, 300])\ntext.(patterns, table[:, 1], halign=:right, valign=:middle)\n\nfor p in 1:length(patterns)\n    setdash(patterns[p])\n    pt = table[p, 2]\n    line(pt - (150, 0), pt + (150, 0), :stroke)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: dashes)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"To define more complicated dash patterns in Luxor, pass a vector to setdash().","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"dashes = [50.0,  # ink\n          10.0,  # skip\n          10.0,  # ink\n          10.0   # skip\n          ]\nsetdash(dashes)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(600, 180, \"assets/figures/moredashes.svg\") # hide\nbackground(\"white\") # hide\norigin() # hide\nfunction dashing()\n    fontsize(12) # hide\n    sethue(\"black\") # hide\n    setline(8)\n    setlinecap(\"butt\")\n    patterns = [10, 4, 50, 25, 14, 100]\n    table = Table(fill(20, length(patterns)), [40, 325])\n    for p in 1:length(patterns)\n        setdash(patterns)\n        pt = table[p, 2]\n        text(string(patterns), table[p, 1], halign=:right, valign=:middle)        \n        line(pt - (150, 0), pt + (200, 0), :stroke)\n        patterns = circshift(patterns, 1)\n        pop!(patterns)\n    end\nend\n\ndashing()\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: more dashes)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"Notice that odd-numbered patterns flip the ink and skip numbers each time through.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"setline\nsetlinecap\nsetlinejoin\nsetdash\nfillstroke\nstrokepath\nfillpath\nstrokepreserve\nfillpreserve\npaint\ndo_action","category":"page"},{"location":"colors-styles/#Luxor.setline","page":"Colors and styles","title":"Luxor.setline","text":"setline(n)\n\nSet the line width, in points.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.setlinecap","page":"Colors and styles","title":"Luxor.setlinecap","text":"setlinecap(s)\n\nSet the line ends. s can be \"butt\" or :butt (the default), \"square\" or :square, or \"round\" or :round.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.setlinejoin","page":"Colors and styles","title":"Luxor.setlinejoin","text":"setlinejoin(\"miter\")\nsetlinejoin(\"round\")\nsetlinejoin(\"bevel\")\n\nSet the line join style, or how to render the junction of two lines when stroking.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.setdash","page":"Colors and styles","title":"Luxor.setdash","text":"setdash(\"dot\")\n\nSet the dash pattern to one of: \"solid\", \"dotted\", \"dot\", \"dotdashed\", \"longdashed\", \"shortdashed\", \"dash\", \"dashed\", \"dotdotdashed\", \"dotdotdotdashed\".\n\nUse setdash(dashes::Vector) to specify the pattern numerically.\n\n\n\n\n\nsetdash(dashes::Vector, offset=0.0)\n\nSet the dash pattern to the values in dashes. The first number is the length of the ink, the second the gap, and so on.\n\nThe offset specifies an offset into the pattern at which the stroke begins. So an offset of 10 means that the stroke starts at dashes[1] + 10 into the pattern.\n\nOr use setdash(\"dot\") etc.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.fillstroke","page":"Colors and styles","title":"Luxor.fillstroke","text":"fillstroke()\n\nFill and stroke the current path.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.strokepath","page":"Colors and styles","title":"Luxor.strokepath","text":"strokepath()\n\nStroke the current path with the current line width, line join, line cap, and dash settings. The current path is then cleared.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.fillpath","page":"Colors and styles","title":"Luxor.fillpath","text":"fillpath()\n\nFill the current path according to the current settings. The current path is then cleared.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.strokepreserve","page":"Colors and styles","title":"Luxor.strokepreserve","text":"strokepreserve()\n\nStroke the current path with current line width, line join, line cap, and dash settings, but then keep the path current.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.fillpreserve","page":"Colors and styles","title":"Luxor.fillpreserve","text":"fillpreserve()\n\nFill the current path with current settings, but then keep the path current.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.paint","page":"Colors and styles","title":"Luxor.paint","text":"paint()\n\nPaint the current clip region with the current settings.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.do_action","page":"Colors and styles","title":"Luxor.do_action","text":"do_action(action)\n\nThis is usually called by other graphics functions. Actions for graphics commands include :fill, :stroke, :clip, :fillstroke, :fillpreserve, :strokepreserve, :none, and :path.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Blends","page":"Colors and styles","title":"Blends","text":"","category":"section"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"A blend is a color gradient. Use setblend() to select a blend in the same way that you'd use setcolor() and sethue() to select a solid color.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"You can make linear or radial blends. Use blend() in either case.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"To create a simple linear blend between two colors, supply two points and two colors to blend():","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(600, 200, \"assets/figures/color-blends-basic.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\norangeblue = blend(Point(-200, 0), Point(200, 0), \"orange\", \"blue\")\nsetblend(orangeblue)\nbox(O, 400, 100, :fill)\nrulers()\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: linear blend)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"And for a radial blend, provide two point/radius pairs, and two colors:","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(600, 200, \"assets/figures/color-blends-radial.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\ngreenmagenta = blend(Point(0, 0), 5, Point(0, 0), 150, \"green\", \"magenta\")\nsetblend(greenmagenta)\nbox(O, 400, 200, :fill)\nrulers()\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: radial blends)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"You can also use blend() to create an empty blend. Then you use addstop() to define the locations of specific colors along the blend, where 0 is the start, and 1 is the end.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(600, 200, \"assets/figures/color-blends-scratch.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\ngoldblend = blend(Point(-200, 0), Point(200, 0))\naddstop(goldblend, 0.0,  \"gold4\")\naddstop(goldblend, 0.25, \"gold1\")\naddstop(goldblend, 0.5,  \"gold3\")\naddstop(goldblend, 0.75, \"darkgoldenrod4\")\naddstop(goldblend, 1.0,  \"gold2\")\nsetblend(goldblend)\nbox(O, 400, 200, :fill)\nrulers()\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: blends from scratch)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"When you define blends, the location of the axes (eg the current workspace as defined by translate(), etc.), is important. In the first of the two following examples, the blend is selected before the axes are moved with translate(pos). The blend 'samples' the original location of the blend's definition.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(600, 200, \"assets/figures/color-blends-translate-1.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\ngoldblend = blend(Point(0, 0), Point(200, 0))\naddstop(goldblend, 0.0,  \"gold4\")\naddstop(goldblend, 0.25, \"gold1\")\naddstop(goldblend, 0.5,  \"gold3\")\naddstop(goldblend, 0.75, \"darkgoldenrod4\")\naddstop(goldblend, 1.0,  \"gold2\")\nsetblend(goldblend)\ntiles = Tiler(600, 200, 1, 5, margin=10)\nfor (pos, n) in tiles\n    gsave()\n    setblend(goldblend)\n    translate(pos)\n    ellipse(O, tiles.tilewidth, tiles.tilewidth, :fill)\n    grestore()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: blends 1)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"Outside the range of the original blend's definition, the same color is used, no matter how far away from the origin you go (there are Cairo options to change this). But in the next example, the blend is relocated to the current axes, which have just been moved to the center of the tile. The blend refers to 0/0 each time, which is at the center of shape.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(600, 200, \"assets/figures/color-blends-translate-2.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\ngoldblend = blend(Point(0, 0), Point(200, 0))\naddstop(goldblend, 0.0,  \"gold4\")\naddstop(goldblend, 0.25, \"gold1\")\naddstop(goldblend, 0.5,  \"gold3\")\naddstop(goldblend, 0.75, \"darkgoldenrod4\")\naddstop(goldblend, 1.0,  \"gold2\")\nsetblend(goldblend)\ntiles = Tiler(600, 200, 1, 5, margin=10)\nfor (pos, n) in tiles\n    gsave()\n    translate(pos)\n    setblend(goldblend)\n    ellipse(O, tiles.tilewidth, tiles.tilewidth, :fill)\n    grestore()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: blends 2)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"blend\naddstop","category":"page"},{"location":"colors-styles/#Luxor.blend","page":"Colors and styles","title":"Luxor.blend","text":"blend(from::Point, to::Point)\n\nCreate an empty linear blend.\n\nA blend is a specification of how one color changes into another. Linear blends are defined by two points: parallel lines through these points define the start and stop locations of the blend. The blend is defined relative to the current axes origin. This means that you should be aware of the current axes when you define blends, and when you use them.\n\nTo add colors, use addstop().\n\n\n\n\n\nblend(centerpos1, rad1, centerpos2, rad2, color1, color2)\n\nCreate a radial blend.\n\nExample:\n\nredblue = blend(\n    pos, 0,                   # first circle center and radius\n    pos, tiles.tilewidth/2,   # second circle center and radius\n    \"red\",\n    \"blue\"\n    )\n\n\n\n\n\nblend(pt1::Point, pt2::Point, color1, color2)\n\nCreate a linear blend.\n\nExample:\n\nredblue = blend(pos, pos, \"red\", \"blue\")\n\n\n\n\n\nblend(from::Point, startradius, to::Point, endradius)\n\nCreate an empty radial blend.\n\nRadial blends are defined by two circles that define the start and stop locations. The first point is the center of the start circle, the first radius is the radius of the first circle.\n\nA new blend is empty. To add colors, use addstop().\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.addstop","page":"Colors and styles","title":"Luxor.addstop","text":"addstop(b::Blend, offset, col)\naddstop(b::Blend, offset, (r, g, b, a))\naddstop(b::Blend, offset, string)\n\nAdd a color stop to a blend. The offset specifies the location along the blend's 'control vector', which varies between 0 (beginning of the blend) and 1 (end of the blend). For linear blends, the control vector is from the start point to the end point. For radial blends, the control vector is from any point on the start circle, to the corresponding point on the end circle.\n\nExamples:\n\nblendredblue = blend(Point(0, 0), 0, Point(0, 0), 1)\naddstop(blendredblue, 0, setcolor(sethue(\"red\")..., .2))\naddstop(blendredblue, 1, setcolor(sethue(\"blue\")..., .2))\naddstop(blendredblue, 0.5, sethue(randomhue()...))\naddstop(blendredblue, 0.5, setcolor(randomcolor()...))\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Using-blendadjust()","page":"Colors and styles","title":"Using blendadjust()","text":"","category":"section"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"You can use blendadjust() to modify the blend so that objects scaled and positioned after the blend was defined are rendered correctly.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/blend-adjust.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(20)\n\n# first line\nblendgoldmagenta = blend(Point(-100, 0), Point(100, 0), \"gold\", \"magenta\")\nsetblend(blendgoldmagenta)\nline(Point(-100, -50), Point(100, -50))\nstrokepath()\n\n# second line\nblendadjust(blendgoldmagenta, Point(50, 0), 0.5, 0.5)\nline(O, Point(100, 0))\nstrokepath()\n\n# third line\nblendadjust(blendgoldmagenta, Point(-50, 50), 0.5, 0.5)\nline(Point(-100, 50), Point(0, 50))\nstrokepath()\n\n# fourth line\ngsave()\ntranslate(0, 100)\nscale(0.5, 0.5)\nsetblend(blendgoldmagenta)\nline(Point(-100, 0), Point(100, 0))\nstrokepath()\ngrestore()\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: blends adjust)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"The blend is defined to span 200 units, horizontally centered at 0/0. The top line is also 200 units long and centered horizontally at 0/0, so the blend is rendered exactly as you'd hope.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"The second line is only half as long, at 100 units, centered at 50/0, so blendadjust() is used to relocate the blend's center to the point 50/0 and scale it by 0.5 (100/200).","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"The third line is also 100 units long, centered at -50/0, so again blendadjust() is used to relocate the blend's center and scale it.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"The fourth line shows that you can translate and scale the axes instead of adjusting the blend, if you use setblend() again in the new scene.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"blendadjust","category":"page"},{"location":"colors-styles/#Luxor.blendadjust","page":"Colors and styles","title":"Luxor.blendadjust","text":"blendadjust(ablend, center::Point, xscale, yscale, rot=0)\n\nModify an existing blend by scaling, translating, and rotating it so that it will fill a shape properly even if the position of the shape is nowhere near the original location of the blend's definition.\n\nFor example, if your blend definition was this (notice the 1)\n\nblendgoldmagenta = blend(\n        Point(0, 0), 0,                   # first circle center and radius\n        Point(0, 0), 1,                   # second circle center and radius\n        \"gold\",\n        \"magenta\"\n        )\n\nyou can use it in a shape that's 100 units across and centered at pos, by calling this:\n\nblendadjust(blendgoldmagenta, Point(pos.x, pos.y), 100, 100)\n\nthen use setblend():\n\nsetblend(blendgoldmagenta)\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Blending-(compositing)-operators","page":"Colors and styles","title":"Blending (compositing) operators","text":"","category":"section"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"Graphics software provides ways to modify how the virtual \"ink\" is applied to previously-drawn graphic elements. In PhotoShop and other software, the compositing process is done using blend modes.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"Use setmode() to set the blending mode of subsequent graphics.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(600, 600, \"assets/figures/blendmodes.png\") # hide\norigin()\n# transparent, no background\nfontsize(15)\nsetline(1)\ntiles = Tiler(600, 600, 4, 5, margin=30)\nmodes = length(Luxor.blendingmodes)\nsetcolor(\"black\")\nfor (pos, n) in tiles\n    n > modes && break\n    gsave()\n    translate(pos)\n    box(O, tiles.tilewidth-10, tiles.tileheight-10, :clip)\n\n    # calculate points for circles\n    diag = (Point(-tiles.tilewidth/2, -tiles.tileheight/2),\n            Point(tiles.tilewidth/2,  tiles.tileheight/2))\n    upper = between(diag, 0.4)\n    lower = between(diag, 0.6)\n\n    # first red shape uses default blend operator\n    setcolor(0.7, 0, 0, .8)\n    circle(upper, tiles.tilewidth/4, :fill)\n\n    # second blue shape shows results of blend operator\n    setcolor(0, 0, 0.9, 0.4)\n    blendingmode = Luxor.blendingmodes[mod1(n, modes)]\n    setmode(blendingmode)\n    circle(lower, tiles.tilewidth/4, :fill)\n\n    clipreset()\n    grestore()\n\n    gsave()\n    translate(pos)\n    text(Luxor.blendingmodes[mod1(n, modes)], O.x, O.y + tiles.tilewidth/2, halign=:center)\n    grestore()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: blend modes)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"Notice in this example that clipping was used to restrict the area affected by the blending process.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"In Cairo, these blend modes are called operators. For a more detailed explanation, refer to the Cairo documentation.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"You can access the list of modes with the unexported symbol Luxor.blendingmodes.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"setmode\ngetmode","category":"page"},{"location":"colors-styles/#Luxor.setmode","page":"Colors and styles","title":"Luxor.setmode","text":"setmode(mode::AbstractString)\n\nSet the compositing/blending mode. mode can be one of:\n\n\"clear\" Where the second object is drawn, the first is completely removed.\n\"source\" The second object is drawn as if nothing else were below.\n\"over\" The default mode: like two transparent slides overlapping.\n\"in\" The first object is removed completely, the second is only drawn where the first was.\n\"out\" The second object is drawn only where the first one wasn't.\n\"atop\" The first object is mostly intact, but mixes both objects in the overlapping area. The second object object is not drawn elsewhere.\n\"dest\" Discard the second object completely.\n\"dest_over\" Like \"over\" but draw second object below the first\n\"dest_in\" Keep the first object whereever the second one overlaps.\n\"dest_out\" The second object is used to reduce the visibility of the first where they overlap.\n\"dest_atop\" Like \"over\" but draw second object below the first.\n\"xor\" XOR where the objects overlap\n\"add\" Add the overlapping areas together\n\"saturate\" Increase Saturation where objects overlap\n\"multiply\" Multiply where objects overlap\n\"screen\" Input colors are complemented and multiplied, the product is complemented again. The result is at least as light as the lighter of the input colors.\n\"overlay\" Multiplies or screens colors, depending on the lightness of the destination color.\n\"darken\" Selects the darker of the color values in each component.\n\"lighten\" Selects the lighter of the color values in each component.\n\nSee the Cairo documentation for details.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.getmode","page":"Colors and styles","title":"Luxor.getmode","text":"getmode()\n\nReturn the current compositing/blending mode as a string.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Meshes","page":"Colors and styles","title":"Meshes","text":"","category":"section"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"A mesh provides smooth shading between three or four colors across a region defined by lines or curves.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"To create a mesh, use the mesh() function and save the result as a mesh object. To use a mesh, supply the mesh object to the setmesh() function.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"The mesh() function accepts either an array of B√©zier paths or a polygon.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"This basic example obtains a polygon from the drawing area using box(BoundingBox()... and uses the four corners of the mesh and the four colors in the array to build the mesh. The paint() function fills the drawing.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor, Colors # hide\nDrawing(600, 600, \"assets/figures/mesh-basic.png\") # hide\norigin() # hide\n\ngarishmesh = mesh(\n    box(BoundingBox(), vertices=true),\n    [\"purple\", \"green\", \"yellow\", \"red\"])\n\nsetmesh(garishmesh)\n\npaint()\n\nsetline(2)\nsethue(\"white\")\nhypotrochoid(180, 81, 130, :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: mesh 1)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"The next example uses a B√©zier path conversion of a square as the outline of the mesh. Because the box to be filled is larger than the mesh's outlines, not all the box is filled.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor, Colors # hide\nDrawing(600, 600, \"assets/figures/mesh1.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetcolor(\"grey50\")\ncircle.([Point(x, y) for x in -200:25:200, y in -200:25:200], 10, :fill)\n\nbp = makebezierpath(box(O, 300, 300, vertices=true), smoothing=.4)\nsetline(3)\nsethue(\"black\")\n\ndrawbezierpath(bp, :stroke)\nmesh1 = mesh(bp, [\n    Colors.RGBA(1, 0, 0, 1),   # bottom left, red\n    Colors.RGBA(1, 1, 1, 0.0), # top left, transparent\n    Colors.RGB(0, 0, 1),      # top right, blue\n    Colors.RGB(1, 0, 1)        # bottom right, purple\n    ])\nsetmesh(mesh1)\nbox(O, 500, 500, :fillpreserve)\nsethue(\"grey50\")\nstrokepath()\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: mesh 1)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"The second example uses a polygon defined by ngon() as the outline of the mesh. The mesh is drawn when the path is stroked.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(600, 600, \"assets/figures/mesh2.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\npl = ngon(O, 250, 3, œÄ/6, vertices=true)\nmesh1 = mesh(pl, [\n    \"purple\",\n    \"green\",\n    \"yellow\"\n    ])\nsetmesh(mesh1)\nsetline(180)\npoly(pl, :strokepreserve, close=true)\nsetline(5)\nsethue(\"black\")\nstrokepath()\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: mesh 2)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"mesh\nsetmesh","category":"page"},{"location":"colors-styles/#Luxor.mesh","page":"Colors and styles","title":"Luxor.mesh","text":"mesh(bezierpath::BezierPath,\n     colors=Array{Colors.Colorant, 1})\n\nCreate a mesh. The first three or four elements of the supplied bezierpath define the three or four sides of the mesh shape.\n\nThe colors array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.\n\nUse setmesh() to select the mesh, which will be used to fill shapes.\n\nExample\n\n@svg begin\n    bp = makebezierpath(ngon(O, 50, 4, 0, vertices=true))\n    mesh1 = mesh(bp, [\n        \"red\",\n        Colors.RGB(0, 1, 0),\n        Colors.RGB(0, 1, 1),\n        Colors.RGB(1, 0, 1)\n        ])\n    setmesh(mesh1)\n    box(O, 500, 500, :fill)\nend\n\n\n\n\n\nmesh(points::Array{Point},\n     colors=Array{Colors.Colorant, 1})\n\nCreate a mesh.\n\nCreate a mesh. The first three or four sides of the supplied points polygon define the three or four sides of the mesh shape.\n\nThe colors array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.\n\nExample\n\n@svg begin\n    pl = ngon(O, 250, 3, pi/6, vertices=true)\n    mesh1 = mesh(pl, [\n        \"purple\",\n        Colors.RGBA(0.0, 1.0, 0.5, 0.5),\n        \"yellow\"\n        ])\n    setmesh(mesh1)\n    setline(180)\n    ngon(O, 250, 3, pi/6, :strokepreserve)\n    setline(5)\n    sethue(\"black\")\n    strokepath()\nend\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Luxor.setmesh","page":"Colors and styles","title":"Luxor.setmesh","text":"setmesh(mesh::Mesh)\n\nSelect a mesh previously created with mesh() for filling shapes.\n\n\n\n\n\n","category":"function"},{"location":"colors-styles/#Masks","page":"Colors and styles","title":"Masks","text":"","category":"section"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"A simple mask function lets you use a circular or rectangular shape to control graphics that are drawn over it. mask() takes a position and a shape, and returns a value between 0 and 1 for that position, depending on its position relative to the shape.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"In the first example, the gray color of each tile is determined by its location relative to the center of the masking circle (O, bw/2); the value is 1.0 at the center, and 0.0 at the circumference. The value could be used to control opacity, shape, or anything else that is relevant to graphics at a particular position.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(610, 610, \"assets/figures/mask.png\") # hide\norigin() # hide\nprintln(\"generating mask.png now...\")\ntiles = Tiler(600, 600, 15, 15, margin=0)\nbw = boxwidth(BoundingBox())\nfor (pos, n) in tiles\n    setgray(mask(pos, O, bw/2))\n    box(pos, tiles.tilewidth, tiles.tileheight, :fillstroke)\nend\n\nsethue(\"white\")\ncircle(O, bw/2, :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: mask)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"The second example uses the distance of each tile relative to the rectangle O, bw, bw to determine the gray color.","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"using Luxor # hide\nDrawing(600, 600, \"assets/figures/mask1.png\") # hide\norigin() # hide\n\ntiles = Tiler(600, 600, 30, 30)\n\nbw = boxwidth(BoundingBox())\nbh = boxheight(BoundingBox())\nfor (pos, n) in tiles\n    mv = mask(pos, O, bw, bh, easingfunction=easeinoutcubic)\n    setgray(mv)\n    box(pos, tiles.tilewidth, tiles.tileheight, :fillstroke)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"(Image: mask1)","category":"page"},{"location":"colors-styles/","page":"Colors and styles","title":"Colors and styles","text":"mask","category":"page"},{"location":"colors-styles/#Luxor.mask","page":"Colors and styles","title":"Luxor.mask","text":"mask(point::Point, focus::Point, radius)\n    max = 1.0,\n    min = 0.0,\n    easingfunction = easingflat)\n\nCalculate a value between 0 and 1 for a point relative to a circular area defined by focus and radius. The value will approach max (1.0) at the center of the circular area, and min (0.0) at the circumference.\n\n\n\n\n\nmask(point::Point, focus::Point, width, height)\n    max = 1.0,\n    min = 0.0,\n    easingfunction = easingflat)\n\nCalculate a value between 0 and 1 for a point relative to a rectangular area defined by focus, width, and height. The value will approach max (1.0) at the center, and min (0.0) at the edges.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"DocTestSetup = quote\n    using Luxor, Colors, Random\n    end","category":"page"},{"location":"simplegraphics/#Simple-graphics","page":"Simple shapes","title":"Simple graphics","text":"","category":"section"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"In Luxor, there are different ways of working with graphical items. You can either draw them immediately (ie place them on the drawing, and they're then fixed). Or you can construct geometric objects as lists of points for further processing. Watch out for a vertices=true option, which returns coordinate data rather than drawing a shape.","category":"page"},{"location":"simplegraphics/#Rectangles-and-boxes","page":"Simple shapes","title":"Rectangles and boxes","text":"","category":"section"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"The simple rectangle and box shapes can be made in different ways.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(400, 220, \"assets/figures/basicrects.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nrulers()\nsethue(\"red\")\nrect(Point(0, 0), 100, 100, :stroke)\nsethue(\"blue\")\nbox(Point(0, 0), 100, 100, :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: rect vs box)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"rect() rectangles are positioned by a corner, but a box made with box() can either be defined by its center and dimensions, or by two opposite corners.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: rects)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"If you want the coordinates of the corners of a box, rather than draw one immediately, use:","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"box(centerpoint, width, height, vertices=true)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"or","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"box(corner1,  corner2, vertices=true)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"box is also able to draw some of the other Luxor objects, such as BoundingBoxes and Table cells.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"rect\nbox","category":"page"},{"location":"simplegraphics/#Luxor.rect","page":"Simple shapes","title":"Luxor.rect","text":"rect(xmin, ymin, w, h, action)\n\nCreate a rectangle with one corner at (xmin/ymin) with width w and height h and then do an action.\n\nSee box() for more ways to do similar things, such as supplying two opposite corners, placing by centerpoint and dimensions.\n\n\n\n\n\nrect(cornerpoint, w, h, action;\n    vertices=false)\n\nCreate a rectangle with one corner at cornerpoint with width w and height h and do an action.\n\nUse vertices=true to return an array of the four corner points: bottom left, top left, top right, bottom right.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.box","page":"Simple shapes","title":"Luxor.box","text":"box(cornerpoint1, cornerpoint2, action=:none;\n    vertices=false)\n\nCreate a box (rectangle) between two points and do an action.\n\nUse vertices=true to return an array of the four corner points: bottom left, top left, top right, bottom right.\n\n\n\n\n\nbox(points::Array, action=:none)\n\nCreate a box/rectangle using the first two points of an array of Points to defined opposite corners.\n\nUse vertices=true to return an array of the four corner points: bottom left, top left, top right, bottom right.\n\n\n\n\n\nbox(pt::Point, width, height, action=:none; vertices=false)\n\nCreate a box/rectangle centered at point pt with width and height. Use vertices=true to return an array of the four corner points rather than draw the box.\n\n\n\n\n\nbox(x, y, width, height, action=:none)\n\nCreate a box/rectangle centered at point x/y with width and height.\n\n\n\n\n\nbox(pt, width, height, cornerradius, action=:none)\n\nDraw a box/rectangle centered at point pt with width and height and round each corner by cornerradius.\n\n\n\n\n\nbox(bbox::BoundingBox, :action;\n        vertices=false)\n\nMake a box using the bounds in bbox.\n\nUse vertices=true to return an array of the four corner points: bottom left, top left, top right, bottom right.\n\n\n\n\n\nbox(tiles::Tiler, n::T where T <: Integer, action::Symbol=:none;\n    vertices=false)\n\nDraw a box in tile n of tiles tiles.\n\n\n\n\n\nbox(t::Table, r::T, c::T, action::Symbol=:none) where T <: Integer\n\nDraw a box in table t at row r and column c.\n\n\n\n\n\nbox(t::Table, cellnumber::Int, action::Symbol=:none; vertices=false)\n\nDraw box cellnumber in table t.\n\n\n\n\n\nbox(tile::BoxmapTile, action::Symbol=:none; vertices=false)\n\nUse a Boxmaptile to make or draw a rectangular box. Use vertices=true to obtain the coordinates.\n\nCreate boxmaps using boxmap().\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"box() also returns the coordinates of the corners.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"box(Point(0, 0), 100, 100, :none)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"4-element Array{Point,1}:\n Point(-50.0, 50.0)\n Point(-50.0, -50.0)\n Point(50.0, -50.0)\n Point(50.0, 50.0)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"For regular polygons, pentagons, and so on, see the later section on Polygons.","category":"page"},{"location":"simplegraphics/#Circles-and-ellipses","page":"Simple shapes","title":"Circles and ellipses","text":"","category":"section"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"There are various ways to make circles, including by center and radius, or passing through two or three points:","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(400, 200, \"assets/figures/circles.png\") # hide\nbackground(\"white\") # hide\n\norigin() # hide\nsetline(3) # hide\nsethue(\"black\")\np1 = Point(0, -50)\np2 = Point(100, 0)\np3 = Point(0, 65)\nmap(p -> circle(p, 4, :fill), [p1, p2, p3])\nsethue(\"orange\")\ncircle(center3pts(p1, p2, p3)..., :stroke)\n\nsethue(\"red\")\np1 = Point(0, 30)\np2 = Point(20, -40)\np3 = Point(50, 5)\ncircle.((p1, p2, p3), 3, :stroke)\ncircle(p1, p2, p3, :stroke)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: circles)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"The center3pts() function returns the center position and radius of a circle passing through three points:","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor, Random # hide\nDrawing(400, 200, \"assets/figures/center3.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsetline(3) # hide\nsethue(\"black\")\np1 = Point(0, -50)\np2 = Point(100, 0)\np3 = Point(0, 65)\nmap(p -> circle(p, 4, :fill), [p1, p2, p3])\nsethue(\"orange\")\ncircle(center3pts(p1, p2, p3)..., :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: center and radius of 3 points)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"circle\ncenter3pts","category":"page"},{"location":"simplegraphics/#Luxor.circle","page":"Simple shapes","title":"Luxor.circle","text":"circle(x, y, r, action=:none)\n\nMake a circle of radius r centered at x/y.\n\naction is one of the actions applied by do_action, defaulting to :none. You can also use ellipse() to draw circles and place them by their centerpoint.\n\n\n\n\n\ncircle(pt, r, action=:none)\n\nMake a circle centered at pt.\n\n\n\n\n\ncircle(pt1::Point, pt2::Point, action=:none)\n\nMake a circle that passes through two points that define the diameter:\n\n\n\n\n\ncircle(pt1::Point, pt2::Point, pt3::Point, action=:none)\n\nMake a circle that passes through three points.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.center3pts","page":"Simple shapes","title":"Luxor.center3pts","text":"center3pts(a::Point, b::Point, c::Point)\n\nFind the radius and center point for three points lying on a circle.\n\nreturns (centerpoint, radius) of a circle.\n\nIf there's no such circle, the function returns (Point(0, 0), 0).\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"With ellipse() you can place ellipses and circles by defining the center point and the width and height.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor, Random # hide\nDrawing(500, 300, \"assets/figures/ellipses.png\") # hide\nbackground(\"white\") # hide\nfontsize(11) # hide\nRandom.seed!(1) # hide\norigin() # hide\ntiles = Tiler(500, 300, 5, 5)\nwidth = 20\nheight = 25\nfor (pos, n) in tiles\n    global width, height\n    randomhue()\n    ellipse(pos, width, height, :fill)\n    sethue(\"black\")\n    label = string(round(width/height, digits=2))\n    textcentered(label, pos.x, pos.y + 25)\n    width += 2\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: ellipses)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"ellipse() can also construct polygons that are approximations to ellipses. You supply two focal points and a length which is the sum of the distances of a point on the perimeter to the two focii.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor, Random # hide\nDrawing(400, 220, \"assets/figures/ellipses_1.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\n\nRandom.seed!(42) # hide\nsethue(\"black\") # hide\nsetline(1) # hide\nfontface(\"Menlo\")\n\nf1 = Point(-100, 0)\nf2 = Point(100, 0)\n\ncircle.([f1, f2], 3, :fill)\n\nepoly = ellipse(f1, f2, 250, vertices=true)\npoly(epoly, :stroke,  close=true)\n\npt = epoly[rand(1:end)]\n\npoly([f1, pt, f2], :stroke)\n\nlabel(\"f1\", :W, f1, offset=10)\nlabel(\"f2\", :E, f2, offset=10)\n\nlabel(string(round(distance(f1, pt), digits=1)), :SE, midpoint(f1, pt))\nlabel(string(round(distance(pt, f2), digits=1)), :SW, midpoint(pt, f2))\n\nlabel(\"ellipse(f1, f2, 250)\", :S, Point(0, 75))\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: more ellipses)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"The advantage of this method is that there's a vertices=true option, allowing further scope for polygon manipulation.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(500, 450, \"assets/figures/ellipses_2.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"gray30\") # hide\nsetline(1) # hide\nf1 = Point(-100, 0)\nf2 = Point(100, 0)\nellipsepoly = ellipse(f1, f2, 170, :none, vertices=true)\n[ begin\n    setgray(rescale(c, 150, 1, 0, 1))\n    poly(offsetpoly(ellipsepoly, c), close=true, :fill);\n    rotate(œÄ/20)\n  end\n     for c in 150:-10:1 ]\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: even more ellipses)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"The ellipseinquad() function constructs an ellipse that fits in a four-sided quadrilateral.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 600, \"assets/figures/ellipseinquad.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"gray30\") # hide\nsetline(1) # hide\n\npg = ngon(O, 250, 6, œÄ/6, vertices=true)\n\ntop = vcat(O, pg[[3, 4, 5]])\nleft = vcat(O, pg[[1, 2, 3]])\nright = vcat(O, pg[[5, 6, 1]])\nsethue(\"red\")\npoly(top, :fill, close=true)\n\nsethue(\"green\")\npoly(left, :fill, close=true)\n\nsethue(\"blue\")\npoly(right, :fill, close=true)\n\nsethue(\"orange\")\nellipseinquad.((top, left, right), :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: ellipse in quadrilateral)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"ellipse\nellipseinquad","category":"page"},{"location":"simplegraphics/#Luxor.ellipse","page":"Simple shapes","title":"Luxor.ellipse","text":"ellipse(xc, yc, w, h, action=:none)\n\nMake an ellipse, centered at xc/yc, fitting in a box of width w and height h.\n\n\n\n\n\nellipse(cpt, w, h, action=:none)\n\nMake an ellipse, centered at point c, with width w, and height h.\n\n\n\n\n\nellipse(focus1::Point, focus2::Point, k, action=:none;\n        stepvalue=pi/100,\n        vertices=false,\n        reversepath=false)\n\nBuild a polygon approximation to an ellipse, given two points and a distance, k, which is the sum of the distances to the focii of any points on the ellipse (or the shortest length of string required to go from one focus to the perimeter and on to the other focus).\n\n\n\n\n\nellipse(focus1::Point, focus2::Point, pt::Point, action=:none;\n        stepvalue=pi/100,\n        vertices=false,\n        reversepath=false)\n\nBuild a polygon approximation to an ellipse, given two points and a point somewhere on the ellipse.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.ellipseinquad","page":"Simple shapes","title":"Luxor.ellipseinquad","text":"ellipseinquad(qgon, action=:none)\n\nCalculate a BeÃÅzier-based ellipse that fits inside the quadrilateral qgon, an array of with at least four Points, then apply action.\n\nReturns ellipsecenter, ellipsesemimajor, ellipsesemiminor, ellipseangle:\n\nellipsecenter the ellipse center\n\nellipsesemimajor ellipse semimajor axis\n\nellipsesemiminor ellipse semiminor axis\n\nellipseangle ellipse rotation\n\nThe function returns O, 0, 0, 0 if a suitable ellipse can't be found. (The qgon is probably not a convex polygon.)\n\nReferences\n\nhttp://faculty.mae.carleton.ca/John_Hayes/Papers/InscribingEllipse.pdf\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"circlepath() constructs a circular path from B√©zier curves, which allows you to use circles as paths.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/circle-path.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"black\") # hide\nsetline(4)\ntiles = Tiler(600, 250, 1, 5)\nfor (pos, n) in tiles\n    randomhue()\n    circlepath(pos, tiles.tilewidth/2, :path)\n    newsubpath()\n    circlepath(pos, rand(5:tiles.tilewidth/2 - 1), :fill, reversepath=true)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: circles as paths)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"circlepath","category":"page"},{"location":"simplegraphics/#Luxor.circlepath","page":"Simple shapes","title":"Luxor.circlepath","text":"circlepath(center::Point, radius, action=:none;\n    reversepath=false,\n    kappa = 0.5522847498307936)\n\nDraw a circle using B√©zier curves.\n\nThe magic value, kappa, is 4.0 * (sqrt(2.0) - 1.0) / 3.0.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Circles-and-tangents","page":"Simple shapes","title":"Circles and tangents","text":"","category":"section"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"Functions to find tangents to circles include:","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"pointcircletangent() finds a point on a circle that lies on line through another point\ncirclecircleoutertangents() finds the points that lie on outer tangents to two circles\ncirclecircleinnertangents() finds the points that lie on inner tangents to two circles\ncircletangent2circles() makes circles of a particular radius tangential to two circles\ncirclepointtangent() makes circles of a particular radius passing through a point and tangential to another circle","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/point-circle-tangents.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(1) # hide\nsethue(\"black\") # hide\n\n\npoint = Point(-150, 0)\ncirclecenter = Point(150, 0)\ncircleradius = 80\n\ncircle.((point, circlecenter), 5, :fill)\ncircle(circlecenter, circleradius, :stroke)\npt1, pt2 = pointcircletangent(point, circlecenter, circleradius)\ncircle.((pt1, pt2), 5, :fill)\n\nsethue(\"grey65\")\nrule(point, slope(point, pt1))\nrule(point, slope(point, pt2))\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: point circle tangents)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/circle-circle-outer-tangents.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(1) # hide\nsethue(\"black\") # hide\n\ncircle1center = Point(-150, 0)\ncircle1radius = 60\ncircle2center = Point(150, 0)\ncircle2radius = 80\n\ncircle.((circle1center, circle2center), 5, :fill)\ncircle(circle1center, circle1radius, :stroke)\ncircle(circle2center, circle2radius, :stroke)\n\np1, p2, p3, p4 = circlecircleoutertangents(\n    circle1center, circle1radius,\n    circle2center, circle2radius)\n\nsethue(\"orange\")\nrule(p1, slope(p1, p2))\nrule(p3, slope(p3, p4))\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: circle circle outer tangents)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"Finding the inner tangents requires a separate function.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/circle-circle-inner-tangents.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(1) # hide\nsethue(\"black\") # hide\n\ncircle1center = Point(-150, 0)\ncircle1radius = 60\ncircle2center = Point(150, 0)\ncircle2radius = 80\n\ncircle.((circle1center, circle2center), 5, :fill)\ncircle(circle1center, circle1radius, :stroke)\ncircle(circle2center, circle2radius, :stroke)\n\np1, p2, p3, p4 = circlecircleinnertangents(\n    circle1center, circle1radius,\n    circle2center, circle2radius)\n\nlabel.((\"p1\", \"p2\", \"p3\", \"p4\"), :n, (p1, p2, p3, p4))\nsethue(\"orange\")\nrule(p1, slope(p1, p2))\nrule(p3, slope(p3, p4))\n\nsethue(\"purple\")\ncircle.((p1, p2, p3, p4), 3, :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: circle circle inner tangents)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"circletangent2circles() takes the required radius and two existing circles:","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/circle-tangents.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"black\") # hide\nsetline(1) # hide\n\ncircle1 = (Point(-100, 0), 90)\ncircle(circle1..., :stroke)\ncircle2 = (Point(100, 0), 90)\ncircle(circle2..., :stroke)\n\nrequiredradius = 25\nncandidates, p1, p2 = circletangent2circles(requiredradius, circle1..., circle2...)\n\nif ncandidates==2\n    sethue(\"orange\")\n    circle(p1, requiredradius, :fill)\n    sethue(\"green\")\n    circle(p2, requiredradius, :fill)\n    sethue(\"purple\")\n    circle(p1, requiredradius, :stroke)\n    circle(p2, requiredradius, :stroke)\nend\n\n# the circles are 10 apart, so there should be just one circle\n# that fits there\n\nrequiredradius = 10\nncandidates, p1, p2 = circletangent2circles(requiredradius, circle1..., circle2...)\n\nif ncandidates==1\n    sethue(\"blue\")\n    circle(p1, requiredradius, :fill)\n    sethue(\"cyan\")\n    circle(p1, requiredradius, :stroke)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: circle tangents)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"circlepointtangent() looks for circles of a specified radius that pass through a point and are tangential to a circle. There are usually two candidates.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/circle-point-tangent.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"black\") # hide\nsetline(1) # hide\n\ncircle1 = (Point(-100, 0), 90)\ncircle(circle1..., :stroke)\n\nrequiredradius = 50\nrequiredpassthrough = O + (80, 0)\nncandidates, p1, p2 = circlepointtangent(requiredpassthrough, requiredradius, circle1...)\n\nif ncandidates==2\n    sethue(\"orange\")\n    circle(p1, requiredradius, :stroke)\n    sethue(\"green\")\n    circle(p2, requiredradius, :stroke)\nend\n\nsethue(\"black\")\ncircle(requiredpassthrough, 4, :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: circle tangents 2)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"These last two functions can return 0, 1, or 2 points (since there are often two solutions to a specific geometric layout).","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"pointcircletangent\ncircletangent2circles\ncirclepointtangent\ncirclecircleinnertangents\ncirclecircleoutertangents","category":"page"},{"location":"simplegraphics/#Luxor.pointcircletangent","page":"Simple shapes","title":"Luxor.pointcircletangent","text":"pointcircletangent(point::Point, circlecenter::Point, circleradius)\n\nFind the two points on a circle that lie on tangent lines passing through an external point.\n\nIf both points are O, the external point is inside the circle, and the result is (O, O).\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.circletangent2circles","page":"Simple shapes","title":"Luxor.circletangent2circles","text":"circletangent2circles(radius, circle1center::Point, circle1radius, circle2center::Point, circle2radius)\n\nFind the centers of up to two circles of radius radius that are tangent to the two circles defined by circle1... and circle2.... These two circles can overlap, but one can't be inside the other.\n\n(0, O, O)      - no such circles exist\n(1, pt1, O)    - 1 circle exists, centered at pt1\n(2, pt1, pt2)  - 2 circles exist, with centers at pt1 and pt2\n\n(The O are just dummy points so that three values are always returned.)\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.circlepointtangent","page":"Simple shapes","title":"Luxor.circlepointtangent","text":"circlepointtangent(through::Point, radius, targetcenter::Point, targetradius)\n\nFind the centers of up to two circles of radius radius that pass through point through and are tangential to a circle that has radius targetradius and center targetcenter.\n\nThis function returns a tuple:\n\n(0, O, O)      - no circles exist\n(1, pt1, O)    - 1 circle exists, centered at pt1\n(2, pt1, pt2)  - 2 circles exist, with centers at pt1 and pt2\n\n(The O are just dummy points so that three values are always returned.)\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.circlecircleinnertangents","page":"Simple shapes","title":"Luxor.circlecircleinnertangents","text":"circlecircleinnertangents(circle1center::Point, circle1radius, circle2center::Point, circle2radius)\n\nFind the inner tangents of two circles. These are tangent lines that cross as they skim past one circle and touch the other.\n\nReturns the four points: tangentpoint1 on circle 1, tangentpoint1 on circle2, tangentpoint2 on circle 1, tangentpoint2 on circle2.\n\nReturns (O, O, O, O) if inner tangents can't be found (eg when the circles overlap).\n\nUse circlecircleoutertangents() to find the outer tangents.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.circlecircleoutertangents","page":"Simple shapes","title":"Luxor.circlecircleoutertangents","text":"circlecircleoutertangents(cpt1::Point, r1, cpt2::Point, r2)\n\nReturn four points, p1, p2,p3,p4, where a line throughp1andp2, and a line throughp3andp4, form the outer tangents to the circles defined bycpt1/r1andcpt2/r2`.\n\nReturns four identical points (O) if one of the circles lies inside the other.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Paths-and-positions","page":"Simple shapes","title":"Paths and positions","text":"","category":"section"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"A path is a sequence of lines and curves. You can add lines and curves to the current path, then use closepath() to join the last point to the first.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"A path can have subpaths, created withnewsubpath(), which can form holes.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"There is a 'current position' which you can set with move(), and can use implicitly in functions like line(), rline(), text(), arc() and curve().","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"move\nrmove\nnewpath\nnewsubpath\nclosepath\ncurrentpoint\nhascurrentpoint","category":"page"},{"location":"simplegraphics/#Luxor.move","page":"Simple shapes","title":"Luxor.move","text":"move(pt)\n\nMove to a point.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.rmove","page":"Simple shapes","title":"Luxor.rmove","text":"rmove(pt)\n\nMove relative to current position by the pt's x and y:\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.newpath","page":"Simple shapes","title":"Luxor.newpath","text":"newpath()\n\nCreate a new path. This is Cairo's new_path() function.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.newsubpath","page":"Simple shapes","title":"Luxor.newsubpath","text":"newsubpath()\n\nAdd a new subpath to the current path. This is Cairo's new_sub_path() function. It can be used for example to make holes in shapes.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.closepath","page":"Simple shapes","title":"Luxor.closepath","text":"closepath()\n\nClose the current path. This is Cairo's close_path() function.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.currentpoint","page":"Simple shapes","title":"Luxor.currentpoint","text":"currentpoint()\n\nReturn the current point.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.hascurrentpoint","page":"Simple shapes","title":"Luxor.hascurrentpoint","text":"hascurrentpoint()\n\nReturn true if there is a current point. Obtain the current point with currentpoint().\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Lines","page":"Simple shapes","title":"Lines","text":"","category":"section"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"Use line() and rline() to draw straight lines. line(pt1, pt2, action) draws a line between two points. line(pt) adds a line to the current path going from the current position to the point. rline(pt) adds a line relative to the current position.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"line\nrline","category":"page"},{"location":"simplegraphics/#Luxor.line","page":"Simple shapes","title":"Luxor.line","text":"line(pt)\n\nDraw a line from the current position to the pt.\n\n\n\n\n\nline(pt1::Point, pt2::Point, action=:none)\n\nMake a line between two points, pt1 and pt2 and do an action.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.rline","page":"Simple shapes","title":"Luxor.rline","text":"rline(pt)\n\nDraw a line relative to the current position to the pt.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"You can use rule() to draw a line through a point, optionally at an angle to the current x-axis.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(700, 200, \"assets/figures/rule.png\") # hide\nbackground(\"white\") # hide\nsethue(\"black\") # hide\nsetline(0.5) # hide\ny = 10\nfor x in 10 .^ range(0, length=100, stop=3)\n    global y\n    circle(Point(x, y), 2, :fill)\n    rule(Point(x, y), -œÄ/2, boundingbox=BoundingBox(centered=false))\n    y += 2\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: arc)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"Use the boundingbox keyword argument to crop the ruled lines with a BoundingBox.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(700, 200, \"assets/figures/rulebbox.png\") # hide\norigin()\nbackground(\"white\") # hide\nsethue(\"black\") # hide\nsetline(0.75) # hide\nbox(BoundingBox() * 0.9, :stroke)\nfor x in 10 .^ range(0, length=100, stop=3)\n    rule(Point(x, 0), œÄ/2,  boundingbox=BoundingBox() * 0.9)\n    rule(Point(-x, 0), œÄ/2, boundingbox=BoundingBox() * 0.9)\nend\nfinish() # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: arc)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"rule","category":"page"},{"location":"simplegraphics/#Luxor.rule","page":"Simple shapes","title":"Luxor.rule","text":"rule(pos, theta;\n    boundingbox=BoundingBox(),\n    vertices=false)\n\nDraw a straight line through pos at an angle theta from the x axis.\n\nBy default, the line spans the entire drawing, but you can supply a BoundingBox to change the extent of the line.\n\nrule(O)       # draws an x axis\nrule(O, pi/2) # draws a  y axis\n\nThe function:\n\nrule(O, pi/2, boundingbox=BoundingBox()/2)\n\ndraws a line that spans a bounding box half the width and height of the drawing, and returns a Set of end points. If you just want the vertices and don't want to draw anything, use vertices=true.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Arrows","page":"Simple shapes","title":"Arrows","text":"","category":"section"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"You can draw lines, arcs, and curves with arrows at the end with arrow(). For straight arrows, supply the start and end points. For arrows as circular arcs, you provide center, radius, and start and finish angles. You can optionally provide dimensions for the arrowheadlength and arrowheadangle of the tip of the arrow (angle in radians between side and center). The default line weight is 1.0, equivalent to setline(1)), but you can specify another.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(400, 250, \"assets/figures/arrow.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"steelblue4\") # hide\nsetline(2) # hide\narrow(Point(0, 0), Point(0, -65))\narrow(Point(0, 0), Point(100, -65), arrowheadlength=20, arrowheadangle=pi/4, linewidth=.3)\narrow(Point(0, 0), 100, œÄ, œÄ/2, arrowheadlength=25,   arrowheadangle=pi/12, linewidth=1.25)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: arrows)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"If you provide four points, you can draw a B√©zier curve with optional arrowheads at each end. Use the various options to control their presence and appearance.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 400, \"assets/figures/arrowbezier.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsetline(2) # hide\npts = ngon(Point(0, 0), 100, 8, vertices=true)\nsethue(\"mediumvioletred\")\narrow(pts[2:5]..., :stroke, startarrow=false, finisharrow=true)\nsethue(\"cyan4\")\narrow(pts[3:6]..., startarrow=true, finisharrow=true)\nsethue(\"midnightblue\")\narrow(pts[[4, 2, 6, 8]]..., :stroke,\n    startarrow=true,\n    finisharrow=true,\n    arrowheadangle = œÄ/6,\n    arrowheadlength = 35,\n    linewidth  = 1.5)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: arrows)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"The arrow() functions allow you to specify decoration - graphics at a point somewhere along the shaft. For example, say you want to draw a number and a circle at the midpoint of an arrow, define a function that draws text t in a circle of radius r :","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"function marker(r, t)\n    @layer begin\n        sethue(\"purple\")\n        circle(Point(0, 0), r,  :fill)\n        sethue(\"white\")\n        fontsize(30)\n        text(string(t), halign=:center, valign=:middle)\n    end\nend","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"and then pass it to the decorate keyword. By default, the graphics origin when the function is called is placed at the midpoint (0.5) of the arrow's shaft.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 400, \"assets/figures/arrowbezierdecoration.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsetline(2) # hide\n\nfunction marker(r, t) #hide\n    @layer begin #hide\n        sethue(\"purple\") #hide\n        circle(Point(0, 0), r,  :fill) #hide\n        sethue(\"white\") #hide\n        fontsize(25) #hide\n        text(string(t), halign=:center, valign=:middle) #hide\n    end #hide\nend #hide\n\npts = ngon(Point(0, 0), 100, 5, vertices=true)\n\nsethue(\"mediumvioletred\")\n\n# using an anonymous function\narrow(pts[1:4]..., decorate = () -> marker(10, 3))\n\nsethue(\"olivedrab\")\n\n# no arrow, just a graphic, at 0.75\narrow(pts[1:4]..., decorate = () -> ngon(Point(0, 0), 20, 4, 0, :fill), decoration = 0.75, :none)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: arrows with decoration)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"Use the decoration keyword to specify a location other than the default 0.5.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"The graphics environment provided by the decorate function is centered at the decoration point, and rotated to the slope of the curve at that point.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"arrow","category":"page"},{"location":"simplegraphics/#Luxor.arrow","page":"Simple shapes","title":"Luxor.arrow","text":"arrow(startpoint::Point, endpoint::Point;\n    linewidth = 1.0,\n    arrowheadlength = 10,\n    arrowheadangle = pi/8,\n    decoration = 0.5,\n    decorate = () -> ())\n\nDraw a line between two points and add an arrowhead at the end. The arrowhead length will be the length of the side of the arrow's head, and the arrowhead angle is the angle between the sloping side of the arrowhead and the arrow's shaft.\n\nArrows don't use the current linewidth setting (setline()), and defaults to 1, but you can specify another value. It doesn't need stroking/filling, the shaft is stroked and the head filled with the current color.\n\nThe decorate keyword argument accepts a function that can execute code at locations on the arrow's shaft. The inherited graphic environment is centered at each point on the curve between 0 and 1 given by scalar or vector decoration, and the x-axis is aligned with the direction of the curve at that point.\n\n\n\n\n\narrow(centerpos::Point, radius, startangle, endangle;\n    linewidth = 1.0,\n    arrowheadlength = 10,\n    arrowheadangle = pi/8,\n    decoration = 0.5,\n    decorate = () -> ())\n\nDraw a curved arrow, an arc centered at centerpos starting at startangle and ending at endangle with an arrowhead at the end. Angles are measured clockwise from the positive x-axis.\n\nArrows don't use the current linewidth setting (setline()); you can specify the linewidth.\n\nThe decorate keyword argument accepts a function that can execute code at locations on the arrow's shaft. The inherited graphic environment is centered at points on the curve between 0 and 1 given by scalar or vector decoration, and the x-axis is aligned with the direction of the curve at that point.\n\n\n\n\n\narrow(start::Point, C1::Point, C2::Point, finish::Point, action=:stroke;\n    linewidth=1.0,\n    arrowheadlength=10,\n    arrowheadangle=pi/8,\n    startarrow=false,\n    finisharrow=true,\n    decoration = 0.5,\n    decorate = () -> ()))\n\nDraw a Bezier curved arrow, from start to finish, with control points C1 and C2. Arrow heads can be added/hidden by changing startarrow and finisharrow options.\n\nThe decorate keyword argument accepts a function that can execute code at locations on the arrow's shaft. The inherited graphic environment is centered at each point on the curve given by scalar or vector decoration, and the x-axis is aligned with the direction of the curve at that point (TODO - more or less - is it actually correct?).\n\n\n\n\n\narrow(start::Point, finish::Point, height::Vector, action=:stroke;\n    keyword arguments...)\n\nDraw a BeÃÅzier arrow between start and finish, with control points defined to fit in an imaginary box defined by the two supplied height values (see bezierfrompoints()). If the height values are different signs, the arrow will change direction on its way.\n\nKeyword arguments are the same as arrow(pt1, pt2, pt3, pt4).\n\nExample\n\narrow(pts[1], pts[end], [15, 15],\n    decoration = 0.5,\n    decorate = () -> text(string(pts[1])))\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Arcs-and-curves","page":"Simple shapes","title":"Arcs and curves","text":"","category":"section"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"There are a few standard arc-drawing commands, such as curve(), arc(), carc(), and arc2r(). Because these are often used when building complex paths, they usually add arc sections to the current path. To construct a sequence of lines and arcs, use the :path action, followed by a final :stroke or similar.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"curve() constructs B√©zier curves from control points:","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 275, \"assets/figures/curve.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\n\nsethue(\"black\") # hide\n\nsetline(.5)\npt1 = Point(0, -125)\npt2 = Point(200, 125)\npt3 = Point(200, -125)\n\nlabel.(string.([\"O\", \"control point 1\", \"control point 2\", \"control point 3\"]),\n    :e,\n    [O, pt1, pt2, pt3])\n\nsethue(\"red\")\nmap(p -> circle(p, 4, :fill), [O, pt1, pt2, pt3])\n\nline(Point(0, 0), pt1, :stroke)\nline(pt2, pt3, :stroke)\n\nsethue(\"black\")\nsetline(3)\n\n# start a path\nmove(Point(0, 0))\ncurve(pt1, pt2, pt3) #  add to current path\nstrokepath()\n\nfinish()  # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: curve)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"arc2r() draws a circular arc centered at a point that passes through two other points:","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor, Random # hide\nDrawing(700, 200, \"assets/figures/arc2r.png\") # hide\norigin() # hide\nRandom.seed!(42) # hide\nbackground(\"white\") # hide\ntiles = Tiler(700, 200, 1, 6)\nfor (pos, n) in tiles\n    c1, pt2, pt3 = ngon(pos, rand(10:50), 3, rand(0:pi/12:2pi), vertices=true)\n    sethue(\"black\")\n    map(pt -> circle(pt, 4, :fill), [c1, pt3])\n    sethue(\"red\")\n    circle(pt2, 4, :fill)\n    randomhue()\n    arc2r(c1, pt2, pt3, :stroke)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: arc)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"arc2sagitta() and carc2sagitta() make circular arcs based on two points and the sagitta (the maximum height from the chord).","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor, Colors # hide\nDrawing(400, 250, \"assets/figures/arc2sagitta.svg\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(.5) # hide\ntranslate(0, 50) # hide\npt1 = Point(-100, 0)\npt2 = Point(100, 0)\nfor n in reverse(range(1, length=7, stop=120))\n    sethue(\"red\")\n    rule(Point(0, -n))\n    sethue(LCHab(70, 80, rescale(n, 120, 1, 0, 359)))\n    pt, r = arc2sagitta(pt1, pt2, n, :fillpreserve)\n    sethue(\"black\")\n    strokepath()\n    text(string(round(n)), O + (120, -n))\nend\ncircle.((pt1, pt2), 5, :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: arc)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"arc\narc2r\ncarc\ncarc2r\narc2sagitta\ncarc2sagitta\ncurve","category":"page"},{"location":"simplegraphics/#Luxor.arc","page":"Simple shapes","title":"Luxor.arc","text":"arc(xc, yc, radius, angle1, angle2, action=:none)\n\nAdd an arc to the current path from angle1 to angle2 going clockwise, centered at xc, yc.\n\nAngles are defined relative to the x-axis, positive clockwise.\n\n\n\n\n\narc(centerpoint::Point, radius, angle1, angle2, action=:none)\n\nAdd an arc to the current path from angle1 to angle2 going clockwise, centered at centerpoint.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.arc2r","page":"Simple shapes","title":"Luxor.arc2r","text":"  arc2r(c1::Point, p2::Point, p3::Point, action=:none)\n\nAdd a circular arc centered at c1 that starts at p2 and ends at p3, going clockwise, to the current path.\n\nc1-p2 really determines the radius. If p3 doesn't lie on the circular path,  it will be used only as an indication of the arc's length, rather than its position.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.carc","page":"Simple shapes","title":"Luxor.carc","text":"carc(xc, yc, radius, angle1, angle2, action=:none)\n\nAdd an arc to the current path from angle1 to angle2 going counterclockwise, centered at xc/yc.\n\nAngles are defined relative to the x-axis, positive clockwise.\n\n\n\n\n\ncarc(centerpoint::Point, radius, angle1, angle2, action=:none)\n\nAdd an arc centered at centerpoint to the current path from angle1 to angle2, going counterclockwise.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.carc2r","page":"Simple shapes","title":"Luxor.carc2r","text":"carc2r(c1::Point, p2::Point, p3::Point, action=:none)\n\nAdd a circular arc centered at c1 that starts at p2 and ends at p3, going counterclockwise, to the current path.\n\nc1-p2 really determines the radius. If p3 doesn't lie on the circular path, it will be used only as an indication of the arc's length, rather than its position.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.arc2sagitta","page":"Simple shapes","title":"Luxor.arc2sagitta","text":"arc2sagitta(p1::Point, p2::Point, s, action=:none)\n\nMake a clockwise arc starting at p1 and ending at p2 that reaches a height of s, the sagitta, at the middle. Might append to current path...\n\nReturn tuple of the center point and the radius of the arc.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.carc2sagitta","page":"Simple shapes","title":"Luxor.carc2sagitta","text":"carc2sagitta(p1::Point, p2::Point, s, action=:none)\n\nMake a counterclockwise arc starting at p1 and ending at p2 that reaches a height of s, the sagitta, at the middle. Might append to current path...\n\nReturn tuple of center point and radius of arc.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.curve","page":"Simple shapes","title":"Luxor.curve","text":"curve(x1, y1, x2, y2, x3, y3)\ncurve(p1, p2, p3)\n\nAdd a B√©zier curve.\n\nThe spline starts at the current position, finishing at x3/y3 (p3), following two control points x1/y1 (p1) and x2/y2 (p2).\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#More-curved-shapes:-sectors,-spirals,-and-squircles","page":"Simple shapes","title":"More curved shapes: sectors, spirals, and squircles","text":"","category":"section"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"A sector (technically an \"annular sector\") has an inner and outer radius, as well as start and end angles.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 200, \"assets/figures/sector.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"tomato\")\nsector(50, 90, œÄ/2, 0, :fill)\nsethue(\"olive\")\nsector(Point(O.x + 200, O.y), 50, 90, 0, œÄ/2, :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: sector)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"You can also supply a value for a corner radius. The same sector is drawn but with rounded corners.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 200, \"assets/figures/sectorrounded.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"tomato\")\nsector(50, 90, œÄ/2, 0, 15, :fill)\nsethue(\"olive\")\nsector(Point(O.x + 200, O.y), 50, 90, 0, œÄ/2, 15, :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: sector)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"sector","category":"page"},{"location":"simplegraphics/#Luxor.sector","page":"Simple shapes","title":"Luxor.sector","text":"sector(centerpoint::Point, innerradius, outerradius, startangle, endangle, action:none)\n\nDraw an annular sector centered at centerpoint.\n\n\n\n\n\nsector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real,\n   action::Symbol=:none)\n\nDraw an annular sector centered at the origin.\n\n\n\n\n\nsector(centerpoint::Point, innerradius, outerradius, startangle, endangle,\n    cornerradius, action:none)\n\nDraw an annular sector with rounded corners, basically a bent sausage shape, centered at centerpoint.\n\nTODO: The results aren't 100% accurate at the moment. There are small discontinuities where the curves join.\n\nThe cornerradius is reduced from the supplied value if neceesary to prevent overshoots.\n\n\n\n\n\nsector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real,\n   cornerradius::Real, action::Symbol=:none)\n\nDraw an annular sector with rounded corners, centered at the current origin.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"A pie (or wedge) has start and end angles.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(400, 300, \"assets/figures/pie.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"magenta\") # hide\npie(0, 0, 100, œÄ/2, œÄ, :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: pie)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"pie","category":"page"},{"location":"simplegraphics/#Luxor.pie","page":"Simple shapes","title":"Luxor.pie","text":"pie(x, y, radius, startangle, endangle, action=:none)\n\nDraw a pie shape centered at x/y. Angles start at the positive x-axis and are measured clockwise.\n\n\n\n\n\npie(centerpoint, radius, startangle, endangle, action=:none)\n\nDraw a pie shape centered at centerpoint.\n\nAngles start at the positive x-axis and are measured clockwise.\n\n\n\n\n\npie(radius, startangle, endangle, action=:none)\n\nDraw a pie shape centered at the origin\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"To construct spirals, use the spiral() function. These can be drawn directly, or used as polygons. The default is to draw Archimedean (non-logarithmic) spirals.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 300, \"assets/figures/spiral.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"black\") # hide\nsetline(.5) # hide\nfontface(\"Avenir-Heavy\") # hide\nfontsize(15) # hide\n\nspiraldata = [\n  (-2, \"Lituus\",      50),\n  (-1, \"Hyperbolic\", 100),\n  ( 1, \"Archimedes\",   1),\n  ( 2, \"Fermat\",       5)]\n\ngrid = GridRect(O - (200, 0), 130, 50)\n\nfor aspiral in spiraldata\n    @layer begin\n        translate(nextgridpoint(grid))\n        spiral(last(aspiral), first(aspiral), period=20œÄ, :stroke)\n        label(aspiral[2], :S, offset=100)\n    end\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: spiral)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"Use the log=true option to draw logarithmic (Bernoulli or Fibonacci) spirals.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 400, \"assets/figures/spiral-log.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsetline(.5) # hide\nsethue(\"black\") # hide\nfontface(\"Avenir-Heavy\") # hide\nfontsize(15) # hide\n\nspiraldata = [\n    (10,  0.05),\n    (4,   0.10),\n    (0.5, 0.17)]\n\ngrid = GridRect(O - (200, 0), 175, 50)\nfor aspiral in spiraldata\n    @layer begin\n        translate(nextgridpoint(grid))\n        spiral(first(aspiral), last(aspiral), log=true, period=10œÄ, :stroke)\n        label(string(aspiral), :S, offset=100)\n    end\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"Modify the stepby and period parameters to taste, or collect the vertices for further processing.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: spiral log)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"spiral","category":"page"},{"location":"simplegraphics/#Luxor.spiral","page":"Simple shapes","title":"Luxor.spiral","text":"spiral(a, b, action::Symbol=:none;\n                 stepby = 0.01,\n                 period = 4pi,\n                 vertices = false,\n                 log=false)\n\nMake a spiral. The two primary parameters a and b determine the start radius, and the tightness.\n\nFor linear spirals (log=false), b values are:\n\nlituus: -2\n\nhyperbolic spiral: -1\n\nArchimedes' spiral: 1\n\nFermat's spiral: 2\n\nFor logarithmic spirals (log=true):\n\ngolden spiral: b = ln(phi)/ (pi/2) (about 0.30)\n\nValues of b around 0.1 produce tighter, staircase-like spirals.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"A squircle is a cross between a square and a circle. You can adjust the squariness and circularity of it to taste by supplying a value for the root (keyword rt):","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/squircle.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nfontsize(20) # hide\nsetline(2)\ntiles = Tiler(600, 250, 1, 3)\nfor (pos, n) in tiles\n    sethue(\"lavender\")\n    squircle(pos, 80, 80, rt=[0.3, 0.5, 0.7][n], :fillpreserve)\n    sethue(\"grey20\")\n    strokepath()\n    textcentered(\"rt = $([0.3, 0.5, 0.7][n])\", pos)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: squircles)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"squircle","category":"page"},{"location":"simplegraphics/#Luxor.squircle","page":"Simple shapes","title":"Luxor.squircle","text":"squircle(center::Point, hradius, vradius, action=:none;\n    rt = 0.5, stepby = pi/40, vertices=false)\n\nMake a squircle or superellipse (basically a rectangle with rounded corners). Specify the center position, horizontal radius (distance from center to a side), and vertical radius (distance from center to top or bottom):\n\nThe root (rt) option defaults to 0.5, and gives an intermediate shape. Values less than 0.5 make the shape more rectangular. Values above make the shape more round. The horizontal and vertical radii can be different.\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"To draw a simple rounded rectangle, supply a corner radius:","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/round-rect-1.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"black\") # hide\nsetline(4)\nbox(O, 200, 150, 10, :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: rounded rect 1)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"Or you could smooth the corners of a box, like so:","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/round-rect.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"black\") # hide\nsetline(4)\npolysmooth(box(O, 200, 150, vertices=true), 10, :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: rounded rect)","category":"page"},{"location":"simplegraphics/#Stars-and-crosses","page":"Simple shapes","title":"Stars and crosses","text":"","category":"section"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"Use star() to make a star. You can draw it immediately, or use the points it can create.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(500, 300, \"assets/figures/stars.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\ntiles = Tiler(400, 300, 4, 6, margin=5)\nfor (pos, n) in tiles\n    randomhue()\n    star(pos, tiles.tilewidth/3, rand(3:8), 0.5, 0, :fill)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: stars)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"The ratio determines the length of the inner radius compared with the outer.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(500, 250, \"assets/figures/star-ratios.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"black\") # hide\nsetline(2) # hide\ntiles = Tiler(500, 250, 1, 6, margin=10)\nfor (pos, n) in tiles\n    star(pos, tiles.tilewidth/2, 5, rescale(n, 1, 6, 1, 0), 0, :stroke)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: stars)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"Use polycross() to draw a cross-shaped polygon.","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"using Luxor # hide\nDrawing(600, 600, \"assets/figures/polycross.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"black\") # hide\nsetline(2) # hide\ntiles = Tiler(600, 600, 4, 4, margin=10)\nfor (pos, n) in tiles\n    randomhue()\n    polycross(pos, min(tiles.tileheight/3, tiles.tilewidth/3),\n        n + 2, # number of points\n        rescale(n, 1, length(tiles), 0.9, 0.1), # ratio\n        0, # orientation\n        :fill)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"(Image: polycross)","category":"page"},{"location":"simplegraphics/","page":"Simple shapes","title":"Simple shapes","text":"star\npolycross","category":"page"},{"location":"simplegraphics/#Luxor.star","page":"Simple shapes","title":"Luxor.star","text":"star(xcenter, ycenter, radius, npoints=5, ratio=0.5, orientation=0, action=:none;\n    vertices = false,\n    reversepath=false)\n\nMake a star. ratio specifies the height of the smaller radius of the star relative to the larger.\n\nUse vertices=true to return the vertices of a star instead of drawing it.\n\n\n\n\n\nstar(center, radius, npoints=5, ratio=0.5, orientation=0, action=:none;\n    vertices = false, reversepath=false)\n\nDraw a star centered at a position:\n\n\n\n\n\n","category":"function"},{"location":"simplegraphics/#Luxor.polycross","page":"Simple shapes","title":"Luxor.polycross","text":"polycross(pt::Point, radius, npoints::Int, ratio=0.5, orientation=0.0, action=:none;\n    splay       = 0.5,\n    vertices    = false,\n    reversepath = false)\n\nMake a cross-shaped polygon with npoints arms to fit inside a circle of radius radius centered at pt.\n\nratio specifies the ratio of the two sides of each arm. splay makes the arms ... splayed.\n\nUse vertices=true to return the vertices of the shape instead of drawing it.\n\n(Adapted from Compose.jl.xgon()))\n\n\n\n\n\n","category":"function"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"basics/#The-basics","page":"Basic concepts","title":"The basics","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"The underlying drawing model is that you make shapes, and add points to paths, and these are filled and/or stroked, using the current graphics state, which specifies colors, line thicknesses, scale, orientation, opacity, and so on. You can modify the current graphics state by transforming/rotating/scaling it, and setting style parameters, and so on. Subsequent graphics use the new state, but the graphics you've already drawn are unchanged. The gsave() and grestore() functions (or the @layer .... macro) let you create new temporary graphics states,","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"You can specify points on the drawing surface using Point(x, y). The default origin is at the top left of the drawing area, but you can reposition it at any time. Many of the drawing functions have an action argument. This can be :none, :fill, :stroke, :fillstroke, :fillpreserve, :strokepreserve, :clip, or :path. The default is :none.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Y coordinates increase downwards, so Point(0, 100) is below Point(0, 0). This is the preferred coordinate system for most computer graphics software, but mathematicians and scientists may well be used to the other convention, where the y-axis increasing up the page...","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"The main types you'll encounter in Luxor are:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Name of type Purpose\nDrawing holds the current drawing\nPoint specifies 2D points\nBoundingBox defines a bounding box\nTable defines a table with different column widths and row  heights\nPartition defines a table defined by cell width and height\nTiler defines a rectangular grid of tiles\nBezierPathSegment a Bezier path segment defined by 4 points\nBezierPath contains a series of BezierPathSegments\nGridRect defines a rectangular grid\nGridHex defines a hexagonal grid\nScene used to define a scene for an animation\nTurtle represents a turtle for drawing turtle graphics","category":"page"},{"location":"basics/#Points-and-coordinates","page":"Basic concepts","title":"Points and coordinates","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"The Point type holds two coordinates, x and y. For example:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"julia> P = Point(12.0, 13.0)\nLuxor.Point(12.0, 13.0)\n\njulia> P.x\n12.0\n\njulia> P.y\n13.0","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Points are immutable, so you can't change P's x or y values directly. But it's easy to make new points based on existing ones.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Points can be added together:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"julia> Q = Point(4, 5)\nLuxor.Point(4.0, 5.0)\n\njulia> P + Q\nLuxor.Point(16.0, 18.0)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"You can add and multiply Points and scalars:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"julia> 10P\nLuxor.Point(120.0, 130.0)\n\njulia> P + 100\nLuxor.Point(112.0, 113.0)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"You can also make new points by mixing Points and tuples:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"julia> P + (10, 0)\nLuxor.Point(22.0, 13.0)\n\njulia> Q * (0.5, 0.5)\nLuxor.Point(2.0, 2.5)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"You can also create points from tuples:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"julia> Point((1.0, 14))\nPoint(1.0, 14.0)\n\njulia> plist = (1.0, 2.0), (-10, 10), (14.2, 15.4));\n\njulia> Point.(plist)\n3-element Array{Point,1}:\n Point(1.0, 2.0)\n Point(-10.0, 10.0)\n Point(14.2, 15.4)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"You can use the letter O as a shortcut to refer to the current Origin, Point(0, 0).","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"using Luxor # hide\nDrawing(600, 300, \"assets/figures/point-ex.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"blue\") # hide\nrulers()\nbox.([O + (i, 0) for i in range(0, stop=200, length=5)], 20, 20, :stroke)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: point example)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Angles are usually supplied in radians, measured starting at the positive x-axis turning towards the positive y-axis (which usually points 'down' the page or canvas). So rotations are ‚Äòclockwise‚Äô. (The main exception is for turtle graphics, which conventionally let you supply angles in degrees.)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Coordinates are interpreted as PostScript points, where a point is 1/72 of an inch.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Because Julia allows you to combine numbers and variables directly, you can supply units with dimensions and have them converted to points (assuming the current scale is 1:1):","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"inch (in is unavailable, being used by for syntax)\ncm   (centimeters)\nmm   (millimeters)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"For example:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"rect(Point(20mm, 2cm), 5inch, (22/7)inch, :fill)","category":"page"},{"location":"basics/#Drawings","page":"Basic concepts","title":"Drawings","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"You usually work with a current drawing, so the first thing to do is to create one. Some functions won't work if there isn't a current drawing, and others won't do anything useful, since they'll be overridden when a drawing is subsequently created.","category":"page"},{"location":"basics/#Drawings-and-files","page":"Basic concepts","title":"Drawings and files","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"To create a drawing, and optionally specify the filename, type, and dimensions, use the Drawing constructor function.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Drawing\npaper_sizes","category":"page"},{"location":"basics/#Luxor.Drawing","page":"Basic concepts","title":"Luxor.Drawing","text":"Create a new drawing, and optionally specify file type (PNG, PDF, SVG, EPS), file-based or in-memory, and dimensions.\n\nDrawing(width=600, height=600, file=\"luxor-drawing.png\")\n\nExtended help\n\nDrawing()\n\ncreates a drawing, defaulting to PNG format, default filename \"luxor-drawing.png\", default size 800 pixels square.\n\nYou can specify dimensions, and assume the default output filename:\n\nDrawing(400, 300)\n\ncreates a drawing 400 pixels wide by 300 pixels high, defaulting to PNG format, default filename \"luxor-drawing.png\".\n\nDrawing(400, 300, \"my-drawing.pdf\")\n\ncreates a PDF drawing in the file \"my-drawing.pdf\", 400 by 300 pixels.\n\nDrawing(1200, 800, \"my-drawing.svg\")\n\ncreates an SVG drawing in the file \"my-drawing.svg\", 1200 by 800 pixels.\n\nDrawing(width, height, surfacetype | filename)\n\ncreates a new drawing of the given surface type (e.g. :svg, :png), storing the picture only in memory if no filename is provided.\n\nDrawing(1200, 1200/Base.Mathconstants.golden, \"my-drawing.eps\")\n\ncreates an EPS drawing in the file \"my-drawing.eps\", 1200 wide by 741.8 pixels (= 1200 √∑ œï) high. Only for PNG files must the dimensions be integers.\n\nDrawing(\"A4\", \"my-drawing.pdf\")\n\ncreates a drawing in ISO A4 size (595 wide by 842 high) in the file \"my-drawing.pdf\". Other sizes available are: \"A0\", \"A1\", \"A2\", \"A3\", \"A4\", \"A5\", \"A6\", \"Letter\", \"Legal\", \"A\", \"B\", \"C\", \"D\", \"E\". Append \"landscape\" to get the landscape version.\n\nDrawing(\"A4landscape\")\n\ncreates the drawing A4 landscape size.\n\nPDF files default to a white background, but PNG defaults to transparent, unless you specify one using background().\n\nDrawing(width, height, :image)\n\ncreates the drawing in an image buffer in memory. You can obtain the data as a matrix with image_as_matrix().\n\n\n\n\n\n","category":"type"},{"location":"basics/#Luxor.paper_sizes","page":"Basic concepts","title":"Luxor.paper_sizes","text":"paper_sizes\n\nThe paper_sizes Dictionary holds a few paper sizes, width is first, so default is Portrait:\n\n\"A0\"      => (2384, 3370),\n\"A1\"      => (1684, 2384),\n\"A2\"      => (1191, 1684),\n\"A3\"      => (842, 1191),\n\"A4\"      => (595, 842),\n\"A5\"      => (420, 595),\n\"A6\"      => (298, 420),\n\"A\"       => (612, 792),\n\"Letter\"  => (612, 792),\n\"Legal\"   => (612, 1008),\n\"Ledger\"  => (792, 1224),\n\"B\"       => (612, 1008),\n\"C\"       => (1584, 1224),\n\"D\"       => (2448, 1584),\n\"E\"       => (3168, 2448))\n\n\n\n\n\n","category":"constant"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"To finish a drawing and close the file, use finish(), and, to launch an external application to view it, use preview().","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: jupyter)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"If you're using Juno or VS Code, then PNG and SVG files should appear in the Plots pane. In a Pluto notebook, output appears above the cell. In a notebook environment, output appears in the next notebook cell.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: juno)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"finish\npreview","category":"page"},{"location":"basics/#Luxor.finish","page":"Basic concepts","title":"Luxor.finish","text":"finish()\n\nFinish the drawing, and close the file. You may be able to open it in an external viewer application with preview().\n\n\n\n\n\n","category":"function"},{"location":"basics/#Luxor.preview","page":"Basic concepts","title":"Luxor.preview","text":"preview()\n\nIf working in a notebook (eg Jupyter/IJulia), display a PNG or SVG file in the notebook.\n\nIf working in Juno, display a PNG or SVG file in the Plot pane.\n\nDrawings of type :image should be converted to a matrix with image_as_matrix() before calling finish().\n\nOtherwise:\n\non macOS, open the file in the default application, which is probably the Preview.app for PNG and PDF, and Safari for SVG\non Unix, open the file with xdg-open\non Windows, refer to COMSPEC.\n\n\n\n\n\n","category":"function"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"note: Note\nSVGs are text based, and can get quite big. Up to a certain size, SVGs will be previewable as easily and quickly as PNGs. But very large drawings in SVG format won't necessarily  be displayed.","category":"page"},{"location":"basics/#Quick-drawings-with-macros","page":"Basic concepts","title":"Quick drawings with macros","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"The @draw, @svg, @png, and @pdf macros are designed to let you quickly create graphics without having to provide the usual boiler-plate functions. For example, the Julia code:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"@svg circle(Point(0, 0), 20, :stroke) 50 50","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"expands to","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Drawing(50, 50, \"luxor-drawing-(timestamp).svg\")\norigin()\nbackground(\"white\")\nsethue(\"black\")\ncircle(Point(0, 0), 20, :stroke)\nfinish()\npreview()","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"They're just short-cuts - designed to save a bit of typing. You can omit the width and height (thus defaulting to 600 by 600, except for @imagematrix), and you don't have to specify a filename (you'll get time-stamped files in the current working directory). For multiple lines, use either:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"@svg begin\n    setline(10)\n    sethue(\"purple\")\n    circle(Point(0, 0), 20, :fill)\nend","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"or (less nicely):","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"@svg (setline(10);\n      sethue(\"purple\");\n      circle(Point(0, 0), 20, :fill)\n     )","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"The @draw macro creates a drawing in-memory (not saved in a file). You should see it displayed if you're working in a suitable environment (Juno, VSCode, Jupyter, Pluto).","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"@svg\n@png\n@pdf\n@draw","category":"page"},{"location":"basics/#Luxor.@svg","page":"Basic concepts","title":"Luxor.@svg","text":"@svg drawing-instructions [width] [height] [filename]\n\nCreate and preview an SVG drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as filename if supplied, or luxor-drawing-(timestamp).svg.\n\nExamples\n\n@svg circle(O, 20, :fill)\n\n@svg circle(O, 20, :fill) 400\n\n@svg circle(O, 20, :fill) 400 1200\n\n@svg circle(O, 20, :fill) 400 1200 \"/tmp/test\"\n\n@svg circle(O, 20, :fill) 400 1200 \"/tmp/test.svg\"\n\n@svg begin\n        setline(10)\n        sethue(\"purple\")\n        circle(O, 20, :fill)\n     end\n\n@svg begin\n        setline(10)\n        sethue(\"purple\")\n        circle(O, 20, :fill)\n     end 1200 1200\n\n\n\n\n\n","category":"macro"},{"location":"basics/#Luxor.@png","page":"Basic concepts","title":"Luxor.@png","text":"@png drawing-instructions [width] [height] [filename]\n\nCreate and preview an PNG drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as filename, if supplied, or luxor-drawing(timestamp).png.\n\nExamples\n\n@png circle(O, 20, :fill)\n\n@png circle(O, 20, :fill) 400\n\n@png circle(O, 20, :fill) 400 1200\n\n@png circle(O, 20, :fill) 400 1200 \"/tmp/round\"\n\n@png circle(O, 20, :fill) 400 1200 \"/tmp/round.png\"\n\n@png begin\n        setline(10)\n        sethue(\"purple\")\n        circle(O, 20, :fill)\n     end\n\n\n@png begin\n        setline(10)\n        sethue(\"purple\")\n        circle(O, 20, :fill)\n     end 1200 1200\n\n\n\n\n\n","category":"macro"},{"location":"basics/#Luxor.@pdf","page":"Basic concepts","title":"Luxor.@pdf","text":"@pdf drawing-instructions [width] [height] [filename]\n\nCreate and preview an PDF drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as filename if supplied, or luxor-drawing(timestamp).pdf.\n\nExamples\n\n@pdf circle(O, 20, :fill)\n\n@pdf circle(O, 20, :fill) 400\n\n@pdf circle(O, 20, :fill) 400 1200\n\n@pdf circle(O, 20, :fill) 400 1200 \"/tmp/A0-version\"\n\n@pdf circle(O, 20, :fill) 400 1200 \"/tmp/A0-version.pdf\"\n\n@pdf begin\n        setline(10)\n        sethue(\"purple\")\n        circle(O, 20, :fill)\n     end\n\n@pdf begin\n        setline(10)\n        sethue(\"purple\")\n        circle(O, 20, :fill)\n     end 1200 1200\n\n\n\n\n\n","category":"macro"},{"location":"basics/#Luxor.@draw","page":"Basic concepts","title":"Luxor.@draw","text":"@draw drawing-instructions [width] [height]\n\nPreview an PNG drawing, optionally specifying width and height (the default is 600 by 600). The drawing is stored in memory, not in a file on disk.\n\nExamples\n\n@draw circle(O, 20, :fill)\n\n@draw circle(O, 20, :fill) 400\n\n@draw circle(O, 20, :fill) 400 1200\n\n\n@draw begin\n         setline(10)\n         sethue(\"purple\")\n         circle(O, 20, :fill)\n      end\n\n\n@draw begin\n         setline(10)\n         sethue(\"purple\")\n         circle(O, 20, :fill)\n      end 1200 1200\n\n\n\n\n\n","category":"macro"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"If you don't specify a size, the defaults are usually 600 by 600. If you don't specify a file name, files created with the macros are placed in your current working directory as luxor-drawing- followed by a time stamp. You don't even have to specify the suffix:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"@svg juliacircles(150) 400 400 \"test\" # saves in \"test.svg\"","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"If you want to create drawings with transparent backgrounds, or use variables to specify filenames, you have to use the longer form, rather than the macros:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Drawing()\nbackground(1, 1, 1, 0)\norigin()\nsetline(30)\nsethue(\"green\") # assumes current opacity\nbox(BoundingBox() - 50, :stroke)\nfinish()\npreview()","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: transparent background)","category":"page"},{"location":"basics/#Drawings-in-memory","page":"Basic concepts","title":"Drawings in memory","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"You can choose to store the drawing in memory. The advantage is that in-memory drawings are quicker, and can be passed as Julia data. It's useful in some environments to not have to worry about writing files. This syntax for the Drawing() function:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Drawing(width, height, surfacetype, [filename])","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"lets you supply surfacetype as a symbol (:svg or :png). This creates a new drawing of the given surface type and stores the image only in memory if no filename is supplied. The @draw macro creates PNG files in memory.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"You can specify :image as the surface type. This allows you to copy the current drawing into a 2D matrix (using image_as_matrix()). See the Images chapter for more information.","category":"page"},{"location":"basics/#Interactive-drawings","page":"Basic concepts","title":"Interactive drawings","text":"","category":"section"},{"location":"basics/#Using-Pluto","page":"Basic concepts","title":"Using Pluto","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Pluto notebooks typically display the final result of a piece of code in a cell. So there are various ways you can organize your drawing code. For example:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"using Luxor, PlutoUI, Colors\n\n@bind x Slider(0:0.1:12)\n\n@bind y Slider(1:12)\n\n@draw begin\n\tsetopacity(0.8)\n\tfor i in 0:0.1:1\n\t\tsethue(HSB(360i, .8, .8))\n\t\tsquircle(O, 50, 50, :fill, rt = x * i)\n\t\trotate(2œÄ/y)\n\tend\nend 100 100","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"or","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"begin\n    d = Drawing(800, 800, :svg)\n    origin()\n\tfor (n, m) in enumerate(exp10.(range(0.0, 2, step=0.2)))\n\t\tsetmesh(mesh(convert(Vector{Point}, BoundingBox()/m),\n\t\t\t[\"darkviolet\",\"gold2\", \"firebrick2\", \"slateblue4\"]))\n    \trotate(œÄ/7)\n    \tpaint()\n\tend\n    finish()\n\td\nend","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: pluto examples)","category":"page"},{"location":"basics/#Using-Jupyter-notebooks-(IJulia-and-Interact)","page":"Basic concepts","title":"Using Jupyter notebooks (IJulia and Interact)","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"Currently, you should use an in-memory SVG drawing to display graphics if you're using Interact.jl. This example provides an HSB color widget.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"using Interact, Colors, Luxor\n@manipulate for h in 0:360, s in 0:0.01:1, b in 0:0.01:1\n    d = Drawing(300, 300, :svg)\n    sethue(Colors.HSB(h, s, b))\n    origin()\n    circle(Point(0, 0), 100, :fill)  \n    circle(polar(110, deg2rad(h)), 10, :fill)\n    sethue(\"black\")\n    label(string(h, \"¬∞\"), deg2rad(h), polar(120, deg2rad(h)))\n        finish()\n    d\nend","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: interactive)","category":"page"},{"location":"basics/#The-drawing-surface","page":"Basic concepts","title":"The drawing surface","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"The origin (0/0) starts off at the top left: the x axis runs left to right across the page, and the y axis runs top to bottom down the page.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"The origin() function moves the 0/0 point to the center of the drawing. It's often convenient to do this at the beginning of a program.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"You can use functions like scale(), rotate(), and translate() to change the coordinate system.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"background() fills the drawing with a color, covering any previous contents. By default, PDF drawings have a white background, whereas PNG drawings have no background so that the background appears transparent in other applications. If there is a current clipping region, background() fills just that region. In the next example, the first background() fills the entire drawing with magenta, but the calls in the loop fill only the active clipping region, a table cell defined by the Table iterator:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"using Luxor # hide\nDrawing(600, 400, \"assets/figures/backgrounds.png\") # hide\nbackground(\"magenta\")\norigin()\ntable = Table(5, 5, 100, 50)\nfor (pos, n) in table\n    box(pos,\n        table.colwidths[table.currentcol],\n        table.rowheights[table.currentrow],\n        :clip)\n    background(randomhue()...)\n    clipreset()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: background)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"The rulers() function draws a couple of rulers to indicate the position and orientation of the current axes.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"using Luxor # hide\nDrawing(400, 400, \"assets/figures/axes.png\") # hide\nbackground(\"gray80\")\norigin()\nrulers()\nfinish() # hide\nnothing # hide","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: axes)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"background\nrulers\norigin","category":"page"},{"location":"basics/#Luxor.background","page":"Basic concepts","title":"Luxor.background","text":"background(color)\n\nFill the canvas with a single color. Returns the (red, green, blue, alpha) values.\n\nExamples:\n\nbackground(\"antiquewhite\")\nbackground(1, 0.0, 1.0)\nbackground(1, 0.0, 1.0, .5)\n\nIf Colors.jl is installed:\n\nbackground(RGB(0, 1, 0))\nbackground(RGBA(0, 1, 0))\nbackground(RGBA(0, 1, 0, .5))\nbackground(Luv(20, -20, 30))\n\nIf you don't specify a background color for a PNG drawing, the background will be transparent. You can set a partly or completely transparent background for PNG files by passing a color with an alpha value, such as this 'transparent black':\n\nbackground(RGBA(0, 0, 0, 0))\n\nor\n\nbackground(0, 0, 0, 0)\n\nReturns a tuple (r, g, b, a) of the color that was used to paint the background.\n\n\n\n\n\n","category":"function"},{"location":"basics/#Luxor.rulers","page":"Basic concepts","title":"Luxor.rulers","text":"rulers()\n\nDraw and label two rulers starting at O, the current 0/0, and continuing out along the current positive x and y axes.\n\n\n\n\n\n","category":"function"},{"location":"basics/#Luxor.origin","page":"Basic concepts","title":"Luxor.origin","text":"origin()\n\nReset the current matrix, and then set the 0/0 origin to the center of the drawing (otherwise it will stay at the top left corner, the default).\n\nYou can refer to the 0/0 point as O. (O = Point(0, 0)),\n\n\n\n\n\norigin(pt:Point)\n\nReset the current matrix, then move the 0/0 position to pt.\n\n\n\n\n\n","category":"function"},{"location":"basics/#Save-and-restore","page":"Basic concepts","title":"Save and restore","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"gsave() saves a copy of the current graphics settings (current axis rotation, position, scale, line and text settings, color, and so on). When the next grestore() is called, all changes you've made to the graphics settings will be discarded, and the previous settings are restored, so things return to how they were when you last used gsave(). gsave() and grestore() should always be balanced in pairs, enclosing the functions.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"The @layer macro is a synonym for a gsave()...grestore() pair.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"@svg begin\n    circle(Point(0, 0), 100, :stroke)\n    @layer (sethue(\"red\"); rule(Point(0, 0)); rule(O, œÄ/2))\n    circle(Point(0, 0), 200, :stroke)\nend","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"or","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"@svg begin\n    circle(Point(0, 0), 100, :stroke)\n    @layer begin\n        sethue(\"red\")\n        rule(Point(0, 0))\n        rule(Point(0, 0), pi/2)\n    end\n    circle(Point(0, 0), 200, :stroke)\nend","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"gsave\ngrestore","category":"page"},{"location":"basics/#Luxor.gsave","page":"Basic concepts","title":"Luxor.gsave","text":"gsave()\n\nSave the current color settings on the stack.\n\n\n\n\n\n","category":"function"},{"location":"basics/#Luxor.grestore","page":"Basic concepts","title":"Luxor.grestore","text":"grestore()\n\nReplace the current graphics state with the one on top of the stack.\n\n\n\n\n\n","category":"function"},{"location":"basics/#Return-the-current-drawing","page":"Basic concepts","title":"Return the current drawing","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"In some situations you'll want to explicitly return the current drawing to the calling function.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"currentdrawing","category":"page"},{"location":"basics/#Luxor.currentdrawing","page":"Basic concepts","title":"Luxor.currentdrawing","text":"currentdrawing()\n\nReturn the current Luxor drawing, if there currently is one.\n\n\n\n\n\n","category":"function"},{"location":"basics/#Drawing-as-image-matrix","page":"Basic concepts","title":"Drawing as image matrix","text":"","category":"section"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"While drawing, you can copy the current graphics in a drawing as a matrix of pixels, using the image_as_matrix() function.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"image_as_matrix() returns a array of ARGB32 values. Each ARGB value encodes the Red, Green, Blue, and Alpha values of a pixel into a single 32 bit integer.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"The following example draws a red rectangle, then copies the drawing into a matrix called mat1. Then it adds a blue triangle, and copies the updated drawing into mat2. In the second drawing, values from the two matrices are tested, and table cells are randomly colored depending on the corresponding values ... this is a primitive Boolean operation.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"using Luxor, Colors, Random # hide\nRandom.seed!(42) # hide\nDrawing(40, 40, :png)\norigin()\nbackground(\"black\")\nsethue(\"red\")\nbox(Point(0, 0), 40, 15, :fill)\nmat1 = image_as_matrix()\nsethue(\"blue\")\nsetline(10)\nsetopacity(0.6)\nngon(Point(0, 0), 10, 3, 0, :stroke)\nmat2 = image_as_matrix()\nfinish()\n\n# second drawing\n\nDrawing(400, 400, \"assets/figures/image-drawings.svg\")\nbackground(\"grey20\")\norigin()\nt = Table(40, 40, 4, 4)\nsethue(\"white\")\nrc = CartesianIndices(mat1)\nfor i in rc\n    r, c = Tuple(i)\n    pixel1 = convert(Colors.RGBA, mat1[r, c])\n    pixel2 = convert(Colors.RGBA, mat2[r, c])\n    if red(pixel1) > .5 && blue(pixel2) > .5\n        randomhue()\n        box(t, r, c, :fillstroke)\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"The first image (enlarged) shows the mat1 matrix as red, mat2 as blue.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: intermediate)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"In the second drawing, a table with 1600 squares is colored according to the values in the matrices.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: image drawings)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(You can use collect() to gather the re-interpreted values together.)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"You can display the matrix using, for example, Images.jl.","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"using Luxor, Images\n\n# in Luxor\n\nDrawing(250, 250, :png)\norigin()\nbackground(randomhue()...)\nsethue(\"red\")\nfontsize(200)\nfontface(\"Georgia\")\ntext(\"42\", halign=:center, valign=:middle)\nmat = image_as_matrix()\nfinish()\n\n# in Images\n\nimg = RGB.(mat)\n# img = Gray.(mat) # for greyscale\n\nimfilter(img, Kernel.gaussian(10))","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"In Luxor:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: 42 image array)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"In Images:","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"(Image: 42 image array)","category":"page"},{"location":"basics/","page":"Basic concepts","title":"Basic concepts","text":"@imagematrix\n@imagematrix!\nimage_as_matrix\nimage_as_matrix!","category":"page"},{"location":"basics/#Luxor.@imagematrix","page":"Basic concepts","title":"Luxor.@imagematrix","text":"@imagematrix drawing-instructions [width=256] [height=256]\n\nCreate a drawing and return a matrix of the image.\n\nThis macro returns a matrix of pixels that represent the drawing produced by the vector graphics instructions. It uses the image_as_matrix() function.\n\nThe default drawing is 256 by 256 points.\n\nYou don't need finish() (the macro calls it), and it's not previewed by preview().\n\nm = @imagematrix begin\n        sethue(\"red\")\n        box(O, 20, 20, :fill)\n    end 60 60\n\njulia>  m[1220:1224] |> show\n    ARGB32[ARGB32(0.0N0f8,0.0N0f8,0.0N0f8,0.0N0f8),\n           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),\n           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),\n           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),\n           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8)]\n\n\nIf, for some strange reason you want to draw the matrix as another Luxor drawing again, use code such as this:\n\nm = @imagematrix begin\n        sethue(\"red\")\n        box(O, 20, 20, :fill)\n        sethue(\"blue\")\n        box(O, 10, 40, :fill)\n    end 60 60\n\nfunction convertmatrixtocolors(m)\n    return convert.(Colors.RGBA, m)\nend\n\nfunction drawimagematrix(m)\n    d = Drawing(500, 500, \"/tmp/temp.png\")\n    origin()\n    w, h = size(m)\n    t = Tiler(500, 500, w, h)\n    mi = convertmatrixtocolors(m)\n    @show mi[30, 30]\n    for (pos, n) in t\n        c = mi[t.currentrow, t.currentcol]\n        setcolor(c)\n        box(pos, t.tilewidth -1, t.tileheight - 1, :fill)\n    end\n    finish()\n    return d\nend\n\ndrawimagematrix(m)\n\nTransparency\n\nThe default value for the cells in an image matrix is transparent black. (Luxor's default color is opaque black.)\n\njulia> @imagematrix begin\n       end 2 2\n2√ó2 reinterpret(ARGB32, ::Array{UInt32,2}):\n ARGB32(0.0,0.0,0.0,0.0)  ARGB32(0.0,0.0,0.0,0.0)\n ARGB32(0.0,0.0,0.0,0.0)  ARGB32(0.0,0.0,0.0,0.0)\n\nSetting the background to a partially or completely transparent value may give unexpected results:\n\njulia> @imagematrix begin\n       background(1, 0.5, 0.0, 0.5) # semi-transparent orange\n       end 2 2\n2√ó2 reinterpret(ARGB32, ::Array{UInt32,2}):\n ARGB32(0.502,0.251,0.0,0.502)  ARGB32(0.502,0.251,0.0,0.502)\n ARGB32(0.502,0.251,0.0,0.502)  ARGB32(0.502,0.251,0.0,0.502)\n\nhere the semi-transparent orange color has been partially applied to the transparent background.\n\njulia> @imagematrix begin\n           sethue(1., 0.5, 0.0)\n       paint()\n       end 2 2\n2√ó2 reinterpret(ARGB32, ::Array{UInt32,2}):\n ARGB32(1.0,0.502,0.0,1.0)  ARGB32(1.0,0.502,0.0,1.0)\n ARGB32(1.0,0.502,0.0,1.0)  ARGB32(1.0,0.502,0.0,1.0)\n\npicks up the default alpha of 1.0.\n\n\n\n\n\n","category":"macro"},{"location":"basics/#Luxor.@imagematrix!","page":"Basic concepts","title":"Luxor.@imagematrix!","text":"@imagematrix! buffer drawing-instructions [width=256] [height=256]\n\nLike @imagematrix, but use an existing UInt32 buffer.\n\nw = 200\nh  = 150\nbuffer = zeros(UInt32, w, h)\nm = @imagematrix! buffer juliacircles(40) 200 150;\nImages.RGB.(m)\n\n\n\n\n\n","category":"macro"},{"location":"basics/#Luxor.image_as_matrix","page":"Basic concepts","title":"Luxor.image_as_matrix","text":"image_as_matrix()\n\nReturn an Array of the current state of the picture as an array of ARGB32.\n\nA matrix 50 wide and 30 high => a table 30 rows by 50 cols\n\nusing Luxor, Images\n\nDrawing(50, 50, :png)\norigin()\nbackground(randomhue()...)\nsethue(\"white\")\nfontsize(40)\nfontface(\"Georgia\")\ntext(\"42\", halign=:center, valign=:middle)\nmat = image_as_matrix()\nfinish()\n\n\n\n\n\n","category":"function"},{"location":"basics/#Luxor.image_as_matrix!","page":"Basic concepts","title":"Luxor.image_as_matrix!","text":"image_as_matrix!(buffer)\n\nLike image_as_matrix(), but use an existing UInt32 buffer.\n\nbuffer is a buffer of UInt32.\n\nw = 200\nh = 150\nbuffer = zeros(UInt32, w, h)\nDrawing(w, h, :image)\norigin()\njuliacircles(50)\nm = image_as_matrix!(buffer)\nfinish()\n# collect(m)) is Array{ARGB32,2}\nImages.RGB.(m)\n\n\n\n\n\n","category":"function"},{"location":"livegraphics/#Live-graphics","page":"Live graphics","title":"Live graphics","text":"","category":"section"},{"location":"livegraphics/","page":"Live graphics","title":"Live graphics","text":"With the help of an external appication to manage windows, it's possible to use Luxor to create continuously changing graphics in a window.","category":"page"},{"location":"livegraphics/","page":"Live graphics","title":"Live graphics","text":"This example uses the MiniFB package, which you can add using ] add MiniFB.","category":"page"},{"location":"livegraphics/","page":"Live graphics","title":"Live graphics","text":"The file play.jl defines a simple macro, @play, which continuously evaluates and draws the graphics in a window. For example, this code:","category":"page"},{"location":"livegraphics/","page":"Live graphics","title":"Live graphics","text":"using Luxor\n\ninclude(dirname(pathof(Luxor)) * \"/play.jl\")\n\nlet Œ∏ = 0\n    @play 400 400 begin\n    #\n        background(\"black\")\n        sethue(\"white\")\n        rotate(Œ∏)\n        hypotrochoid(200, 110, 37, :stroke)\n        Œ∏ += œÄ/120\n        sleep(0.01)\n    #\n    end\nend","category":"page"},{"location":"livegraphics/","page":"Live graphics","title":"Live graphics","text":"draws a continuously rotating hypotrochoid.","category":"page"},{"location":"livegraphics/#Clock","page":"Live graphics","title":"Clock","text":"","category":"section"},{"location":"livegraphics/","page":"Live graphics","title":"Live graphics","text":"This code also imports the @play macro.","category":"page"},{"location":"livegraphics/","page":"Live graphics","title":"Live graphics","text":"The call to sleep() reduces the CPU time, and allows other processes to run, but the millisecond animation will be less smooth as a result.","category":"page"},{"location":"livegraphics/","page":"Live graphics","title":"Live graphics","text":"(Image: clock)","category":"page"},{"location":"livegraphics/","page":"Live graphics","title":"Live graphics","text":"using Luxor, Colors, Dates, ColorSchemes\n\ninclude(dirname(pathof(Luxor)) * \"/play.jl\")\n\nfunction clock(cscheme=ColorSchemes.leonardo)\n    @play 400 600 begin\n\n        # background\n        sethue(get(cscheme, .0))\n        paint()\n\n        # 24hour sector\n        fontsize(30)\n        sethue(get(cscheme, .2))\n        h = Dates.hour(now())\n        sector(O, 180, 200, œÄ/2, œÄ/2 + rescale(h, 0, 24, 0, 2pi), :fill)\n\n        @layer begin\n            fontsize(12)\n            sethue(\"white\")\n            @. text([\"0\", \"6\", \"12\", \"18\"], polar(190, [i * œÄ/2 for i in 1:4]),\n                halign=:center,\n                valign=:middle)\n        end\n\n        # minute sector\n        sethue(get(cscheme, .4))\n        m = Dates.minute(now())\n        sector(O, 160, 180, 3œÄ/2, 3œÄ/2 + rescale(m, 0, 60, 0, 2pi), :fill)\n\n        # second sector\n        sethue(get(cscheme, .6))\n        s = Dates.second(now())\n        sector(O, 140, 160, 3œÄ/2, 3œÄ/2 + rescale(s, 0, 60, 0, 2pi), :fill)\n\n        # millisecond indicator\n        @layer begin\n            setopacity(0.5)\n            sethue(get(cscheme, .8))\n            ms = Dates.value(Dates.Millisecond(Dates.now()))\n            circle(polar(120, 3œÄ/2 + rescale(ms, 0, 1000, 0, 2pi)), 20, :fill)\n        end\n\n        # central text\n        fontface(\"JuliaMono-Black\")\n        sethue(get(cscheme, 1.0))\n        text(Dates.format(Dates.now(), \"HH:MM:SS\"), halign=:center)\n\n        sleep(0.05)\n    end\nend\n\nclock(ColorSchemes.klimt)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"DocTestSetup = quote\n    using Luxor, Colors, Random\n    end","category":"page"},{"location":"geometrytools/#Geometry-tools","page":"Geometry tools","title":"Geometry tools","text":"","category":"section"},{"location":"geometrytools/#Lines-and-distances","page":"Geometry tools","title":"Lines and distances","text":"","category":"section"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"You can find the midpoint between two points using midpoint().","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"The following code places a small pentagon (using ngon()) at the midpoint of each side of a larger pentagon:","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\nDrawing(700, 220, \"assets/figures/midpoint.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"red\")\nngon(O, 100, 5, 0, :stroke)\n\nsethue(\"darkgreen\")\np5 = ngon(O, 100, 5, 0, vertices=true)\n\nfor i in eachindex(p5)\n    pt1 = p5[mod1(i, 5)]\n    pt2 = p5[mod1(i + 1, 5)]\n    ngon(midpoint(pt1, pt2), 20, 5, 0, :fill)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: arc)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"A more general function, between(), finds for a value x between 0 and 1 the corresponding point on a line defined by two points. So midpoint(p1, p2) and between(p1, p2, 0.5) should return the same point.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\nDrawing(700, 150, \"assets/figures/betweenpoint.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"red\")\np1 = Point(-150, 0)\np2 = Point(150, 40)\nline(p1, p2)\nstrokepath()\nfor i in -0.5:0.1:1.5\n    randomhue()\n    circle(between(p1, p2, i), 5, :fill)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: arc)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"Values less than 0.0 and greater than 1.0 appear to work well too, placing the point on the line if extended.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"midpoint\nbetween","category":"page"},{"location":"geometrytools/#Luxor.midpoint","page":"Geometry tools","title":"Luxor.midpoint","text":"midpoint(p1, p2)\n\nFind the midpoint between two points.\n\n\n\n\n\nmidpoint(a)\n\nFind midpoint between the first two elements of an array of points.\n\n\n\n\n\nmidpoint(bb::BoundingBox)\n\nReturns the point midway between the two points of the BoundingBox. This should also be the center, unless I've been very stupid...\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.between","page":"Geometry tools","title":"Luxor.between","text":"between(p1::Point, p2::Point, x)\nbetween((p1::Point, p2::Point), x)\n\nFind the point between point p1 and point p2 for x, where x is typically between 0 and 1. between(p1, p2, 0.5) is equivalent to midpoint(p1, p2).\n\n\n\n\n\nbetween(bb::BoundingBox, x)\n\nFind a point between the two corners of a BoundingBox corresponding to x, where x is typically between 0 and 1.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"center3pts() finds the radius and center point of a circle passing through three points which you can then use with functions such as circle() or arc2r().","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"getnearestpointonline() finds perpendiculars, as does perpendicular().","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\nDrawing(600, 400, \"assets/figures/perpendicular.svg\") # hide\norigin() # hide\nbackground(\"white\") # hide\n\npt1, pt2 = Point(-150, 0), Point(150, 50)\nline(pt1, pt2, :stroke)\n\npt3 = Point(-50, -80)\ncircle.([pt1, pt2, pt3], 3, :fill)\n\np = getnearestpointonline(pt1, pt2, pt3)\nsethue(\"red\")\narrow(pt3, p)\ncircle(pt3, 4, :fill)\n\npt4, pt5 = perpendicular(pt1, pt2)\nsetline(3)\n\nsethue(\"black\")\nlabel.(string.([\"p\", \"pt1\", \"pt2\", \"pt3\", \"pt4\", \"pt5\"]), :ne, (p, pt1, pt2, pt3, pt4, pt5))\n\nsethue(\"green\")\narrow(pt4, pt5)\ncircle.([pt4, pt5], 4, :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: arc)","category":"page"},{"location":"geometrytools/#Points-and-arcs","page":"Geometry tools","title":"Points and arcs","text":"","category":"section"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"Use isarcclockwise(c, p1, p2) to check whether an arc centered at c running from p1 to p2 is clockwise.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"The pointinverse() function finds the inverse of a point relative to a reference circle (centerpoint and radius). In the image, each vertex on the star is linked by an arrow to its inverse.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\nDrawing(600, 400, \"assets/figures/pointinverse.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(1) # hide\n\nradius = 80\nstarradius = 70\nsethue(\"black\")\npoints = star(O, starradius, 5, 0.5, œÄ/5, vertices=true)\nantipoints = last.(pointinverse.(points, O, radius))\n\n@layer (sethue(\"grey90\"); poly(antipoints, :fill))\n@layer (sethue(\"grey75\"); poly(points, :fill))\ncircle(O, radius, :stroke)\n\nprettypoly.((points, antipoints), :none,\n    vertexlabels = (n, l) -> (label(string(n), :ne)))\nforeach(x -> arrow(x[1] , x[2]), zip(points, antipoints))\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: arc)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"Use anglethreepoints() to find the angle formed by two lines connecting three points:","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\nDrawing(800, 800, \"assets/figures/anglethreepoints.png\") # hide\norigin() # hide\n\nfunction showangle(pt1, pt2, pt3)\n    Œ∏ = anglethreepoints(pt1, pt2, pt3)\n    label(string(round(rad2deg(Œ∏), digits=2), \"¬∞\"), :w, pt2)\n    newpath()\n    carc(pt2, 50, 0, -Œ∏, 0)\n    strokepath()\nend\n\nlet\n    background(\"grey20\")\n    sethue(\"white\")\n    fontsize(12)\n    tiles = Tiler(800, 800, 4, 4)\n    for (pos, n) in tiles\n        @layer begin\n            translate(pos)\n            pg = [polar(50, 0), O, polar(50, n * -2œÄ/16)]\n            poly(pg, :stroke)\n            for n in 1:3\n                pt1 = pg[1]\n                pt2 = pg[2]\n                pt3 = pg[3]\n                showangle(pt1, pt2, pt3)\n            end\n        end\n    end\n    finish() # hide\nend\n\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: angle three points)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"distance\ngetnearestpointonline\npointlinedistance\nslope\nperpendicular\ndotproduct\n@polar\npolar\nispointonline\nisarcclockwise\npointinverse\nanglethreepoints","category":"page"},{"location":"geometrytools/#Luxor.distance","page":"Geometry tools","title":"Luxor.distance","text":"distance(p1::Point, p2::Point)\n\nFind the distance between two points (two argument form).\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.getnearestpointonline","page":"Geometry tools","title":"Luxor.getnearestpointonline","text":"getnearestpointonline(pt1::Point, pt2::Point, startpt::Point)\n\nGiven a line from pt1 to pt2, and startpt is the start of a perpendicular heading to meet the line, at what point does it hit the line?\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.pointlinedistance","page":"Geometry tools","title":"Luxor.pointlinedistance","text":"pointlinedistance(p::Point, a::Point, b::Point)\n\nFind the distance between a point p and a line between two points a and b.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.slope","page":"Geometry tools","title":"Luxor.slope","text":"slope(pointA::Point, pointB::Point)\n\nFind angle of a line starting at pointA and ending at pointB.\n\nReturn a value between 0 and 2pi. Value will be relative to the current axes.\n\nslope(O, Point(0, 100)) |> rad2deg # y is positive down the page\n90.0\n\nslope(Point(0, 100), O) |> rad2deg\n270.0\n\nThe slope isn't the same as the gradient. A vertical line going up has a slope of 3œÄ/2.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.perpendicular","page":"Geometry tools","title":"Luxor.perpendicular","text":"perpendicular(p1, p2, k)\n\nReturn a point p3 that is k units away from p1, such that a line p1 p3 is perpendicular to p1 p2.\n\nConvention? to the right?\n\n\n\n\n\nperpendicular(p1, p2)\n\nReturn two points p3 and p4 such that a line from p3 to p4 is perpendicular to a line from p1 to p2, the same length, and the lines intersect at their midpoints.\n\n\n\n\n\nperpendicular(p::Point)\n\nReturns point Point(p.y, -p.x).\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.dotproduct","page":"Geometry tools","title":"Luxor.dotproduct","text":"dotproduct(a::Point, b::Point)\n\nReturn the scalar dot product of the two points.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.@polar","page":"Geometry tools","title":"Luxor.@polar","text":"@polar (p)\n\nConvert a tuple of two numbers to a Point of x, y Cartesian coordinates.\n\n@polar (10, pi/4)\n@polar [10, pi/4]\n\nproduces\n\nLuxor.Point(7.0710678118654755, 7.071067811865475)\n\n\n\n\n\n","category":"macro"},{"location":"geometrytools/#Luxor.polar","page":"Geometry tools","title":"Luxor.polar","text":"polar(r, theta)\n\nConvert point in polar form (radius and angle) to a Point.\n\npolar(10, pi/4)\n\nproduces\n\nLuxor.Point(7.071067811865475, 7.0710678118654755)\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.ispointonline","page":"Geometry tools","title":"Luxor.ispointonline","text":"ispointonline(pt::Point, pt1::Point, pt2::Point;\n    extended = false,\n    atol = 10E-5)\n\nReturn true if the point pt lies on a straight line between pt1 and pt2.\n\nIf extended is false (the default) the point must lie on the line segment between pt1 and pt2. If extended is true, the point lies on the line if extended in either direction.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.isarcclockwise","page":"Geometry tools","title":"Luxor.isarcclockwise","text":"isarcclockwise(c::Point, A::Point, B::Point)\n\nReturn true if an arc centered at c going from A to B is clockwise.\n\nIf c, A, and B are collinear, then a hemispherical arc could be either clockwise or not.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.pointinverse","page":"Geometry tools","title":"Luxor.pointinverse","text":"pointinverse(A::Point, centerpoint::Point, rad)\n\nFind A‚Ä≤, the inverse of a point A with respect to a circle centerpoint/rad, such that:\n\ndistance(centerpoint, A) * distance(centerpoint, A‚Ä≤) == rad^2\n\nReturn (true, A‚Ä≤) or (false, A).\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.anglethreepoints","page":"Geometry tools","title":"Luxor.anglethreepoints","text":"anglethreepoints(p1::Point, p2::Point, p3::Point)\n\nFind the angle formed by two lines defined by three points.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Triangle-centers","page":"Geometry tools","title":"Triangle centers","text":"","category":"section"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\n\nDrawing(350, 350, \"assets/figures/trianglecenters.svg\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(0.4) # hide\nfontsize(11) # hide\n‚ñ≤ = Point[Point(-100.0, 0.0), Point(110.0, 30.0), Point(65.0, 90.0)]\n\n@layer begin\n    sethue(\"red\")\n    setline(2)\n    poly(‚ñ≤,  :stroke, close=true)\nend\n\n# circumcenter\ncircle(‚ñ≤..., :stroke)\ncp = trianglecircumcenter(‚ñ≤...)\ncircle(cp, 2, :fill)\nlabel(\"circumcenter\", :N, cp)\n\n# incenter\ncp = triangleincenter(‚ñ≤...)\ncircle(cp, 2, :fill)\npt1 = getnearestpointonline(‚ñ≤[1], ‚ñ≤[2], cp)\n@layer begin\n    sethue(\"black\")\n    circle(cp, distance(cp, pt1), :stroke)\n    label(\"incenter\", :S, cp)\nend\n\n# center    \ncp = trianglecenter(‚ñ≤...)\ncircle(cp, 2, :fill)\nlabel(\"center\", :w, cp)\n\n# orthocenter\ncp = triangleorthocenter(‚ñ≤...)\ncircle(cp, 2, :fill)\nlabel(\"orthocenter\", :e, cp)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: triangle centers)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"trianglecircumcenter\ntriangleincenter\ntrianglecenter\ntriangleorthocenter","category":"page"},{"location":"geometrytools/#Luxor.trianglecircumcenter","page":"Geometry tools","title":"Luxor.trianglecircumcenter","text":"trianglecircumcenter(pt1::Point, pt2::Point, pt3::Point)\n\nReturn the circumcenter of the triangle defined by pt1, pt2, and pt3. The circumcenter is the center of a circle that passes through the vertices of the triangle.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.triangleincenter","page":"Geometry tools","title":"Luxor.triangleincenter","text":"triangleincenter(pt1::Point, pt2::Point, pt3::Point)\n\nReturn the incenter of the triangle defined by pt1, pt2, and pt3. The incenter is the center of a circle inscribed inside the triangle.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.trianglecenter","page":"Geometry tools","title":"Luxor.trianglecenter","text":"trianglecenter(pt1::Point, pt2::Point, pt3::Point)\n\nReturn the centroid of the triangle defined by pt1, pt2, and pt3.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.triangleorthocenter","page":"Geometry tools","title":"Luxor.triangleorthocenter","text":"triangleorthocenter(pt1::Point, pt2::Point, pt3::Point)\n\nReturn the orthocenter of the triangle defined by pt1, pt2, and pt3.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Intersections","page":"Geometry tools","title":"Intersections","text":"","category":"section"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"intersectionlines() finds the intersection of two lines.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\nDrawing(700, 220, \"assets/figures/intersection.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\nsethue(\"black\")\nP1, P2, P3, P4 = ngon(O, 100, 5, vertices=true)\nlabel.([\"P1\", \"P2\", \"P3\", \"P4\"], :N, [P1, P2, P3, P4])\nline(P1, P2, :stroke)\nline(P4, P3, :stroke)\n\nflag, ip =  intersectionlines(P1, P2, P4, P3)\nif flag\n    circle(ip, 5, :fill)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: arc)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"intersectionlinecircle() finds the intersection of a line and a circle. There can be 0, 1, or 2 intersection points.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\nDrawing(700, 220, \"assets/figures/intersection_line_circle.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"chocolate2\") # hide\nl1 = Point(-100.0, -75.0)\nl2 = Point(300.0, 100.0)\nrad = 100\ncpoint = Point(0, 0)\nline(l1, l2, :stroke)\nsethue(\"darkgreen\") # hide\ncircle(cpoint, rad, :stroke)\nnints, ip1, ip2 =  intersectionlinecircle(l1, l2, cpoint, rad)\nsethue(\"black\")\nif nints == 2\n    circle(ip1, 8, :stroke)\n    circle(ip2, 8, :stroke)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: arc)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"intersection2circles() finds the area of the intersection of two circles, and intersectioncirclecircle() finds the points where they cross.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"This example shows the areas of two circles, and the area of their intersection.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\nDrawing(700, 310, \"assets/figures/intersection2circles.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nfontsize(14) # hide\nsethue(\"black\") # hide\n\nc1 = (O, 150)\nc2 = (O + (100, 0), 150)\n\ncircle(c1... , :stroke)\ncircle(c2... , :stroke)\n\nsethue(\"purple\")\ncircle(c1... , :clip)\ncircle(c2... , :fill)\nclipreset()\n\nsethue(\"black\")\n\ntext(string(150^2 * œÄ |> round), c1[1] - (125, 0))\ntext(string(150^2 * œÄ |> round), c2[1] + (100, 0))\nsethue(\"white\")\ntext(string(intersection2circles(c1..., c2...) |> round),\n     midpoint(c1[1], c2[1]), halign=:center)\n\nsethue(\"red\")\nflag, C, D = intersectioncirclecircle(c1..., c2...)\nif flag\n    circle.([C, D], 5, :fill)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: intersection of two circles)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"intersectionlines\nintersectionlinecircle\nintersection2circles\nintersectioncirclecircle","category":"page"},{"location":"geometrytools/#Luxor.intersectionlines","page":"Geometry tools","title":"Luxor.intersectionlines","text":"intersectionlines(p0, p1, p2, p3,\n    crossingonly=false)\n\nFind point where two lines intersect.\n\nIf crossingonly == true the point of intersection must lie on both lines.\n\nIf crossingonly == false the point of intersection can be where the lines meet if extended almost to 'infinity'.\n\nAccordng to this function, collinear, overlapping, and parallel lines never intersect. Ie, the line segments might be collinear but have no points in common, or the lines segments might be collinear and have many points in common, or the line segments might be collinear and one is entirely contained within the other.\n\nIf the lines are collinear and share a point in common, that is the intersection point.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.intersectionlinecircle","page":"Geometry tools","title":"Luxor.intersectionlinecircle","text":"intersectionlinecircle(p1::Point, p2::Point, cpoint::Point, r)\n\nFind the intersection points of a line (extended through points p1 and p2) and a circle.\n\nReturn a tuple of (n, pt1, pt2)\n\nwhere\n\nn is the number of intersections, 0, 1, or 2\npt1 is first intersection point, or Point(0, 0) if none\npt2 is the second intersection point, or Point(0, 0) if none\n\nThe calculated intersection points won't necessarily lie on the line segment between p1 and p2.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.intersection2circles","page":"Geometry tools","title":"Luxor.intersection2circles","text":"intersection2circles(pt1, r1, pt2, r2)\n\nFind the area of intersection between two circles, the first centered at pt1 with radius r1, the second centered at pt2 with radius r2.\n\nIf one circle is entirely within another, that circle's area is returned.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.intersectioncirclecircle","page":"Geometry tools","title":"Luxor.intersectioncirclecircle","text":"intersectioncirclecircle(cp1, r1, cp2, r2)\n\nFind the two points where two circles intersect, if they do. The first circle is centered at cp1 with radius r1, and the second is centered at cp1 with radius r1.\n\nReturns\n\n(flag, ip1, ip2)\n\nwhere flag is a Boolean true if the circles intersect at the points ip1 and ip2. If the circles don't intersect at all, or one is completely inside the other, flag is false and the points are both Point(0, 0).\n\nUse intersection2circles() to find the area of two overlapping circles.\n\nIn the pure world of maths, it must be possible that two circles 'kissing' only have a single intersection point. At present, this unromantic function reports that two kissing circles have no intersection points.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Bounding-boxes","page":"Geometry tools","title":"Bounding boxes","text":"","category":"section"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"The BoundingBox type allows you to use rectangular extents to organize and interact with the 2D drawing area. A BoundingBox holds two points, the opposite corners of a bounding box.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"You can make a BoundingBox from the current drawing, two points, a text string, an existing polygon, or by modifying an existing one.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"BoundingBox() without arguments defines an extent that encloses the drawing (assuming that the origin is at the center of the drawing‚Äîsee origin()). Use centered=false if the drawing origin is still at the top left corner.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"This example draws circles at three points: at two of the drawing's corners and the midway point between them:","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\nDrawing(700, 400, \"assets/figures/bbox.png\") # hide\nbackground(\"white\") # hide\n\norigin()\n\nbb = BoundingBox()\nsetline(10)\nsethue(\"orange\")\n\ncircle(bb[1], 150, :stroke) # first corner\n\ncircle(bb[2], 150, :stroke) # second corner\n\ncircle(midpoint(bb...), 150, :stroke) # midpoint\n\nsethue(\"blue\")\ncircle.([bb[1], midpoint(bb[1:2]), bb[2]], 130, :fill)\n\nsethue(\"red\")\ncircle.([first(bb), midpoint(bb...), last(bb)], 100, :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: bounding box)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"You can make a bounding box from a polygon:","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\nDrawing(400, 200, \"assets/figures/bboxpoly.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\np = star(O, 100, 5, 0.1, œÄ/3.3, vertices=true)\nsethue(\"antiquewhite\")\nbox(BoundingBox(p), :fill)\n\nsethue(\"black\")\npoly(p, :stroke, close=true)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: bounding box of polygon)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"The resulting bounding box objects can be passed to box() or poly() to be drawn.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"Pass a bounding box to midpoint() to find its center point. The functions boxbottom(), boxheight(), boxtop(), boxaspectratio(), boxdiagonal(), and  boxwidth() return information about a bounding box.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"To convert a bounding box b into a box, use box(b, vertices=true) or convert(Vector{Point}, BoundingBox()).","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"You can also do some arithmetic on bounding boxes. In the next example, the bounding box is created from the text \"good afternoon\". The bounding box is filled with purple, then increased by 40 units on all sides (blue), also scaled by 1.3 (green), and also shifted by (0, 100) (orange).","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor # hide\nDrawing(500, 300, \"assets/figures/bbox2.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\ntranslate(-130,0)\nfontsize(40)\nstr = \"good afternoon\"\nsethue(\"purple\")\nbox(BoundingBox(str), :fill)\nsethue(\"white\")\ntext(str)\n\nsethue(\"blue\")\nmodbox = BoundingBox(str) + 40 # add 40 units to all sides\npoly(modbox, :stroke, close=true)\n\nsethue(\"green\")\nmodbox = BoundingBox(str) * 1.3\npoly(modbox, :stroke, close=true)\n\nsethue(\"orange\")\nmodbox = BoundingBox(str) + (0, 100)\npoly(modbox, :fill, close=true)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: bounding boxes 2)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"You can find the union and intersection of BoundingBoxes, and also find whether a point lies inside one. The following code creates, shrinks, and shifts two bounding boxes (colored yellow and pink), and then draws: their union (a bounding box that includes both), in black outline; and their intersection (a bounding box of their common areas), in red. Then some random points are created (you can pass a bounding box to rand() to get a random point inside the box) and drawn differently depending on whether they're inside the intersection or outside.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor, Random # hide\nDrawing(600, 400, \"assets/figures/bbox3.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\n\norigin()\nsetopacity(0.75)\nsetline(8)\n\nbbox1 = BoundingBox()/2 - (50, 30)\nsethue(\"yellow\")\nbox(bbox1, :fill)\n\nbbox2 = BoundingBox()/2  + (50, 30)\nsethue(\"pink\")\nbox(bbox2, :fill)\n\nsethue(\"black\")\nbox(bbox1 + bbox2, :stroke)\n\nsethue(\"red\")\nbothboxes = intersectboundingboxes(bbox1, bbox2)\nbox(bothboxes, :fill)\n\nfor i in 1:500\n    pt = rand(bbox1 + bbox2)\n    if isinside(pt, bothboxes)\n        sethue(\"white\")\n        circle(pt, 3, :fill)\n    else\n        sethue(\"black\")\n        circle(pt, 2, :fill)\n    end\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: intersecting bounding boxes)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"To find out where a line starting at the center of a bounding box passing through a point crosses or would cross the edges of the box, use pointcrossesboundingbox().","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor, Random # hide\nDrawing(600, 400, \"assets/figures/bbox4.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\norigin() # hide\nbx = BoundingBox(box(O, 200, 200, :none))\nsetline(1)\nsethue(\"black\") # hide\nbox(bx, :stroke)\nfor i in 1:10\n    pt = randompoint((1.5bx)...)\n    pt2 = pointcrossesboundingbox(pt, bx)\n\n    sethue(\"grey50\")\n    arrow(O, pt)\n    sethue(\"red\")\n    circle(pt2, 3, :stroke)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: point crosses bounding box)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"boxaspectratio\nboxdiagonal\nboxwidth\nboxheight\nintersectboundingboxes\npointcrossesboundingbox\nboxbottomleft\nboxbottomright\nboxmiddlecenter\nboxmiddleleft\nboxmiddleright\nboxtopcenter\nboxtopleft\nboxtopright","category":"page"},{"location":"geometrytools/#Luxor.boxaspectratio","page":"Geometry tools","title":"Luxor.boxaspectratio","text":"boxaspectratio(bb::BoundingBox)\n\nReturn the aspect ratio (the height divided by the width) of bounding box bb.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.boxdiagonal","page":"Geometry tools","title":"Luxor.boxdiagonal","text":"boxdiagonal(bb::BoundingBox)\n\nReturn the length of the diagonal of bounding box bb.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.boxwidth","page":"Geometry tools","title":"Luxor.boxwidth","text":"boxwidth(bb::BoundingBox)\n\nReturn the width of bounding box bb.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.boxheight","page":"Geometry tools","title":"Luxor.boxheight","text":"boxheight(bb::BoundingBox)\n\nReturn the height of bounding box bb.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.intersectboundingboxes","page":"Geometry tools","title":"Luxor.intersectboundingboxes","text":"intersectboundingboxes(bb1::BoundingBox, bb2::BoundingBox)\n\nReturn a BoundingBox that's an intersection of the two bounding boxes.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.pointcrossesboundingbox","page":"Geometry tools","title":"Luxor.pointcrossesboundingbox","text":"pointcrossesboundingbox(pt, bbox::BoundingBox)\n\nFind and return the point where a line from the center of bounding box bbox to point pt would, if continued, cross the edges of the box.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.boxbottomleft","page":"Geometry tools","title":"Luxor.boxbottomleft","text":"boxbottomleft(bb::BoundingBox)\n\nReturn the point at the bottom left of the BoundingBox bb.\n\n‚ãÖ ‚ãÖ ‚ãÖ\n‚ãÖ ‚ãÖ ‚ãÖ\n‚ñ† ‚ãÖ ‚ãÖ\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.boxbottomright","page":"Geometry tools","title":"Luxor.boxbottomright","text":"boxbottomright(bb::BoundingBox)\n\nReturn the point at the bottom right of the BoundingBox bb.\n\n‚ãÖ ‚ãÖ ‚ãÖ\n‚ãÖ ‚ãÖ ‚ãÖ\n‚ãÖ ‚ãÖ ‚ñ†\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.boxmiddlecenter","page":"Geometry tools","title":"Luxor.boxmiddlecenter","text":"boxmiddlecenter(bb::BoundingBox)\n\nReturn the point at the center of the BoundingBox bb.\n\n‚ãÖ ‚ãÖ ‚ãÖ\n‚ãÖ ‚ñ† ‚ãÖ\n‚ãÖ ‚ãÖ ‚ãÖ\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.boxmiddleleft","page":"Geometry tools","title":"Luxor.boxmiddleleft","text":"boxmiddleleft(bb::BoundingBox)\n\nReturn the point at the middle left of the BoundingBox bb.\n\n‚ãÖ ‚ãÖ ‚ãÖ\n‚ñ† ‚ãÖ ‚ãÖ\n‚ãÖ ‚ãÖ ‚ãÖ\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.boxmiddleright","page":"Geometry tools","title":"Luxor.boxmiddleright","text":"boxmiddleright(bb::BoundingBox)\n\nReturn the point at the midde right of the BoundingBox bb.\n\n‚ãÖ ‚ãÖ ‚ãÖ\n‚ãÖ ‚ãÖ ‚ñ†\n‚ãÖ ‚ãÖ ‚ãÖ\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.boxtopcenter","page":"Geometry tools","title":"Luxor.boxtopcenter","text":"boxtopcenter(bb::BoundingBox)\n\nReturn the point at the top center of the BoundingBox bb.\n\n‚ãÖ ‚ñ† ‚ãÖ\n‚ãÖ ‚ãÖ ‚ãÖ\n‚ãÖ ‚ãÖ ‚ãÖ\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.boxtopleft","page":"Geometry tools","title":"Luxor.boxtopleft","text":"boxtopleft(bb::BoundingBox)\n\nReturn the point at the top left of the BoundingBox bb.\n\n‚ñ† ‚ãÖ ‚ãÖ\n‚ãÖ ‚ãÖ ‚ãÖ\n‚ãÖ ‚ãÖ ‚ãÖ\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.boxtopright","page":"Geometry tools","title":"Luxor.boxtopright","text":"boxtopright(bb::BoundingBox)\n\nReturn the point at the top right of the BoundingBox bb.\n\n‚ãÖ ‚ãÖ ‚ñ†\n‚ãÖ ‚ãÖ ‚ãÖ\n‚ãÖ ‚ãÖ ‚ãÖ\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Noise","page":"Geometry tools","title":"Noise","text":"","category":"section"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"For artistic graphics you might prefer noisy input values to purely random ones. Use the noise() function to obtain smoothly changing random values corresponding to input coordinates. The returned values wander slowly rather than jump about everywhere.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"In this example, the gray value varies gradually as the noise() function returns values between 0 and 1 depending on the location of the two input values pos.x and pos.y.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"The top two quadrants use a lower value for the detail keyword argument, an integer ()>= 1) specifying how many \"octaves\" of noise you want.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"The left two quadrants use a lower value for the persistence keyword argument, a floating point number specifying how the amplitude diminishes for each successive level of detail. There is more fine detail when the persistence is higher, particularly when the detail setting is also high.","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"using Luxor, Colors # hide\nDrawing(800, 400, \"assets/figures/noise.png\") # hide\n\nbackground(\"white\") # hide\norigin() # hide\n\ntiles = Tiler(800, 400, 200, 200)\nsethue(\"black\")\nfor (pos, n) in tiles\n    freq = 0.05\n    pos.y < 0 ? d = 1      : d = 4\n    pos.x < 0 ? pers = 0.3 : pers = 1.0\n    ns = noise(freq * pos.x, freq * pos.y,\n        detail=d,\n        persistence=pers)\n    setgray(ns)\n    box(pos, tiles.tilewidth, tiles.tileheight, :fillstroke)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"(Image: noise)","category":"page"},{"location":"geometrytools/","page":"Geometry tools","title":"Geometry tools","text":"noise\ninitnoise","category":"page"},{"location":"geometrytools/#Luxor.noise","page":"Geometry tools","title":"Luxor.noise","text":"noise(x)          ; detail = 1, persistence = 1.0) # 1D\nnoise(x, y)       ; detail = 1, persistence = 1.0) # 2D\nnoise(x, y, z)    ; detail = 1, persistence = 1.0) # 3D\nnoise(x, y, z, w) ; detail = 1, persistence = 1.0) # 4D\n\nGenerate a noise value between 0.0 and 1.0 corresponding to the x, y, z, and w values. An x value on its own produces 1D noise, x and y make 2D noise, and so on.\n\nThe detail value is an integer (>= 1) specifying how many octaves of noise you want.\n\nThe persistence value, typically between 0.0 and 1.0, controls how quickly the amplitude diminishes for each successive octave for values of detail greater than 1.\n\n\n\n\n\n","category":"function"},{"location":"geometrytools/#Luxor.initnoise","page":"Geometry tools","title":"Luxor.initnoise","text":"initnoise(seed::Int)\ninitnoise()\n\nInitialize the noise generation code.\n\njulia> initnoise(); noise(1)\n0.7453148982810598\n\njulia> initnoise(); noise(1)\n0.7027617067916981\n\nIf you provide an integer seed, it will be used to seed Random.seed!()` when the noise code is initialized:\n\njulia> initnoise(41); noise(1) # yesterday\n0.7134000046640385\n\njulia> initnoise(41); noise(1) # today\n0.7134000046640385\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Polygons-and-paths","page":"Polygons and paths","title":"Polygons and paths","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"For drawing shapes, Luxor provides polygons and paths.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"A polygon is an ordered collection of Points stored in an array.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"A path is a sequence of one or more straight and curved (circular arc or B√©zier curve) segments. Paths can consist of subpaths. Luxor maintains a 'current path', to which you can add lines and curves until you finish with a stroke or fill instruction.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"Luxor also provides a BezierPath type, which is an array of four-point tuples, each of which is a B√©zier cubic curve section.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"create convert draw info edit\npolygons    \nngon() polysmooth() poly() isinside() simplify()\nngonside()  prettypoly() polyperimeter() polysplit()\nstar()  polysmooth() polyarea() polyportion()\npolycross()   polycentroid() polyremainder()\noffsetpoly()   boundingbox() polysortbyangle()\nhyptrochoid()   ispolyclockwise() polysortbydistance()\nepitrochoid()   ispolyconvex() polyintersections()\npolyrotate!()    polymove!()\npolyfit()    polyscale!()\n    \n    polyreflect!()\n    polysample()\n    polytriangulate()\n    insertvertices!()\npaths    \ngetpath() pathtopoly()   \ngetpathflat()    \nBezier paths    \nmakebezierpath() pathtobezierpaths() drawbezierpath()  \npathtobezierpaths() bezierpathtopoly() brush()  \nBezierPath()    \nBezierPathSegment()    \nbeziersegmentangles()    ","category":"page"},{"location":"polygons/#Regular-polygons-(\"ngons\")","page":"Polygons and paths","title":"Regular polygons (\"ngons\")","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"A polygon is an array of points. The points can be joined with straight lines.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"You can make regular polygons ‚Äî from triangles, pentagons, hexagons, septagons, heptagons, octagons, nonagons, decagons, and on-and-on-agons ‚Äî with ngon().","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Colors # hide\nDrawing(700, 600, \"assets/figures/n-gon.png\") # hide\n\norigin() # hide\nbackground(\"white\") # hide\ncols = distinguishable_colors(10)\nsetline(2)\nfontsize(12)\ntiles = Tiler(700, 600, 3, 3)\n\nfor (pos, n) in tiles\n    @layer begin\n        translate(pos)\n\n        p = ngon(Point(0, 0), 80, n, vertices=true)\n\n        sethue(cols[n])\n\n        poly(p, :fill, close=true)\n        sethue(\"black\")\n        poly(p, :stroke, close=true)\n\n        circle(Point(0, 0), 4, :fill)\n\n        label.([string(i) for i in 1:n], slope.(O, p), p, offset=5)\n    end\nend\n\nfinish() # hide\n\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The initial orientation of the polygon defaults to 0.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: n-gons)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"If you want to specify the side length rather than the circumradius, use ngonside().","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(500, 600, \"assets/figures/ngonside.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\nsetline(2) # hide\nfor i in 20:-1:3\n    sethue(i/20, 0.5, 0.7)\n    ngonside(Point(0, 0), 75, i, 0, :fill)\n    sethue(\"black\")\n    ngonside(Point(0, 0), 75, i, 0, :stroke)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: stars)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The functions return the vertices, or you can use the vertices=true option.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"ngon(Point(0, 0), 10, 5)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":" Point(3.0901699437494745, 9.510565162951535)\n Point(-8.090169943749473, 5.877852522924733)\n Point(-8.090169943749475, -5.87785252292473)\n Point(3.0901699437494723, -9.510565162951536)\n Point(10.0, -2.4492935982947065e-15)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"ngon\nngonside","category":"page"},{"location":"polygons/#Luxor.ngon","page":"Polygons and paths","title":"Luxor.ngon","text":"ngon(x, y, radius, sides=5, orientation=0, action=:none;\n    vertices=false, reversepath=false)\n\nDraw a regular polygon centered at point centerpos.\n\n\n\n\n\nngon(centerpos, radius, sides=5, orientation=0, action=:none;\n    vertices=false,\n    reversepath=false)\n\nDraw a regular polygon centered at point centerpos.\n\nFind the vertices of a regular n-sided polygon centered at x, y with circumradius radius.\n\nThe polygon is constructed counterclockwise, starting with the first vertex drawn below the positive x-axis.\n\nIf you just want the raw points, use keyword argument vertices=true, which returns the array of points. Compare:\n\nngon(0, 0, 4, 4, 0, vertices=true) # returns the polygon's points:\n\n    4-element Array{Luxor.Point, 1}:\n    Luxor.Point(2.4492935982947064e-16, 4.0)\n    Luxor.Point(-4.0, 4.898587196589413e-16)\n    Luxor.Point(-7.347880794884119e-16, -4.0)\n    Luxor.Point(4.0, -9.797174393178826e-16)\n\nwhereas\n\nngon(0, 0, 4, 4, 0, :close) #¬†draws a polygon\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.ngonside","page":"Polygons and paths","title":"Luxor.ngonside","text":"ngonside(centerpoint::Point, sidelength::Real, sides::Int=5, orientation=0,\n    action=:none; kwargs...)\n\nDraw a regular polygon centered at centerpoint with sides sides of length sidelength.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Polygons","page":"Polygons and paths","title":"Polygons","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"Use poly() to draw lines connecting the points and/or just fill the area:","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(600, 250, \"assets/figures/simplepoly.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\norigin() # hide\nsethue(\"orchid4\") # hide\ntiles = Tiler(600, 250, 1, 2, margin=20)\ntile1, tile2 = collect(tiles)\n\nrandompoints = [Point(rand(-100:100), rand(-100:100)) for i in 1:10]\n\ngsave()\ntranslate(tile1[1])\npoly(randompoints, :stroke)\ngrestore()\n\ngsave()\ntranslate(tile2[1])\npoly(randompoints, :fill)\ngrestore()\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: simple poly)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"poly","category":"page"},{"location":"polygons/#Luxor.poly","page":"Polygons and paths","title":"Luxor.poly","text":"poly(bbox::BoundingBox, :action; kwargs...)\n\nMake a polygon around the BoundingBox in bbox.\n\n\n\n\n\nDraw a polygon.\n\npoly(pointlist::Array{Point, 1}, action = :none;\n    close=false,\n    reversepath=false)\n\nA polygon is an Array of Points. By default poly() doesn't close or fill the polygon, to allow for clipping.\n\n\n\n\n\n","category":"function"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"A polygon can contain holes. The reversepath keyword changes the direction of the polygon. The following piece of code uses ngon() to make and draw two paths, the second forming a hole in the first, to make a hexagonal bolt shape:","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(400, 250, \"assets/figures/holes.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsetline(5)\nsethue(\"gold\")\nline(Point(-200, 0), Point(200, 0), :stroke)\nsethue(\"orchid4\")\nngon(0, 0, 60, 6, 0, :path)\nnewsubpath()\nngon(0, 0, 40, 6, 0, :path, reversepath=true)\nfillstroke()\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: holes)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The prettypoly() function can place graphics at each vertex of a polygon. After the polygon action, the supplied vertexfunction function is evaluated at each vertex. For example, to mark each vertex of a polygon with a randomly-colored circle:","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(400, 250, \"assets/figures/prettypolybasic.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"steelblue4\") # hide\n\napoly = star(O, 70, 7, 0.6, 0, vertices=true)\nprettypoly(apoly, :fill, () ->\n        begin\n            randomhue()\n            circle(O, 10, :fill)\n        end,\n    close=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: prettypoly)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"An optional keyword argument vertexlabels lets you pass a function that can number each vertex. The function can use two arguments, the current vertex number, and the total number of points in the polygon:","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(400, 250, \"assets/figures/prettypolyvertex.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"steelblue4\") # hide\n\napoly = star(O, 80, 5, 0.6, 0, vertices=true)\nprettypoly(apoly,\n    :stroke,\n    vertexlabels = (n, l) -> (text(string(n, \" of \", l), halign=:center)),\n    close=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: prettypoly)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"prettypoly","category":"page"},{"location":"polygons/#Luxor.prettypoly","page":"Polygons and paths","title":"Luxor.prettypoly","text":"prettypoly(bbox::BoundingBox, :action; kwargs...)\n\nMake a decorated polygon around the BoundingBox in bbox. The vertices are in the order: bottom left, top left, top right, and bottom right.\n\n\n\n\n\nprettypoly(points::Array{Point, 1}, action=:none, vertexfunction = () -> circle(O, 2, :stroke);\n    close=false,\n    reversepath=false,\n    vertexlabels = (n, l) -> ()\n    )\n\nDraw the polygon defined by points, possibly closing and reversing it, using the current parameters, and then evaluate the vertexfunction function at every vertex of the polygon.\n\nThe default vertexfunction draws a 2 pt radius circle.\n\nTo mark each vertex of a polygon with a randomly colored filled circle:\n\np = star(O, 70, 7, 0.6, 0, vertices=true)\nprettypoly(p, :fill, () ->\n    begin\n        randomhue()\n        circle(O, 10, :fill)\n    end,\n    close=true)\n\nThe optional keyword argument vertexlabels lets you supply a function with two arguments that can access the current vertex number and the total number of vertices at each vertex. For example, you can label the vertices of a triangle \"1 of 3\", \"2 of 3\", and \"3 of 3\" using:\n\nprettypoly(triangle, :stroke,\n    vertexlabels = (n, l) -> (text(string(n, \" of \", l))))\n\n\n\n\n\n","category":"function"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"Recursive decoration is possible:","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(400, 260, \"assets/figures/prettypolyrecursive.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\norigin() # hide\nsethue(\"magenta\") # hide\nsetopacity(0.5) # hide\n\ndecorate(pos, p, level) = begin\n    if level < 4\n        randomhue()\n        scale(0.25, 0.25)\n        prettypoly(p, :fill, () -> decorate(pos, p, level+1), close=true)\n    end\nend\n\napoly = star(O, 100, 7, 0.6, 0, vertices=true)\nprettypoly(apoly, :fill, () -> decorate(O, apoly, 1), close=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: prettypoly)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"Polygons can be simplified using the Douglas-Peucker algorithm (non-recursive version), via simplify().","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(600, 500, \"assets/figures/simplify.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsethue(\"black\") # hide\nsetline(1) # hide\nfontsize(20) # hide\ntranslate(0, -120) # hide\nsincurve = [Point(6x, 80sin(x)) for x in -5œÄ:œÄ/20:5œÄ]\nprettypoly(collect(sincurve), :stroke,\n    () -> begin\n            sethue(\"red\")\n            circle(O, 3, :fill)\n          end)\ntext(string(\"number of points: \", length(collect(sincurve))), 0, 100)\ntranslate(0, 200)\nsimplercurve = simplify(collect(sincurve), 0.5)\nprettypoly(simplercurve, :stroke,\n    () -> begin\n            sethue(\"red\")\n            circle(O, 3, :fill)\n          end)\ntext(string(\"number of points: \", length(simplercurve)), 0, 100)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: simplify)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"simplify","category":"page"},{"location":"polygons/#Luxor.simplify","page":"Polygons and paths","title":"Luxor.simplify","text":"Simplify a polygon:\n\nsimplify(pointlist::Array, detail=0.1)\n\ndetail is the maximum approximation error of simplified polygon.\n\n\n\n\n\n","category":"function"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The isinside() function returns true if a point is inside a polygon.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(500, 500, \"assets/figures/isinside.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\napolygon = star(O, 200, 8, 0.5, 0, vertices=true)\nfor pt in collect(first.(Table(30, 30, 15, 15)))\n    sethue(noise(pt.x/600, pt.y/600), noise(pt.x/300, pt.y/300), noise(pt.x/250, pt.y/250))\n    isinside(pt, apolygon, allowonedge=true) ? circle(pt, 8, :fill) : circle(pt, 3, :fill)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: isinside)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"isinside","category":"page"},{"location":"polygons/#Luxor.isinside","page":"Polygons and paths","title":"Luxor.isinside","text":"isinside(p::Point, bb:BoundingBox)\n\nReturns true if pt is inside bounding box bb.\n\n\n\n\n\nisinside(p, pol; allowonedge=false)\n\nIs a point p inside a polygon pol? Returns true if it does, or false.\n\nThis is an implementation of the Hormann-Agathos (2001) Point in Polygon algorithm.\n\nThe classification of points lying on the edges of the target polygon, or coincident with its vertices is not clearly defined, due to rounding errors or arithmetical inadequacy. By default these will generate errors, but you can suppress these by setting allowonedge to true.\n\n\n\n\n\n","category":"function"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"You can use randompoint() and randompointarray() to create a random Point or list of Points.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(400, 250, \"assets/figures/randompoints.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\norigin() # hide\n\npt1 = Point(-100, -100)\npt2 = Point(100, 100)\n\nsethue(\"gray80\")\nmap(pt -> circle(pt, 6, :fill), (pt1, pt2))\nbox(pt1, pt2, :stroke)\n\nsethue(\"red\")\ncircle(randompoint(pt1, pt2), 7, :fill)\n\nsethue(\"blue\")\nmap(pt -> circle(pt, 2, :fill), randompointarray(pt1, pt2, 100))\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: isinside)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"randompoint\nrandompointarray","category":"page"},{"location":"polygons/#Luxor.randompoint","page":"Polygons and paths","title":"Luxor.randompoint","text":"randompoint(lowpt, highpt)\n\nReturn a random point somewhere inside the rectangle defined by the two points.\n\n\n\n\n\nrandompoint(lowx, lowy, highx, highy)\n\nReturn a random point somewhere inside a rectangle defined by the four values.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.randompointarray","page":"Polygons and paths","title":"Luxor.randompointarray","text":"randompointarray(lowpt, highpt, n)\n\nReturn an array of n random points somewhere inside the rectangle defined by two points.\n\n\n\n\n\nrandompointarray(lowx, lowy, highx, highy, n)\n\nReturn an array of n random points somewhere inside the rectangle defined by the four coordinates.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Quickly-changing-polygons","page":"Polygons and paths","title":"Quickly changing polygons","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"If you want to quickly and permanently modify a polygon, there's polymove!(), polyscale!(), polyreflect!(), and polyrotate!().","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(400, 350, \"assets/figures/polychange.png\") # hide\norigin() # hide\n\nsethue(\"magenta\") # hide\nshape = star(O, 10, 5, 0.5, 0, vertices=true)\n\ncircle(O, 3, :stroke)\n\npolymove!(shape, O, O + (0, 50))\n\npoly(shape, :stroke, close=true)\n\nfor i in 1:20\n    poly(polyrotate!(shape, œÄ/5), :fill, close=true)\n    polyscale!(shape, 19//18)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The polygon is continually modified (notice the ! in the function names).","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: poly changing)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(400, 350, \"assets/figures/polyreflect.png\") # hide\norigin() # hide\nRandom.seed!(34) # hide\nsetopacity(0.7) # hide\nsethue(\"grey60\") # hide\npgon = randompointarray(BoundingBox()/2 ..., 10)\npolymove!(pgon, O, Point(-80, 0))\npoly(pgon, :fill, close=true)\n# reflect in y axis:\npolyreflect!(pgon, Point(0, 0), Point(0, 100))\nsethue(\"blue\")\npoly(pgon, :fill, close=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: poly reflect)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"polyscale!\npolymove!\npolyreflect!\npolyrotate!","category":"page"},{"location":"polygons/#Luxor.polyscale!","page":"Polygons and paths","title":"Luxor.polyscale!","text":"polyscale!(pgon, s;\n   center=O)\n\nScale (permanently) a polygon by s, relative to center.\n\n\n\n\n\npolyscale!(pgon, sh, sv;\n    center=O)\n\nScale (permanently) a polygon by sh horizontally and sv vertically, relative to center.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.polymove!","page":"Polygons and paths","title":"Luxor.polymove!","text":"polymove!(pgon, frompoint::Point, topoint::Point)\n\nMove (permanently) a polygon from frompoint to topoints.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.polyreflect!","page":"Polygons and paths","title":"Luxor.polyreflect!","text":"polyreflect!(pgon, pt1 = O, pt2 = O + (0, 100)\n\nReflect (permanently) a polygon in a line (default to the y-axis) joining two points.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.polyrotate!","page":"Polygons and paths","title":"Luxor.polyrotate!","text":"polyrotate!(pgon, Œ∏;\n    center=O)\n\nRotate (permanently) a polygon around center by Œ∏ radians.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Other-functions","page":"Polygons and paths","title":"Other functions","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"There are a number of experimental polygon functions. These won't work well for polygons that aren't simple or where the sides intersect each other, but they sometimes do a reasonable job. For example, here's polysplit():","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(400, 150, \"assets/figures/polysplit.png\") # hide\norigin() # hide\nsetopacity(0.7) # hide\nRandom.seed!(42) # hide\nsethue(\"black\") # hide\ns = squircle(O, 60, 60, vertices=true)\npt1 = Point(0, -120)\npt2 = Point(0, 120)\nline(pt1, pt2, :stroke)\npoly1, poly2 = polysplit(s, pt1, pt2)\nrandomhue()\npoly(poly1, :fill)\nrandomhue()\npoly(poly2, :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: polysplit)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"polysplit\npolysortbydistance\npolysortbyangle\npolycentroid","category":"page"},{"location":"polygons/#Luxor.polysplit","page":"Polygons and paths","title":"Luxor.polysplit","text":"polysplit(p, p1, p2)\n\nSplit a polygon into two where it intersects with a line. It returns two polygons:\n\n(poly1, poly2)\n\nThis doesn't always work, of course. For example, a polygon the shape of the letter \"E\" might end up being divided into more than two parts.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.polysortbydistance","page":"Polygons and paths","title":"Luxor.polysortbydistance","text":"Sort a polygon by finding the nearest point to the starting point, then the nearest point to that, and so on.\n\npolysortbydistance(p, starting::Point)\n\nYou can end up with convex (self-intersecting) polygons, unfortunately.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.polysortbyangle","page":"Polygons and paths","title":"Luxor.polysortbyangle","text":"Sort the points of a polygon into order. Points are sorted according to the angle they make with a specified point.\n\npolysortbyangle(pointlist::Array, refpoint=minimum(pointlist))\n\nThe refpoint can be chosen, but the minimum point is usually OK too:\n\npolysortbyangle(parray, polycentroid(parray))\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.polycentroid","page":"Polygons and paths","title":"Luxor.polycentroid","text":"Find the centroid of simple polygon.\n\npolycentroid(pointlist)\n\nReturns a point. This only works for simple (non-intersecting) polygons.\n\nYou could test the point using isinside().\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Smoothing-polygons","page":"Polygons and paths","title":"Smoothing polygons","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"Because polygons can have sharp corners, the experimental polysmooth() function attempts to insert arcs at the corners and draw the result.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The original polygon is shown in red; the smoothed polygon is shown on top:","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(600, 250, \"assets/figures/polysmooth.svg\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetopacity(0.5) # hide\nRandom.seed!(42) # hide\nsetline(0.7) # hide\ntiles = Tiler(600, 250, 1, 5, margin=10)\nfor (pos, n) in tiles\n    p = star(pos, tiles.tilewidth/2 - 2, 5, 0.3, 0, vertices=true)\n    sethue(\"red\")\n    poly(p, close=true, :stroke)\n    sethue(\"black\")\n    polysmooth(p, n * 2, :fill)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: polysmooth)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The final polygon shows that you can get unexpected results if you attempt to smooth corners by more than the possible amount. The debug=true option draws the circles if you want to find out what's going wrong, or if you want to explore the effect in more detail.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(600, 250, \"assets/figures/polysmooth-pathological.svg\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetopacity(0.75) # hide\nRandom.seed!(42) # hide\nsetline(1) # hide\np = star(O, 60, 5, 0.35, 0, vertices=true)\nsetdash(\"dot\")\nsethue(\"red\")\nprettypoly(p, close=true, :stroke)\nsetdash(\"solid\")\nsethue(\"black\")\npolysmooth(p, 40, :fill, debug=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: polysmooth)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"polysmooth","category":"page"},{"location":"polygons/#Luxor.polysmooth","page":"Polygons and paths","title":"Luxor.polysmooth","text":"polysmooth(points, radius, action=:action; debug=false)\n\nMake a closed path from the points and round the corners by making them arcs with the given radius. Execute the action when finished.\n\nThe arcs are sometimes different sizes: if the given radius is bigger than the length of the shortest side, the arc can't be drawn at its full radius and is therefore drawn as large as possible (as large as the shortest side allows).\n\nThe debug option also draws the construction circles at each corner.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Offsetting-polygons","page":"Polygons and paths","title":"Offsetting polygons","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"There are three methods for offsetpoly(), a function which constructs a new polygon that's offset from an existing one.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"offsetpoly(plist, d) treats the plist of points as a polygon  with n vertices joined by n lines with offset d on both  sides.\noffsetpoly(plist, startoffset=d1, endoffset=d2) treats the plist of points as a polyline with n vertices joined by n-1 lines, where the offset varies from startoffset to endoffset.\noffsetpoly(plist, f::function) applies a function f at each vertex of the polyline to determine the width of the offset polygon at that point.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The first method is good for making closed shapes larger or smaller. The other methods are useful for building shapes around an open linear spine.","category":"page"},{"location":"polygons/#:-n-vertices-joined-by-n-lines","page":"Polygons and paths","title":"1: n vertices joined by n lines","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The offsetpoly(plist, d) method constructs a closed polygon outside or inside an existing polygon, at distance d.  The last vertex in plist as assumed to be be connected to the first.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"In the following example, the dotted red polygon is the original, the black polygons have positive offsets and surround the original, the cyan polygons have negative offsets and run inside the original. Use poly() to draw the result.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(600, 250, \"assets/figures/polyoffset-simple.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\nsetline(1.5) # hide\n\np = star(O, 45, 5, 0.5, 0, vertices=true)\nsethue(\"red\")\nsetdash(\"dot\")\npoly(p, :stroke, close=true)\nsetdash(\"solid\")\nsethue(\"black\")\n\npoly(offsetpoly(p, 20), :stroke, close=true)\npoly(offsetpoly(p, 25), :stroke, close=true)\npoly(offsetpoly(p, 30), :stroke, close=true)\npoly(offsetpoly(p, 35), :stroke, close=true)\n\nsethue(\"darkcyan\")\n\npoly(offsetpoly(p, -10), :stroke, close=true)\npoly(offsetpoly(p, -15), :stroke, close=true)\npoly(offsetpoly(p, -20), :stroke, close=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: offset poly 2)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The function is intended for simple cases, and it can go wrong if pushed too far. Sometimes the offset distances can be larger than the polygon segments, and things will start to go wrong. In this example, the offset goes so far negative that the polygon overshoots the origin, becomes inverted and starts getting larger again.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: offset poly problem)","category":"page"},{"location":"polygons/#n-vertices-joined-by-n-1-lines","page":"Polygons and paths","title":"2 n vertices joined by n-1 lines","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The offsetpoly(plist) method constructs a polygon around a line joining the lines in plist. At the start of the line, the polygon will be startoffset units on each side; by the end of the line, the polygon will be endoffset units on each side. The last vertex isn't joined to the first, hence n-1.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"In the following example, the original spine is drawn in orange, on top of the black polygon that's constructed to be offset 2 units on each side at the start and 30 units on each side at the end.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(800, 500, \"assets/figures/polyoffset-open.png\") # hide\norigin() # hide\nbackground(\"purple\") # hide\nsetline(2) # hide\n\nspine = [Point(20 + 40x, 15sin(2x)) for x in 0:.1:4œÄ]\n\nfor Œ∏ in range(0, 2œÄ, step=œÄ/12)\n    @layer begin\n        sethue(\"black\")\n        rotate(Œ∏)\n        poly(offsetpoly(spine, startoffset=1, endoffset=30), :fill)\n        sethue(\"orange\")\n        poly(spine, :stroke)\n    end\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: offset poly open)","category":"page"},{"location":"polygons/#Using-an-offset-control-function","page":"Polygons and paths","title":"Using an offset-control function","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"This method accepts a keyword argument that allows you to control the way the offsets are applied, using the easing functionality built in to Luxor (see Animation helper functions).","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"By default the function is lineartween(), so the offset changes linearly between the startoffset and the endoffset values. With other easing functions, this change is modulated. For example, the easeinoutquad function moves between start and end values using a quadratic motion.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(800, 500, \"assets/figures/polyoffset-easing.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(2) # hide\nsetlinejoin(\"round\") # hide\n\nspine = between.(O - (200, 0), O + (200, 0), 0:0.025:1)\n\nsethue(\"red\")\nprettypoly(spine, :stroke)\n\nsethue(\"black\")\npg = offsetpoly(spine, startoffset=0, endoffset=200, easingfunction=easeinoutquad)\nprettypoly(pg, :stroke, close=true)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: offset poly easing)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"But in the next example, the function f(t, b, c, d) (the Luxor standard four-argument easing function) is defined to run from 0 to 2 and back again as t goes from  0 to 1, so the initial and final offsets are 'eased' to 0, and at the middle of the polygon the offsets at that location are 'eased' to 2 √ó the offset value at that point.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(800, 200, \"assets/figures/polyoffset-easing1.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(2) # hide\nsetlinejoin(\"round\") # hide\n\nspine = [Point(20x, 15sin(x)) for x in -4œÄ:pi/24:4pi]\n\nf(t, b, c, d) = 2sin(t * œÄ)\n\npg = offsetpoly(spine, startoffset=1, endoffset=10, easingfunction=f)\nsethue(\"black\")\npoly(pg, :fill)\n\nsethue(\"white\")\npoly(spine, :stroke)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: offset poly easing 1)","category":"page"},{"location":"polygons/#:-Applying-a-function","page":"Polygons and paths","title":"3: Applying a function","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"This method generates offset widths using the supplied function. The value of the supplied function f at f(0, Œ∏) determines the start offset on each side, and f(1, Œ∏) determines the finishing offset on each side. The width at the middle vertex will be f(0.5, Œ∏) (on each side). Œ∏ is provided as the current slope of the polyline at that point.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(800, 250, \"assets/figures/polyoffset-function.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(2) # hide\nsetlinejoin(\"round\") # hide\n\n\nspiralcurve = spiral(10, 0.3, log=true, period=3œÄ)\nf(x, Œ∏) = 1 + 15sin(x * œÄ)\npgon = offsetpoly(spiralcurve, f)\npoly(pgon, :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: offset poly fucntion)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"offsetpoly","category":"page"},{"location":"polygons/#Luxor.offsetpoly","page":"Polygons and paths","title":"Luxor.offsetpoly","text":"offsetpoly(plist::Array{Point, 1}, d) where T<:Number\n\nReturn a polygon that is offset from a polygon by d units.\n\nThe incoming set of points plist is treated as a polygon, and another set of points is created, which form a polygon lying d units away from the source poly.\n\nPolygon offsetting is a topic on which people have written PhD theses and published academic papers, so this short brain-dead routine will give good results for simple polygons up to a point (!). There are a number of issues to be aware of:\n\nvery short lines tend to make the algorithm 'flip' and produce larger lines\nsmall polygons that are counterclockwise and larger offsets may make the new\n\npolygon appear the wrong side of the original\n\nvery sharp vertices will produce even sharper offsets, as the calculated intersection point veers off to infinity\nduplicated adjacent points might cause the routine to scratch its head and wonder how to draw a line parallel to them\n\n\n\n\n\noffsetpoly(plist;\n    startoffset = 10,\n    endoffset   = 10,\n    easingfunction = lineartween)\n\nReturn a closed polygon that is offset from and encloses an open polygon.\n\nThe incoming set of points plist is treated as an open polygon, and another set of points is created, which form a polygon lying ...offset units away from the source poly.\n\nThis method for offsetpoly() treats the list of points as n vertices connected with n - 1 lines. It allows you to vary the offset from the start of the line to the end.\n\nThe other method offsetpoly(plist, d) treats the list of points as n vertices connected with n lines.\n\nExtended help\n\nThis function accepts a keyword argument that allows you to control the offset using a function, using the easing functionality built in to Luxor. By default the function is lineartween(), so the offset changes linearly between the startoffset and the endoffset. The function:\n\nf(a, b, c, d) = 2sin((a * œÄ))\n\nruns from 0 to 2 and back as a runs from 0 to 1. The offsets are scaled by this amount.\n\n\n\n\n\noffsetpoly(plist, shape::Function)\n\nReturn a closed polygon that is offset from and encloses an polyline.\n\nThe incoming set of points plist is treated as an polyline, and another set of points is created, which form a closed polygon offset from the source poly.\n\nThis method for offsetpoly() treats the list of points as n vertices connected with n - 1 lines. (The other method offsetpoly(plist, d) treats the list of points as n vertices connected with n lines.)\n\nThe supplied function determines the width of the line. f(0, Œ∏) gives the width at the start (the slope of the curve at that point is supplied in Œ∏), f(1, Œ∏) provides the width at the end, and f(n, Œ∏) is the width of point n/l.\n\nExamples\n\nThis example draws a tilde, with the ends starting at 20 (10 + 10) units wide, swelling to 50 (10 + 10 + 15 + 15) in the middle, as f(0.5) = 25.\n\nf(x, Œ∏) =  10 + 15sin(x * œÄ)\nsinecurve = [Point(50x, 50sin(x)) for x in -œÄ:œÄ/24:œÄ]\npgon = offsetpoly(sinecurve, f)\npoly(pgon, :fill)\n\nThis example enhances the vertical part of the curve, and thins the horizontal parts.\n\ng(x, Œ∏) = rescale(abs(sin(Œ∏)), 0, 1, 0.1, 30)\nsinecurve = [Point(50x, 50sin(x)) for x in -œÄ:œÄ/24:œÄ]\npgon = offsetpoly(sinecurve, g)\npoly(pgon, :fill)\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Fitting-splines","page":"Polygons and paths","title":"Fitting splines","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The experimental polyfit() function constructs a B-spline that follows the points approximately.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(600, 250, \"assets/figures/polyfit.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\n\npts = [Point(x, rand(-100:100)) for x in -280:30:280]\nsetopacity(0.7)\nsethue(\"red\")\nprettypoly(pts, :none, () -> circle(O, 5, :fill))\nsethue(\"darkmagenta\")\npoly(polyfit(pts, 200), :stroke)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: offset poly)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"polyfit","category":"page"},{"location":"polygons/#Luxor.polyfit","page":"Polygons and paths","title":"Luxor.polyfit","text":"polyfit(plist::Array, npoints=30)\n\nBuild a polygon that constructs a B-spine approximation to it. The resulting list of points makes a smooth path that runs between the first and last points.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Converting-paths-to-polygons","page":"Polygons and paths","title":"Converting paths to polygons","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"You can convert the current path to an array of polygons, using pathtopoly().","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"In the next example, the path consists of a number of paths, some of which are subpaths, which form the holes.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(800, 300, \"assets/figures/path-to-poly.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nfontsize(60) # hide\ntranslate(-300, -50) # hide\ntextpath(\"get polygons from paths\")\nplist = pathtopoly()\nsetline(0.5) # hide\nfor (n, pgon) in enumerate(plist)\n    randomhue()\n    prettypoly(pgon, :stroke, close=true)\n    gsave()\n    translate(0, 100)\n    poly(polysortbyangle(pgon, polycentroid(pgon)), :stroke, close=true)\n    grestore()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: path to polygon)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The pathtopoly() function calls getpathflat() to convert the current path to an array of polygons, with each curved section flattened to line segments.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The getpath() function gets the current path as an array of elements, lines, and unflattened curves.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"pathtopoly\ngetpath\ngetpathflat","category":"page"},{"location":"polygons/#Luxor.pathtopoly","page":"Polygons and paths","title":"Luxor.pathtopoly","text":"pathtopoly()\n\nConvert the current path to an array of polygons.\n\nReturns an array of polygons, corresponding to the paths and subpaths of the original path.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.getpath","page":"Polygons and paths","title":"Luxor.getpath","text":"getpath()\n\nGet the current path and return a CairoPath object, which is an array of element_type and points objects. With the results you can step through and examine each entry:\n\no = getpath()\nfor e in o\n      if e.element_type == Cairo.CAIRO_PATH_MOVE_TO\n          (x, y) = e.points\n          move(x, y)\n      elseif e.element_type == Cairo.CAIRO_PATH_LINE_TO\n          (x, y) = e.points\n          # straight lines\n          line(x, y)\n          strokepath()\n          circle(x, y, 1, :stroke)\n      elseif e.element_type == Cairo.CAIRO_PATH_CURVE_TO\n          (x1, y1, x2, y2, x3, y3) = e.points\n          # Bezier control lines\n          circle(x1, y1, 1, :stroke)\n          circle(x2, y2, 1, :stroke)\n          circle(x3, y3, 1, :stroke)\n          move(x, y)\n          curve(x1, y1, x2, y2, x3, y3)\n          strokepath()\n          (x, y) = (x3, y3) #¬†update current point\n      elseif e.element_type == Cairo.CAIRO_PATH_CLOSE_PATH\n          closepath()\n      else\n          error(\"unknown CairoPathEntry \" * repr(e.element_type))\n          error(\"unknown CairoPathEntry \" * repr(e.points))\n      end\n  end\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.getpathflat","page":"Polygons and paths","title":"Luxor.getpathflat","text":"getpathflat()\n\nGet the current path, like getpath() but flattened so that there are no B√®zier curves.\n\nReturns a CairoPath which is an array of element_type and points objects.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Polygons-to-B√©zier-paths-and-back-again","page":"Polygons and paths","title":"Polygons to B√©zier paths and back again","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"Use the makebezierpath() and drawbezierpath() functions to make and draw B√©zier paths, and pathtobezierpaths() to convert the current path to an array of B√©zier paths.  ","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"A BezierPath type contains a sequence of BezierPathSegments; each curve segment is defined by four points: two end points and their control points.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"    (Point(-129.904, 75.0),        # start point\n     Point(-162.38, 18.75),        # ^ control point\n     Point(-64.9519, -150.0),      # v control point\n     Point(-2.75546e-14, -150.0)), # end point\n    (Point(-2.75546e-14, -150.0),\n     Point(64.9519, -150.0),\n     Point(162.38, 18.75),\n     Point(129.904, 75.0)),\n    (Point(129.904, 75.0),\n     Point(97.4279, 131.25),\n     Point(-97.4279, 131.25),\n     Point(-129.904, 75.0)\n     ),\n     ...","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"B√©zier paths are different from ordinary paths in that they don't usually contain straight line segments. However, by setting the two control points to be the same as their matching start/end points, you create straight line sections.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"makebezierpath() takes the points in a polygon and converts each line segment into one B√©zier curve. drawbezierpath() draws the resulting sequence.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(600, 320, \"assets/figures/abezierpath.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsetline(1.5) # hide\nsetgray(0.5) # hide\npts = ngon(O, 150, 3, pi/6, vertices=true)\nbezpath = makebezierpath(pts)\npoly(pts, :stroke)\nfor (p1, c1, c2, p2) in bezpath[1:end-1]\n    circle.([p1, p2], 4, :stroke)\n    circle.([c1, c2], 2, :fill)\n    line(p1, c1, :stroke)\n    line(p2, c2, :stroke)\nend\nsethue(\"black\")\nsetline(3)\ndrawbezierpath(bezpath, :stroke, close=false)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: path to polygon)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(600, 320, \"assets/figures/bezierpaths.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nRandom.seed!(3) # hide\ntiles = Tiler(600, 300, 1, 4, margin=20)\nfor (pos, n) in tiles\n    @layer begin\n        translate(pos)\n        pts = polysortbyangle(\n                randompointarray(\n                    Point(-tiles.tilewidth/2, -tiles.tilewidth/2),\n                    Point(tiles.tilewidth/2, tiles.tilewidth/2),\n                    4))\n        setopacity(0.7)\n        sethue(\"black\")\n        prettypoly(pts, :stroke, close=true)\n        randomhue()\n        drawbezierpath(makebezierpath(pts), :fill)\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: path to polygon)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"You can convert a B√©zier path to a polygon (an array of points), using the bezierpathtopoly() function. This chops up the curves into a series of straight line segments. An optional steps keyword lets you specify how many line segments are used to approximate each B√©zier segment.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"In this example, the original star is drawn in a dotted gray line, then converted to a B√©zier path (drawn in orange), then the B√©zier path is converted (with low resolution) to a polygon but offset by 20 units before being drawn (in blue).","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(600, 600, \"assets/figures/bezierpathtopoly.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nRandom.seed!(3) # hide\n\npgon = star(O, 250, 5, 0.6, 0, vertices=true)\n\n@layer begin\n    setgrey(0.5)\n    setdash(\"dot\")\n    poly(pgon, :stroke, close=true)\n    setline(5)\nend\n\nsetline(4)\n\nsethue(\"orangered\")\n\nnp = makebezierpath(pgon)    \ndrawbezierpath(np, :stroke)\n\nsethue(\"steelblue\")\np = bezierpathtopoly(np, steps=3)    \n\nq1 = offsetpoly(p, 20)\nprettypoly(q1, :stroke, close=true)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: path to polygon)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"You can convert the current path to an array of BezierPaths using the pathtobezierpaths() function.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"In the next example, the letter \"a\" is placed at the current position (set by move()) and then converted to an array of B√©zier paths. Each B√©zier path is drawn first of all in gray, then the control points of segment are drawn (in orange) showing how they affect the curvature.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(600, 400, \"assets/figures/pathtobezierpaths.png\") # hide\nbackground(\"ivory\") # hide\norigin() # hide\nst = \"a\"\nthefontsize = 500\nfontsize(thefontsize)\nsethue(\"red\")\ntex = textextents(st)\nmove(-tex[3]/2, tex[4]/2)\ntextpath(st)\nnbps = pathtobezierpaths()\nsetline(1.5)\nfor nbp in nbps\n    sethue(\"grey80\")\n    drawbezierpath(nbp, :stroke)\n    for p in nbp\n        sethue(\"darkorange\")\n        circle(p[2], 2.0, :fill)\n        circle(p[3], 2.0, :fill)\n        line(p[2], p[1], :stroke)\n        line(p[3], p[4], :stroke)\n        if p[1] != p[4]\n            sethue(\"black\")\n            circle(p[1], 2.0, :fill)\n            circle(p[4], 2.0, :fill)\n        end\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: path to polygon)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"beziersegmentangles() lets you define a BeÃÅzier path segment by specifying the angles the control handles make with the base line.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(600, 400, \"assets/figures/beziersegmentangles.svg\") # hide\nbackground(\"ivory\") # hide\norigin() # hide\n\nsetline(.5)\n\n@layer begin\n    rule.(O, (0, (œÄ/2)))\nend\n\nP = O\nQ = O + (200, 0)\nsethue(\"black\")\n\npts = beziersegmentangles(P, Q,\n    out = deg2rad(60),\n    in  = 2œÄ - deg2rad(45))\n\n@layer begin\n    setline(2)\n    sethue(\"purple\")\n    drawbezierpath(pts, :stroke)\nend\n\nsethue(\"grey50\")\nline(O, pts[2], :stroke)\nline(Q, pts[3], :stroke)\nfontsize(15)\ncircle.((P, pts[2], pts[3], Q), 5, :fill)\nlabel.((\"P\", \"Q\"), :ne, (P, Q))\ntext(\"60¬∞\", P + (40, 20))\ntext(\"135¬∞\", Q + (10, 20))\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: bezier segment angles)","category":"page"},{"location":"polygons/#Brush-strokes","page":"Polygons and paths","title":"Brush strokes","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The brush() function builds Bezier paths in a quasi-random fashion, that could look like brush strokes. The optional keyword arguments allow a range of different effects.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"You can pass a function that can adjust various drawing settings before the shapes are drawn.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\n\nbrushŒ±(nbpb) = begin\n    setline(1)\n    setopacity(0.3)\n    drawbezierpath(nbpb, :stroke)\n    sethue(0.2, 0.3, rand(0.3:0.01:0.65))\n    return nbpb\nend\n\nfunction numberit(pos, n)\n    @layer begin\n        sethue(\"black\")\n        text(string(n), pos)\n    end    \nend\n\nDrawing(800, 700, \"assets/figures/brush1.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\nt  = Tiler(800, 700, 5, 1)\nsethue(\"orange3\")\nfontsize(20)\nfor (pos, n) in t\n    start, finish = pos - (200, 0), pos + (200, 0)\n    if n == 1\n        # five brush strokes\n        brush(start, finish, 1)\n        numberit(pos, n)\n    elseif n == 2\n        # minwidth and maxwidth control the, er, width\n         brush(start, finish, 5, minwidth = -5, maxwidth = 2)\n         numberit(pos, n)\n    elseif n == 3\n        # dont have to have transparent strokes\n         brush(start, finish, 20, minwidth = .2, randomopacity = false)\n         numberit(pos, n)\n    elseif n == 4\n        # twist and adjust handles to taste\n         brush(start, finish, minwidth = -.1, maxwidth = .2,\n             twist = 2, highhandle = 2, tidystart=false)\n         numberit(pos, n)    \n    elseif n == 5   \n        # call a function to modify each stroke\n        brush(start, finish, 1, minwidth = -2.2, maxwidth = .8,\n            lowhandle = -.4, highhandle = 1.5, twist = .5,  \n            strokefunction = brushŒ±)\n        numberit(pos, n)\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: brush 1)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"For more information (and more than you probably wanted to know) about Luxor's B√©zier paths, visit https://cormullion.github.io/pages/2018-06-20-bezier/.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"bezier\nbezier‚Ä≤\nbezier‚Ä≤‚Ä≤\nbeziercurvature\nbezierfrompoints\nbezierpathtopoly\nbezierstroke\nbeziertopoly\ndrawbezierpath\nmakebezierpath\npathtobezierpaths\nsetbezierhandles\nshiftbezierhandles\nLuxor.findbeziercontrolpoints\nbrush\nbeziersegmentangles","category":"page"},{"location":"polygons/#Luxor.bezier","page":"Polygons and paths","title":"Luxor.bezier","text":"bezier(t, A::Point, A1::Point, B1::Point, B::Point)\n\nReturn the result of evaluating the Bezier cubic curve function, t going from 0 to 1, starting at A, finishing at B, control points A1 (controlling A), and B1 (controlling B).\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.bezier‚Ä≤","page":"Polygons and paths","title":"Luxor.bezier‚Ä≤","text":"bezier‚Ä≤(t, A::Point, A1::Point, B1::Point, B::Point)\n\nReturn the first derivative of the Bezier function.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.bezier‚Ä≤‚Ä≤","page":"Polygons and paths","title":"Luxor.bezier‚Ä≤‚Ä≤","text":"bezier‚Ä≤‚Ä≤(t, A::Point, A1::Point, B1::Point, B::Point)\n\nReturn the second derivative of Bezier function.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.beziercurvature","page":"Polygons and paths","title":"Luxor.beziercurvature","text":"beziercurvature(t, A::Point, A1::Point, B1::Point, B::Point)\n\nReturn the curvature of the Bezier curve at t ([0-1]), given start and end points A and B, and control points A1 and B1. The value (kappa) will typically be a value between -0.001 and 0.001 for points with coordinates in the 100-500 range.\n\nŒ∫(t) is the curvature of the curve at point t, which for a parametric planar curve is:\n\nbeginequation\nkappa = fracmid dotxddoty-dotyddotxmid\n    (dotx^2 + doty^2)^frac32\nndequation\n\nThe radius of curvature, or the radius of an osculating circle at a point, is 1/Œ∫(t). Values of 1/Œ∫ will typically be in the range -1000 to 1000 for points with coordinates in the 100-500 range.\n\nTODO Fix overshoot...\n\n...The value of kappa can sometimes collapse near 0, returning NaN (and Inf for radius of curvature).\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.bezierfrompoints","page":"Polygons and paths","title":"Luxor.bezierfrompoints","text":"bezierfrompoints(startpoint::Point, pointonline1::Point,\n    pointonline2::Point, endpoint::Point)\n\nGiven four points, return the Bezier curve that passes through all four points, starting at startpoint and ending at endpoint. The two middle points of the returned BezierPathSegment are the two control points that make the curve pass through the two middle points supplied.\n\n\n\n\n\nbezierfrompoints(ptslist::Array{Point, 1})\n\nGiven four points, return the Bezier curve that passes through all four points.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.bezierpathtopoly","page":"Polygons and paths","title":"Luxor.bezierpathtopoly","text":"bezierpathtopoly(bezierpath::BezierPath; steps=10)\n\nConvert a Bezier path (an array of Bezier segments, where each segment is a tuple of four points: anchor1, control1, control2, anchor2) to a polygon.\n\nTo make a Bezier path, use makebezierpath() on a polygon.\n\nThe steps optional keyword determines how many line sections are used for each path.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.bezierstroke","page":"Polygons and paths","title":"Luxor.bezierstroke","text":"bezierstroke(point1, point2, width=0.0)\n\nReturn a BezierPath, a stroked version of a straight line between two points.\n\nIt wil have 2 or 6 Bezier path segments that define a brush or pen shape. If width is 0, the brush shape starts and ends at a point. Otherwise the brush shape starts and ends with the thick end.\n\nTo draw it, use eg drawbezierpath(..., :fill).\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.beziertopoly","page":"Polygons and paths","title":"Luxor.beziertopoly","text":"beziertopoly(bpseg::BezierPathSegment; steps=10)\n\nConvert a Bezier segment to a polygon (an array of points).\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.drawbezierpath","page":"Polygons and paths","title":"Luxor.drawbezierpath","text":"drawbezierpath(bezierpath::BezierPath, action=:none;\n    close=true)\n\nDraw the B√©zier path, and apply the action, such as :none, :stroke, :fill, etc. By default the path is closed.\n\n\n\n\n\ndrawbezierpath(bps::BezierPathSegment, action=:none;\n    close=false)\n\nDraw the B√©zier path segment, and apply the action, such as :none, :stroke, :fill, etc. By default the path is open.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.makebezierpath","page":"Polygons and paths","title":"Luxor.makebezierpath","text":"makebezierpath(pgon::Array{Point, 1}; smoothing=1.0)\n\nReturn a B√©zier path (a BezierPath) that represents a polygon (an array of points). The B√©zier path is an array of segments (tuples of 4 points); each segment contains the four points that make up a section of the entire B√©zier path. smoothing determines how closely the curve follows the polygon. A value of 0 returns a straight-sided path; as values move above 1 the paths deviate further from the original polygon's edges.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.pathtobezierpaths","page":"Polygons and paths","title":"Luxor.pathtobezierpaths","text":"pathtobezierpaths(\n    ; flat=true)\n\nConvert the current path (which may consist of one or more paths) to an array of Bezier paths. Each Bezier path is, in turn, an array of path segments. Each path segment is a tuple of four points. A straight line is converted to a Bezier segment in which the control points are set to be the same as the end points.\n\nIf flat is true, use getpathflat() rather than getpath().\n\nExample\n\nThis code draws the Bezier segments and shows the control points as \"handles\", like a vector-editing program might.\n\n@svg begin\n    fontface(\"MyanmarMN-Bold\")\n    st = \"goo\"\n    thefontsize = 100\n    fontsize(thefontsize)\n    sethue(\"red\")\n    fontsize(thefontsize)\n    textpath(st)\n    nbps = pathtobezierpaths()\n    for nbp in nbps\n        setline(.15)\n        sethue(\"grey50\")\n        drawbezierpath(nbp, :stroke)\n        for p in nbp\n            sethue(\"red\")\n            circle(p[2], 0.16, :fill)\n            circle(p[3], 0.16, :fill)\n            line(p[2], p[1], :stroke)\n            line(p[3], p[4], :stroke)\n            if p[1] != p[4]\n                sethue(\"black\")\n                circle(p[1], 0.26, :fill)\n                circle(p[4], 0.26, :fill)\n            end\n        end\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.setbezierhandles","page":"Polygons and paths","title":"Luxor.setbezierhandles","text":"setbezierhandles(bps::BezierPathSegment;\n        angles  = [0.05, -0.1],\n        handles = [0.3, 0.3])\n\nReturn a new Bezier path segment with new locations for the Bezier control points in the Bezier path segment bps.\n\nangles are the two angles that the \"handles\" make with the line direciton.\n\nhandles are the lengths of the \"handles\". 0.3 is a typical value.\n\n\n\n\n\nsetbezierhandles(bezpath::BezierPath;\n        angles=[0 .05, -0.1],\n        handles=[0.3, 0.3])\n\nReturn a new Bezierpath with new locations for the Bezier control points in every Bezier path segment of the BezierPath in bezpath.\n\nangles are the two angles that the \"handles\" make with the line direciton.\n\nhandles are the lengths of the \"handles\". 0.3 is a typical value.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.shiftbezierhandles","page":"Polygons and paths","title":"Luxor.shiftbezierhandles","text":"shiftbezierhandles(bps::BezierPathSegment;\n    angles=[0.1, -0.1], handles=[1.1, 1.1])\n\nReturn a new BezierPathSegment that modifies the Bezier path in bps by moving the control handles. The values in angles increase the angle of the handles; the values in handles modifies the lengths: 1 preserves the length, 0.5 halves the length of the  handles, 2 doubles them.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.findbeziercontrolpoints","page":"Polygons and paths","title":"Luxor.findbeziercontrolpoints","text":"findbeziercontrolpoints(previouspt::Point,\n    pt1::Point,\n    pt2::Point,\n    nextpt::Point;\n    smooth_value=0.5)\n\nFind the B√©zier control points for the line between pt1 and pt2, where the point before pt1 is previouspt and the next point after pt2 is nextpt.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.brush","page":"Polygons and paths","title":"Luxor.brush","text":"brush(pt1, pt2, width=10;\n    strokes=10,\n    minwidth=0.01,\n    maxwidth=0.03,\n    twist = -1,\n    lowhandle  = 0.3,\n    highhandle = 0.7,\n    randomopacity = true,\n    tidystart = false,\n    action = :fill,\n    strokefunction = (nbpb) -> nbpb))\n\nDraw a composite brush stroke made up of some randomized individual filled Bezier paths.\n\nstrokefunction allows a function to process a BezierPathSegment or do other things before it's drawn.\n\nnote: Note\nThere is a lot of randomness in this function. Results are unpredictable.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.beziersegmentangles","page":"Polygons and paths","title":"Luxor.beziersegmentangles","text":"beziersegmentangles(pt1, pt2;\n    out = deg2rad(45),\n    in  = deg2rad(135))\n)\n\nReturn a BezierPathSegment joining pt1 and pt2 making the angles out at the start and in at the end.\n\nIt's similar to the tikZ (a) to [out=135, in=45] (b) drawing instruction (but in radians obviously).\n\nout is the angle between a line from pt1 to the outgoing BeÃÅzier handle makes with the horizontal. in is the angle that a line joining pt2 from the preceding BeÃÅzier handle makes with the horizontal. So:\n\ndrawbezierpath(beziersegmentangles(O, O + (100, 0),\n    out = deg2rad(45),\n    in  = 2œÄ - deg2rad(45)),\n    :stroke)\n\ndraws a shape resembling a piece of string fixed at each end and hanging down in the middle.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Polygon-information","page":"Polygons and paths","title":"Polygon information","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"polyperimeter calculates the length of a polygon's perimeter.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(600, 250, \"assets/figures/polyperimeter.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\nsetline(1.5) # hide\nsethue(\"black\") # hide\nfontsize(20) # hide\np = box(O, 50, 50, vertices=true)\npoly(p, :stroke)\ntext(string(round(polyperimeter(p, closed=false))), O.x, O.y + 60)\n\ntranslate(200, 0)\n\npoly(p, :stroke, close=true)\ntext(string(round(polyperimeter(p, closed=true))), O.x, O.y + 60)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: polyperimeter)","category":"page"},{"location":"polygons/#Polygon-selection-and-modification","page":"Polygons and paths","title":"Polygon selection and modification","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"There are Luxor functions to return the first part or last part of a polygon. You can also ask for a resampling of a polygon, choosing either to increase the number of points (which places new points to the \"lines\" joining the vertices) or decrease them (which changes the shape of the polygon). It's also possible to insert vertices automatically.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"polyportion() and polyremainder() return part of a polygon depending on the fraction you supply. For example, polyportion(p, 0.5) returns the first half of polygon p, polyremainder(p, .75) returns the last quarter of it.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(600, 250, \"assets/figures/polyportion.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\nsetline(1.5) # hide\nsethue(\"black\") # hide\nfontsize(20) # hide\n\np = ngon(O, 100, 7, 0, vertices=true)\npoly(p, :stroke, close=true)\nsetopacity(0.75)\n\nsetline(20)\nsethue(\"red\")\npoly(polyportion(p, 0.25), :stroke)\n\nsetline(10)\nsethue(\"green\")\npoly(polyportion(p, 0.5), :stroke)\n\nsetline(5)\nsethue(\"blue\")\npoly(polyportion(p, 0.75), :stroke)\n\nsetline(1)\ncircle(polyremainder(p, 0.75)[1], 5, :stroke) # first point\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: polyportion)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"You can insert vertices in the edges of a polygon with insertvertices!(). For example, this code inserts a new vertex into each side of a polygon five times. The polygon ends up with 128 vertices.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/insertvertices.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(1) # hide\nsethue(\"black\") #¬†hide\n\npts = box(O, 500, 200, vertices=true)\nprettypoly(pts, :stroke, close=true)\n\nfor i in 1:5\n    insertvertices!(pts)\n    prettypoly(pts, :stroke, close=true)\n    fontsize(16)\n    label(string(length(pts)), :ne, pts[1], offset=10)\n    scale(0.8)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: poly insert vertices)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"To resample a polygon, use polysample(). In this example, the same four-sided polygon is resampled at multiples of 4, with different circle radii at each multiple. This adds more points to the new copy of the original polygon.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/polysample.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(1) # hide\nsethue(\"black\") #¬†hide\n\npts = ngon(O, 100, 4, vertices=true)\nfor (n, npoints) in enumerate(reverse([4, 8, 16, 32, 48]))\n    prettypoly(polysample(pts, npoints),\n        :stroke, close=true,\n        () -> begin\n                circle(O, 2n, :stroke)\n              end)\nend    \n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: polysampling)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"There is a closed option, which determines whether or not the final edge (the one that would join the final vertex to the first), is included in the sampling. In the following example, the original polygon is drawn in black, then sampled as a closed polygon (in blue), then as a non-closed one (magenta).","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(600, 250, \"assets/figures/polysample2.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(1) # hide\nsethue(\"black\") #¬†hide\nfontsize(8) #¬†hide\n\ntranslate(0, -50) #¬†hide\nsetline(1) # hide\nsethue(\"black\") #¬†hide\n\n# original polygon\n\nnumbervertices(l, n) = label(string(l), :N, O)\ndrawvertices() = ngon(O, 3, 4, 0, :fill)\n\npts = [Point(30x, 20sin(x)) for x in -2œÄ:œÄ/6:2œÄ]\n\n# 1: drawn as defined\n\nprettypoly(pts, \"stroke\", drawvertices, vertexlabels = numbervertices)\n\ntranslate(0, 50)\n\n\n# 2: resampled as closed\n\nnpoints = 40\n\nsethue(\"cornflowerblue\")\nprettypoly(polysample(pts, npoints, closed=true), :stroke, drawvertices,\n    vertexlabels = numbervertices)\n\ntranslate(0, 50)\n\n# 3: resampled as open\n\nsethue(\"magenta\")\nprettypoly(polysample(pts, npoints, closed=false), :stroke, drawvertices,\n    vertexlabels = numbervertices)\n\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: polysampling 2)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"polysample\ninsertvertices!","category":"page"},{"location":"polygons/#Luxor.polysample","page":"Polygons and paths","title":"Luxor.polysample","text":"polysample(p::Array{Point, 1}, npoints::T where T <: Integer;\n        closed=true)\n\nSample the polygon p, returning a polygon with npoints to represent it. The first sampled point is:\n\n 1/`npoints` * `perimeter of p`\n\naway from the original first point of p.\n\nIf npoints is the same as length(p) the returned polygon is the same as the original, but the first point finishes up at the end (so new=circshift(old, 1)).\n\nIf closed is true, the entire polygon (including the edge joining the last point to the first point) is sampled.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.insertvertices!","page":"Polygons and paths","title":"Luxor.insertvertices!","text":"insertvertices!(pgon;\n    ratio=0.5)\n\nInsert a new vertex into each edge of a polygon pgon. The default ratio of 0.5 divides the original edge of the polygon into half.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Polygon-side-lengths","page":"Polygons and paths","title":"Polygon side lengths","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"polydistances returns an array of the accumulated side lengths of a polygon.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"julia> p = ngon(O, 100, 7, 0, vertices=true);\njulia> polydistances(p)\n8-element Array{Real,1}:\n   0.0000\n  86.7767\n 173.553\n 260.33\n 347.107\n 433.884\n 520.66\n 607.437","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"It's used by polyportion() and polyremainder(), and you can pre-calculate and pass them to these functions via keyword arguments for performance. By default the result includes the final closing segment (closed=true).","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"These functions also make use of the nearestindex(), which returns a tuple of: the index of the nearest value in an array of distances to a given value; and the excess value.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"In this example, we want to find a point halfway round the perimeter of a triangle. Use nearestindex() to find the index of the nearest vertex (nidx, 2), and the surplus length, (over, 100).","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(650, 250, \"assets/figures/nearestindex.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\n\nsethue(\"black\") # hide\nsetline(0.5) # hide\n\np = ngonside(O, 200, 3, vertices=true)\nprettypoly(p, :stroke, close=true, vertexlabels = (n, l) -> label(string(n), :NW, offset=10))\n\n# distances array\nda = polydistances(p)\n\nnidx, over = nearestindex(da, polyperimeter(p)/2)\n\nsethue(\"red\")\ncircle(p[nidx], 5, :stroke)\n\narrow(p[nidx],\n      between(p[nidx], p[nidx+1], over/distance(p[nidx], p[nidx+1])),\n      linewidth=2)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: nearestindex)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"Of course, it's much easier to do polyportion(p, 0.5).","category":"page"},{"location":"polygons/#Area-of-polygon","page":"Polygons and paths","title":"Area of polygon","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"Use polyarea() to find the area of a polygon. Of course, this only works for simple polygons; polygons that intersect themselves or have holes are not correctly processed.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"This code draws some regular polygons and calculates their area, perimeter, and shows how near the ratio of perimeter over radius approaches 2œÄ.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(650, 500, \"assets/figures/polyarea.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nfontsize(13) # hide\nfontface(\"Georgia\")\nsethue(\"black\")\nsetline(0.25)\nouterframe = Table([500], [400, 200])\ntotal = 30\nproperties = Table(fill(15, total), [20, 85, 85], outerframe[1, 2])\nradius = 55\nsethue(\"grey20\")\nfor i in 3:total\n    global radius\n    text(string(i), properties[i, 1], halign=:right)\n    p = ngon(outerframe[1], radius, i, 0, vertices=true)\n    prettypoly(p, :stroke, close=true, () -> (sethue(\"red\"); circle(O, 2, :fill)))\n    pa = polyarea(p)\n    pp = polyperimeter(p)\n    ppoverradius = pp/radius\n    text(string(Int(round(pa, digits=0))), properties[i, 2], halign=:left)\n    text(string(round(ppoverradius, digits=6)), properties[i, 3], halign=:left)\n    radius += 5\nend\n\nfontsize(10)\n[text([\"Sides\", \"Area\", \"Perimeter/Radius\"][n], pt, halign=:center)\n    for (pt, n) in Table([20], [20, 85, 85], outerframe[2] - (0, 220))]\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: poly area)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"polyperimeter\npolyportion\npolyremainder\npolydistances\nnearestindex\npolyarea\nispolyclockwise\nispolyconvex","category":"page"},{"location":"polygons/#Luxor.polyperimeter","page":"Polygons and paths","title":"Luxor.polyperimeter","text":"polyperimeter(p::Array{Point, 1}; closed=true)\n\nFind the total length of the sides of polygon p.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.polyportion","page":"Polygons and paths","title":"Luxor.polyportion","text":"polyportion(p::Array{Point, 1}, portion=0.5; closed=true, pdist=[])\n\nReturn a portion of a polygon, starting at a value between 0.0 (the beginning) and 1.0 (the end). 0.5 returns the first half of the polygon, 0.25 the first quarter, 0.75 the first three quarters, and so on.\n\nUse closed=false to exclude the line joining the final point to the first point from the calculations.\n\nIf you already have a list of the distances between each point in the polygon (the \"polydistances\"), you can pass them in pdist, otherwise they'll be calculated afresh, using polydistances(p, closed=closed).\n\nUse the complementary polyremainder() function to return the other part.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.polyremainder","page":"Polygons and paths","title":"Luxor.polyremainder","text":"polyremainder(p::Array{Point, 1}, portion=0.5; closed=true, pdist=[])\n\nReturn the rest of a polygon, starting at a value between 0.0 (the beginning) and 1.0 (the end). 0.5 returns the last half of the polygon, 0.25 the last three quarters, 0.75 the last quarter, and so on.\n\nUse closed=false to exclude the line joining the final point to the first point from the calculations.\n\nIf you already have a list of the distances between each point in the polygon (the \"polydistances\"), you can pass them in pdist, otherwise they'll be calculated afresh, using polydistances(p, closed=closed).\n\nUse the complementary polyportion() function to return the other part.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.polydistances","page":"Polygons and paths","title":"Luxor.polydistances","text":"polydistances(p::Array{Point, 1}; closed=true)\n\nReturn an array of the cumulative lengths of a polygon.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.nearestindex","page":"Polygons and paths","title":"Luxor.nearestindex","text":"nearestindex(polydistancearray, value)\n\nReturn a tuple of the index of the largest value in polydistancearray less than value, and the difference value. Array is assumed to be sorted.\n\n(Designed for use with polydistances()).\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.polyarea","page":"Polygons and paths","title":"Luxor.polyarea","text":"polyarea(p::Array)\n\nFind the area of a simple polygon. It works only for polygons that don't self-intersect. See also polyorientation().\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.ispolyclockwise","page":"Polygons and paths","title":"Luxor.ispolyclockwise","text":"ispolyclockwise(pgon)\n\nReturns true if polygon is clockwise. WHEN VIEWED IN A LUXOR DRAWING...?\n\nTODO This code is still experimental...\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.ispolyconvex","page":"Polygons and paths","title":"Luxor.ispolyconvex","text":"ispolyconvex(pts)\n\nReturn true if polygon is convex. This tests that every interior angle is less than or equal to 180¬∞.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Other-polygon-operations","page":"Polygons and paths","title":"Other polygon operations","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"These functions are still in development. Expect varying degrees of success when using them.","category":"page"},{"location":"polygons/#Intersections","page":"Polygons and paths","title":"Intersections","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"intersectlinepoly(pt1, pt2, polygon) returns an array containing the points where a line from pt1 to pt2 crosses the perimeter of the polygon.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(600, 550, \"assets/figures/linepolyintersections.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(5) # hide\nsetline(0.3)\nsethue(\"thistle\")\nc = star(O, 120, 7, 0.2, vertices=true)\npoly(c, :fillstroke, close=true)\nfor n in 1:15\n    pt1 = Point(rand(-250:250, 2)...)\n    pt2 = Point(rand(-250:250, 2)...)\n    ips = intersectlinepoly(pt1, pt2, c)\n    if !isempty(ips)\n            sethue(\"grey20\")\n            line(pt1, pt2, :stroke)\n            randomhue()\n            circle.(ips, 2, :fill)\n    else\n        sethue(\"grey80\")\n        line(pt1, pt2, :stroke)\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: line/polygon intersections)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"polyintersect calculates the intersection points of two polygons.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor # hide\nDrawing(600, 550, \"assets/figures/polyintersections.png\") # hide\n\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"grey60\") # hide\nsetopacity(0.8) # hide\npentagon = ngon(O, 250, 5, vertices=true)\nsquare = box(O + (80, 20), 280, 400, vertices=true)\n\npoly(pentagon, :stroke, close=true)\npoly(square, :stroke, close=true)\n\nsethue(\"orange\")\ncircle.(polyintersect(pentagon, square), 8, :fill)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: polygon intersections)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"The returned polygon contains the points where one polygon crosses another.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"intersectlinepoly\npolyintersect","category":"page"},{"location":"polygons/#Luxor.intersectlinepoly","page":"Polygons and paths","title":"Luxor.intersectlinepoly","text":"intersectlinepoly(pt1::Point, pt2::Point, C)\n\nReturn an array of the points where a line between pt1 and pt2 crosses polygon C.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Luxor.polyintersect","page":"Polygons and paths","title":"Luxor.polyintersect","text":"polyintersect(p1::AbstractArray{Point, 1}, p2::AbstractArray{Point, 1};\n    closed=true)\n\nTODO: Fix/test/improve this experimental polygon intersection routine.\n\nReturn the points where polygon p1 and polygon p2 cross.\n\nIf closed is false, the intersection points must lie on the first n - 1 lines of each polygon.\n\n\n\n\n\n","category":"function"},{"location":"polygons/#Triangulation","page":"Polygons and paths","title":"Triangulation","text":"","category":"section"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"Use polytriangulate() to join the vertices of a polygon to form triangles. It returns an array of triangular polygons.","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"using Luxor, Random # hide\nDrawing(600, 550, \"assets/figures/polytriangulate.png\") # hide\n\norigin() # hide\nbackground(\"white\") # hide\nfontsize(18) # hide\n\npts = ngon(O, 200, 7, vertices=true)\ntriangles = polytriangulate(pts)\n\nfor (n, tri) in enumerate(triangles)\n    sethue([Luxor.julia_purple,\n            Luxor.julia_blue,\n            Luxor.julia_red,  \n            Luxor.julia_green\n            ][mod1(n, end)])\n    poly(offsetpoly(tri, -2), :fill, close = true)\n    sethue(\"white\")\n    text(string(n), polycentroid(tri), halign=:center)\nend\n\nsethue(\"red\")\nsetline(3)\npoly(pts, :stroke, close=true)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"(Image: polygon triangulation)","category":"page"},{"location":"polygons/","page":"Polygons and paths","title":"Polygons and paths","text":"polytriangulate","category":"page"},{"location":"polygons/#Luxor.polytriangulate","page":"Polygons and paths","title":"Luxor.polytriangulate","text":"polytriangulate(plist::Array{Point,1}; epsilon = -0.01)\n\nTriangulate the polygon in plist.\n\nThis uses the Bowyer‚ÄìWatson/Delaunay algorithm to make triangles. It returns an array of triangular polygons.\n\nTODO: This experimental polygon function is not very efficient, because it first copies the list of points (to avoid modifying the original), and sorts it, before making triangles.\n\n\n\n\n\n","category":"function"},{"location":"images/","page":"Images","title":"Images","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"images/#Images","page":"Images","title":"Images","text":"","category":"section"},{"location":"images/#Placing-images","page":"Images","title":"Placing images","text":"","category":"section"},{"location":"images/","page":"Images","title":"Images","text":"Luxor lets you place PNG and SVG images on the drawing. First, load an image:","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"for PNG images, use readpng(filename)\nfor SVG images, use readsvg(filename) or readsvg(string)","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"(JPEGs aren't supported.)","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"Then use placeimage() to place the image by its top left corner at point pt, or use the centered=true keyword to place the image's center point there. Access the image's dimensions with .width and .height. You can use the centered=true keyword.","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"using Luxor # hide\nDrawing(600, 350, \"assets/figures/images.png\") # hide\norigin() # hide\nbackground(\"grey40\") # hide\nimg = readpng(\"assets/figures/julia-logo-mask.png\")\nw = img.width\nh = img.height\nrulers()\nscale(0.3, 0.3)\nrotate(œÄ/4)\nplaceimage(img, Point(-w/2, -h/2), .5)\nsethue(\"red\")\ncircle(-w/2, -h/2, 15, :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"(Image: \"Images\")","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"PNG images can be placed with varying opacity/transparency/alpha.","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"readsvg() also lets you supply raw (or pure) SVG code in a string.","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"readpng\nreadsvg\nplaceimage","category":"page"},{"location":"images/#Luxor.readpng","page":"Images","title":"Luxor.readpng","text":"readpng(pathname)\n\nRead a PNG file.\n\nThis returns a image object suitable for placing on the current drawing with placeimage(). You can access its width and height fields:\n\nimage = readpng(\"/tmp/test-image.png\")\nw = image.width\nh = image.height\n\n\n\n\n\n","category":"function"},{"location":"images/#Luxor.readsvg","page":"Images","title":"Luxor.readsvg","text":"readsvg(str)\n\nRead an SVG image. str is either pathname or pure SVG code. This returns an SVG image object suitable for placing on the current drawing with placeimage().\n\nPlacing an SVG file:\n\n@draw begin\n    mycoollogo = readsvg(\"/tmp/mylogo.svg\")\n    placeimage(mycoollogo)\nend\n\nPlacing SVG code:\n\n# from https://github.com/edent/SuperTinyIcons\njulialogocode = \"\"\"<svg xmlns=\"http://www.w3.org/2000/svg\"\n    aria-label=\"Julia\" role=\"img\"\n    viewBox=\"0 0 512 512\">\n    <rect width=\"512\" height=\"512\" rx=\"15%\" fill=\"#fff\"/>\n    <circle fill=\"#389826\" cx=\"256\" cy=\"137\" r=\"83\"/>\n    <circle fill=\"#cb3c33\" cx=\"145\" cy=\"329\" r=\"83\"/>\n    <circle fill=\"#9558b2\" cx=\"367\" cy=\"329\" r=\"83\"/>\n</svg>\"\"\"\n\n@draw begin\n    julia_logo = readsvg(julialogocode)\n    placeimage(julia_logo, centered=true)\nend\n\n\n\n\n\n","category":"function"},{"location":"images/#Luxor.placeimage","page":"Images","title":"Luxor.placeimage","text":"placeimage(pngimg, pos=O; centered=false)\nplaceimage(pngimg, xpos, ypos; centered=false)\n\nPlace the PNG image on the drawing at pos, or (xpos/ypos). The image img has been previously read using readpng().\n\nUse keyword centered=true to place the center of the image at the position.\n\n\n\n\n\nplaceimage(img, pt::Point=O, alpha; centered=false)\nplaceimage(pngimg, xpos, ypos, alpha; centered=false)\n\nPlace a PNG image pngimg on the drawing at pt or Point(xpos, ypos) with opacity/transparency alpha. The image has been previously loaded using readpng().\n\nUse keyword centered=true to place the center of the image at the position.\n\n\n\n\n\nplaceimage(svgimg, pos=O; centered=false)\n\nPlace an SVG image stored in svgimg on the drawing at pos. Use readsvg() to read an SVG image from file, or from SVG code.\n\nUse keyword centered=true to place the center of the image at the position.\n\n\n\n\n\nplaceimage(matrix::AbstractMatrix{UInt32}, pos=O;\n    centered=false)\n\nPlace an image matrix on the drawing at pos.\n\nUse keyword centered=true to place the center of the image at the position.\n\n\n\n\n\n","category":"function"},{"location":"images/#Placing-an-image-matrix","page":"Images","title":"Placing an image matrix","text":"","category":"section"},{"location":"images/","page":"Images","title":"Images","text":"You can also use placeimage() to put image matrices on a drawing.","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"using Luxor\n\nmat = @imagematrix begin    \n    juliacircles(6)\nend 40 40\n\n@draw begin\n    for i in 1:500\n        pos = rand(BoundingBox())\n        @layer begin\n            translate(pos)\n            rotate(rand() * 2œÄ)\n            placeimage(mat, centered = rand(Bool))\n        end\n    end\nend","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"(Image: place image matrix)","category":"page"},{"location":"images/#Clipping-images","page":"Images","title":"Clipping images","text":"","category":"section"},{"location":"images/","page":"Images","title":"Images","text":"You can clip images. The following script repeatedly places the image using a circle to define a clipping path:","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"(Image: \"Images\")","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"using Luxor\n\nwidth, height = 4000, 4000\nmargin = 500\n\nfname = \"/tmp/test-image.pdf\"\nDrawing(width, height, fname)\norigin()\nbackground(\"grey25\")\n\nsetline(5)\nsethue(\"green\")\n\nimage = readpng(dirname(@__FILE__) * \"assets/figures/julia-logo-mask.png\")\n\nw = image.width\nh = image.height\n\npagetiles = Tiler(width, height, 7, 9)\ntw = pagetiles.tilewidth/2\nfor (pos, n) in pagetiles\n    circle(pos, tw, :stroke)\n    circle(pos, tw, :clip)\n    gsave()\n    translate(pos)\n    scale(.95, .95)\n    rotate(rand(0.0:œÄ/8:2œÄ))\n    placeimage(image, O, centered=true)\n    grestore()\n    clipreset()\nend\n\nfinish()","category":"page"},{"location":"images/#Transforming-images","page":"Images","title":"Transforming images","text":"","category":"section"},{"location":"images/","page":"Images","title":"Images","text":"You can transform images by setting the current matrix, either with scale() and rotate() and similar, or by modifying it directly. This code scales and rotates an image made in an earlier chapter of this document around in a circle:","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"using Luxor # hide\nDrawing(600, 400, \"assets/figures/transform-images.png\") # hide\norigin() # hide\nimg = readpng(dirname(dirname(pathof(Luxor))) * \"/docs/src/assets/figures/textoutlines.png\")\nw = img.width\nh = img.height\nfor Œ∏ in 0:œÄ/6:2œÄ-œÄ/6\n    gsave()\n    scale(.4, .4)\n    rotate(Œ∏)\n    translate(300, 0)\n    placeimage(img, -w/2, -h/2, 0.9)\n    grestore()\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"(Image: transforming images)","category":"page"},{"location":"images/#Drawing-on-images","page":"Images","title":"Drawing on images","text":"","category":"section"},{"location":"images/","page":"Images","title":"Images","text":"You sometimes want to draw over images, for example to annotate them with text or vector graphics. The things to be aware of are mostly to do with coordinates and transforms.","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"In these examples, we'll annotate a PNG file.","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"using Luxor # hide\n\nimage = readpng(\"assets/figures/julia-logo-mask.png\")\n\nw = image.width\nh = image.height\n\n# create a drawing surface of the same size\n\nfname = \"assets/figures/drawing_on_images.png\"\nDrawing(w, h, fname)\n\n# place the image on the Drawing - it's positioned by its top/left corner\n\nplaceimage(image, 0, 0)\n\n# now you can annotate the image. The (0/0) is at the top left.\n\nsethue(\"red\")\nsetline(1)\nfontsize(16)\ncircle(Point(150, 50), 2, :fill)\nlabel(\"(150/50)\", :NE, Point(150, 50), leader=true, offset=25)\n\narrow(Point(w/2, 90), Point(0, 90))\narrow(Point(w/2, 90), Point(w, 90))\ntext(\"width $w\", Point(w/2, 70), halign=:center)\n\n# to divide up the image into rectangular areas and number them,\n# temporarily position the axes at the center:\n\n@layer begin\n  setline(0.5)\n  sethue(\"green\")\n  fontsize(12)\n  translate(w/2, h/2)\n  tiles = Tiler(w, h, 8, 8, margin=0)\n  for (pos, n) in tiles\n      box(pos, tiles.tilewidth, tiles.tileheight, :stroke)\n      text(string(n-1), pos, halign=:center)\n  end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"(Image: drawing on images)","category":"page"},{"location":"images/#Adding-text-to-transformed-images","page":"Images","title":"Adding text to transformed images","text":"","category":"section"},{"location":"images/","page":"Images","title":"Images","text":"The above approach works well, but suppose you want to locate the working origin at the lower left of the image, i.e. you want all coordinates to be relative to the bottom left corner of the image?","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"To do this, use translate() and transform() to modify the drawing space:","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"using Luxor # hide\n\nimage = readpng(\"assets/figures/julia-logo-mask.png\")\nw = image.width\nh = image.height\nfname = \"assets/figures/drawing_on_images_2.png\"\nDrawing(w, h, fname)\nplaceimage(image, 0, 0)\n\n# Move the axes to the bottom:\n\ntranslate(0, h)\n\n# and reflect in the x-axis\n\ntransform([1 0 0 -1 0 0])\n\n# now 0/0 is at the bottom left corner, and 100/100 is up and to the right.\n\nsethue(\"blue\")\narrow(Point(200, 300), Point(160, 300))\n\n# However, don't draw text while flipped, because it will be reversed!\n\nfontsize(20)\nsethue(\"black\")\ntext(\"Oh no!\", Point(30, 250))\n\n# To work around this, define a text function\n# that flips the workspace over the x-axis just for the text:\n\nfunction textoverlay(t, pos; kwargs...)\n    @layer begin\n        translate(pos)\n        transform([1 0 0 -1 0 0])\n        text(t, O; kwargs...)\n    end\nend\n\ntextoverlay(\"a tittle!\", Point(200, 300), halign=:left, valign=:middle)\ntextoverlay(\"0/0\", O)\narrow(Point(130, 400), Point(130, 340))\n\nfinish() # hide\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"(Image: drawing on transformed images)","category":"page"},{"location":"images/#Image-compositing","page":"Images","title":"Image compositing","text":"","category":"section"},{"location":"images/","page":"Images","title":"Images","text":"You should be using Images.jl for most tasks involving image editing. But if you just need to composite images together, you can use the blending modes provided by setmode().","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"using Luxor # hide\nDrawing(600, 400, \"assets/figures/image-compositing.png\") # hide\norigin() # hide\nimg = readpng(\"assets/figures/textoutlines.png\")\nw = img.width\nh = img.height\n\nplaceimage(img, -w/2, -h/2, .5)\nsetmode(\"saturate\")\ntranslate(50, 0)\nplaceimage(img, -w/2, -h/2, .5)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"images/","page":"Images","title":"Images","text":"(Image: transforming images)","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"DocTestSetup = quote\n    using Luxor, Colors\nend","category":"page"},{"location":"moreexamples/#More-examples","page":"More examples","title":"More examples","text":"","category":"section"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"One place to look for examples is the Luxor/test directory.","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"(Image: \"tiled images\")","category":"page"},{"location":"moreexamples/#Illustrating-this-document","page":"More examples","title":"Illustrating this document","text":"","category":"section"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"This documentation was built with Documenter.jl, which is an amazingly powerful and flexible documentation generator written in Julia. The illustrations are mostly created when the HTML pages are built: the Julia source for the image is stored in the Markdown source document, and the code to create the images runs each time the documentation is generated.","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"The Markdown markup looks like this:","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"```@example\nusing Luxor, Random # hide\nDrawing(600, 250, \"assets/figures/polysmooth-pathological.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetopacity(0.75) # hide\nRandom.seed!(42) # hide\nsetline(1) # hide\np = star(O, 60, 5, 0.35, 0, vertices=true)\nsetdash(\"dot\")\nsethue(\"red\")\nprettypoly(p, close=true, :stroke)\nsetdash(\"solid\")\nsethue(\"black\")\npolysmooth(p, 40, :fill, debug=true)\nfinish() # hide\n```\n\n![polysmooth](assets/figures/polysmooth-pathological.png)","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"and after you run Documenter's build process the HTML output looks like this:","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"using Luxor, Random # hide\nDrawing(600, 250, \"assets/figures/polysmoothy.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsetopacity(0.75) # hide\nRandom.seed!(42) # hide\nsetline(1) # hide\np = star(O, 60, 5, 0.35, 0, vertices=true)\nsetdash(\"dot\")\nsethue(\"red\")\nprettypoly(p, close=true, :stroke)\nsetdash(\"solid\")\nsethue(\"black\")\npolysmooth(p, 40, :fill, debug=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"(Image: polysmooth)","category":"page"},{"location":"moreexamples/#Why-turtles?","page":"More examples","title":"Why turtles?","text":"","category":"section"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"An interesting application for turtle-style graphics is for drawing Lindenmayer systems (l-systems). Here's an example of how a complex pattern can emerge from a simple set of rules, taken from Lindenmayer.jl:","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"(Image: penrose)","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"The definition of this figure is:","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"penrose = LSystem(Dict(\"X\"  =>  \"PM++QM----YM[-PM----XM]++t\",\n                       \"Y\"  => \"+PM--QM[---XM--YM]+t\",\n                       \"P\"  => \"-XM++YM[+++PM++QM]-t\",\n                       \"Q\"  => \"--PM++++XM[+QM++++YM]--YMt\",\n                       \"M\"  => \"F\",\n                       \"F\"  => \"\"),\n                  \"1[Y]++[Y]++[Y]++[Y]++[Y]\")","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"where some of the characters‚Äîeg \"F\", \"+\", \"-\", and \"t\"‚Äîissue turtle control commands, and others‚Äî\"X,\", \"Y\", \"P\", and \"Q\"‚Äîrefer to specific components of the design. The execution of the l-system involves replacing every occurrence in the drawing code of every dictionary key with the matching values.","category":"page"},{"location":"moreexamples/#Strange","page":"More examples","title":"Strange","text":"","category":"section"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"It's usually better to draw fractals and similar images using pixels and image processing tools. But just for fun it's an interesting experiment to render a strange attractor image using vector drawing rather than placing pixels. This version uses about 600,000 circular dots (which is why it's better to target PNG rather than SVG or PDF for this example!).","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"using Luxor, Colors\nfunction strange(dotsize, w=800.0)\n    xmin = -2.0; xmax = 2.0; ymin= -2.0; ymax = 2.0\n    Drawing(w, w, \"assets/figures/strange-vector.png\")\n    origin()\n    background(\"white\")\n    xinc = w/(xmax - xmin)\n    yinc = w/(ymax - ymin)\n    # control parameters\n    a = 2.24; b = 0.43; c = -0.65; d = -2.43; e1 = 1.0\n    x = y = z = 0.0\n    wover2 = w/2\n    for j in 1:w\n        for i in 1:w\n            xx = sin(a * y) - z  *  cos(b * x)\n            yy = z * sin(c * x) - cos(d * y)\n            zz = e1 * sin(x)\n            x = xx; y = yy; z = zz\n            if xx < xmax && xx > xmin && yy < ymax && yy > ymin\n                xpos = rescale(xx, xmin, xmax, -wover2, wover2) # scale to range\n                ypos = rescale(yy, ymin, ymax, -wover2, wover2) # scale to range\n                rcolor = rescale(xx, -1, 1, 0.0, .7)\n                gcolor = rescale(yy, -1, 1, 0.2, .5)\n                bcolor = rescale(zz, -1, 1, 0.3, .8)\n                setcolor(convert(Colors.HSV, Colors.RGB(rcolor, gcolor, bcolor)))\n                circle(Point(xpos, ypos), dotsize, :fill)\n            end\n        end\n    end\n    finish()\nend\n\nstrange(.3, 800)\nnothing # hide","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"(Image: strange attractor in vectors)","category":"page"},{"location":"moreexamples/#More-animations","page":"More examples","title":"More animations","text":"","category":"section"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"(Image: strange attractor in vectors)","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"Most of the animations on this YouTube channel are made with Luxor.","category":"page"},{"location":"moreexamples/#The-Luxor-logo","page":"More examples","title":"The Luxor logo","text":"","category":"section"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"using Luxor, Colors\n\nfunction multistrokepath(lightness, chroma, hue)\n    # takes the current path and multistrokes it\n    @layer begin\n        for n in 1:2:15\n            sethue(LCHab(5n, chroma, hue))\n            setline(rescale(n, 1, 15, 15, 1))\n            strokepreserve()\n        end\n    end\nend\n\nfunction multifillpath(lightness, chroma, hue)\n    # takes the current path and multifills it\n    @layer begin\n        p = pathtopoly()[1]\n        for n in 0:2:40\n            sethue(LCHab(3n, chroma + n/2, hue))\n            setopacity(rescale(n, 1, 40, 1, 0.1))\n            poly(offsetpoly(p, -n), :fill, close=true)\n        end\n    end\nend\n\nfunction scarab(pos)\n    @layer begin\n        translate(pos)\n        setline(15)\n        setlinecap(\"round\")\n        setlinejoin(\"round\")\n        #legs\n        @layer begin\n            for i in 1:2\n                # right front leg\n                move(O)\n                rline.((polar(80, -œÄ/6),\n                polar(60, -œÄ/2),\n                polar(12, -5œÄ/6),\n                polar(60, -œÄ/4)))\n                #middle leg\n                move(0, 35)\n                rline.((\n                polar(100, -œÄ/6),\n                polar(40, œÄ/2)))\n                #back leg\n                move(0, 100)\n                rline.((polar(120, -œÄ/6),\n                polar(100, œÄ/2)))\n                multistrokepath(50, 20, 240)\n                # other side\n                transform([-1 0 0 1 0 0])\n            end\n            # body\n            @layer begin\n                squircle(Point(0, -25), 26, 75, :fillpreserve)\n                multifillpath(60, 20, 260)            \n\n                squircle(Point(0, 0), 50, 70, :fillpreserve)\n                multifillpath(60, 20, 260)\n\n                squircle(Point(0, 40), 65, 90, :fillpreserve)\n                multifillpath(60, 20, 260)                \n            end\n        end\n    end\nend\n\nfunction draw()\n    Drawing(500, 500, \"assets/figures/luxor-logo.png\")\n    origin()\n    background(1, 1, 1, 0)\n    setopacity(1.0)\n    width = 180\n    height= 240\n    # cartouche\n    @layer begin\n        setcolor(\"goldenrod\")\n        squircle(O, width, height, rt=0.4, :fill)\n    end\n\n    sethue(\"gold3\")\n    setline(14)\n    squircle(O, width, height, rt=0.4, :stroke)\n\n    # interior shadow\n    @layer begin\n        sethue(\"grey20\")\n        setline(2)\n        for n in 10:30\n            setopacity(rescale(n, 10, 30, 0.5, 0.0))\n            squircle(O, width-n, height-n, rt=0.4, :stroke)\n        end\n    end\n\n    # draw scarab\n    scale(0.9)\n    translate(0, 50)\n    scarab(O)\n\n    # julia/sun\n    @layer begin\n        translate(0, -190)\n        sethue(\"grey20\")\n        circle(O, 52, :fill)\n        sethue(\"gold\")\n        circle(O, 51, :fill)\n        sethue(LCHab(20, 55, 15))\n        circle(O, 48, :fill)\n        juliacircles(20)\n    end\n\n    clipreset()\n    finish()\nend\ndraw()\nnothing #hide","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"(Image: Luxor logo)","category":"page"},{"location":"moreexamples/#A-Japanese-style-Temple-scene","page":"More examples","title":"A Japanese-style Temple scene","text":"","category":"section"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"This code was created by kfung, a student that participated in Google Code-in 2019 competition.","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"using Luxor\nDrawing(1280, 720, \"assets/figures/temple.png\")\norigin()\nsetblend(blend(Point(0, -200), Point(0, 300), \"#F38070\", \"#F3C3BC\"))\nbox(O, 1280, 720, :fill)\nsethue(\"#F7C5BC\")\nsetopacity(0.3)\nsun = Point(450, -225)\npoly([sun, Point(400, 400), Point(640, 400), sun], :fill)\npoly([sun, Point(-150, 400), Point(150, 400), sun], :fill)\npoly([sun, Point(-640, 400), Point(-640, 0), sun], :fill)\npoly([sun, Point(-640, -150), Point(-640, -450), sun], :fill)\npoly([sun, Point(100, -360), Point(300, -360), sun], :fill)\npoly([sun, Point(375, -400), Point(475, -400), sun], :fill)\npoly([sun, Point(585, -400), Point(775, -400), sun], :fill)\npoly([sun, Point(640, -265), Point(640, -175), sun], :fill)\npoly([sun, Point(640, -100), Point(640, 125), sun], :fill)\nsethue(\"#C02C20\")\nsetopacity(1)\ncircle(450, -225, 40, :fill)\nsethue(\"white\")\nsetopacity(0.98)\nellipse(20, -275, 150, 75, :fill)\nellipse(-20, -240, 150, 50, :fill)\nellipse(60, -245, 150, 50, :fill)\nellipse(-450, -240, 150, 50, :fill)\nellipse(-350, -250, 150, 50, :fill)\nellipse(430, -90, 200, 10, :fill)\nellipse(470, -95, 200, 10, :fill)\nsetopacity(0.8)\nellipse(-450, -130, 200, 10, :fill)\nellipse(-490, -135, 200, 10, :fill)\nsetopacity(1)\nsethue(\"#2E951A\")\ndrawbezierpath(makebezierpath([Point(-780, 500), Point(-640, 100), Point(-560, -20), Point(-480, -80), Point(-400, -80), Point(-320, -20), Point(-240, 100), Point(-240, 500)]), :fill, close=false)\nsethue(\"#37C61B\")\ndrawbezierpath(makebezierpath([Point(-780, 500), Point(-640, 200), Point(-560, 100), Point(-480, 40), Point(-400, 30), Point(-320, 70), Point(-240, 150), Point(-240, 500)]), :fill, close=false)\nsethue(\"#23AE34\")\nsetopacity(1)\nellipse(530, 90, 100, 100, :fill)\nellipse(490, 150, 80, 80, :fill)\nellipse(570, 150, 80, 80, :fill)\nsethue(\"#713D1D\")\nbox(530, 220, 15, 290, :fill)\nsetline(15)\nline(Point(530,180), Point(565, 125), :stroke)\nline(Point(530,140), Point(495, 105), :stroke)\nsethue(\"#E13705\")\ncircle(480, 150, 8, :fill)\ncircle(560, 100, 8, :fill)\ncircle(510, 70, 8, :fill)\ncircle(580, 160, 8, :fill)\n[circle(544+16*(i-1), 292, 8, :fill) for i in 1:3]\ncircle(552, 278, 8, :fill)\ncircle(512, 292, 8, :fill)\ncircle(496, 292, 8, :fill)\nsethue(\"white\")\nsetline(10)\nline(Point(440, 300), Point(440, 250), :stroke)\npoly([Point(410, 250), Point(395, 235), Point(410, 220), Point(465, 220), Point(465, 250)], :fill)\nsethue(\"black\")\nfontsize(12)\nfontface(\"Arial\")\ntext(\"THIS WAY\", Point(434, 241), halign=:center,  valign = :center)\nsetopacity(1)\nsethue(\"#2A3A4A\")\nbox(0, 330, 1280, 60, :fill)\nsetline(20)\nsetopacity(1)\ndrawbezierpath(makebezierpath([Point(-570, 320), Point(-500, 270), Point(-400, 230), Point(-550, 200), Point(-360, 160), Point(-460, 110), Point(-342, 70), Point(-340, 70)]), :stroke, close=false)\ncircle(-340, 69, 10, :fill)\ncircle(-336, 67, 10, :fill)\nsetopacity(1)\nsethue(\"white\")\n[box(-600+100*(i-1), 330, 50, 5, :fill) for i in 1:13]\nsethue(\"#E7D1BC\")\nbox(0, 240, 700, 120, :fill)\nbox(0, 150, 300, 120, :fill)\nbox(0, 40, 500, 120, :fill)\nsethue(\"#EE766B\")\n[circle((-400+20*(i-1)), 180, 10, :fill) for i in 1:41]\n[circle((-270+20*(i-1)), -20, 10, :fill) for i in 1:28]\nsethue(\"#D14A3E\")\npoly([Point(-420, 180), Point(420, 180), Point(250, 70), Point(-250, 70), Point(-420, 180)], :fill)\npoly([Point(-290, -20), Point(290, -20), Point(150, -120), Point(-150, -120), Point(-290, -20)], :fill)\ncircle(0, 58, 10, :fill)\ncircle(0, 45, 4, :fill)\nsethue(\"#B71909\")\npoly([Point(0, 55), Point(140, 180), Point(-140, 180), Point(0, 55)], :fill)\nsethue(\"#E7D1BC\")\npoly([Point(0, 70), Point(159, 210), Point(-159, 210), Point(0, 70)], :fill)\nsethue(\"black\")\n[box(-180+120*(i-1), 30, 20, 40, :fill) for i in 1:4]\nbox(-300, 240, 20, 40, :fill)\nbox(-200, 240, 20, 40, :fill)\nbox(200, 240, 20, 40, :fill)\nbox(300, 240, 20, 40, :fill)\nsethue(\"#C99A6F\")\nbox(-130, 240, 10, 120, :fill)\nbox(130, 240, 10, 120, :fill)\npoly([Point(0, 85), Point(91, 165), Point(-91, 165), Point(0, 85)], :fill)\nsethue(\"black\")\nbox(0, 258, 88, 84, :fill)\nsethue(\"#C99A6F\")\nbox(-20, 260, 38, 80, :fill)\nbox(20, 260, 38, 80, :fill)\nsethue(\"black\")\ncircle(-10, 260, 4, :fill)\ncircle(10, 260, 4, :fill)\nfinish()\nnothing # hide","category":"page"},{"location":"moreexamples/","page":"More examples","title":"More examples","text":"(Image: temple)","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"DocTestSetup = quote\n    using Luxor, Colors, Random\n    end","category":"page"},{"location":"moregraphics/#More-graphics","page":"More graphics","title":"More graphics","text":"","category":"section"},{"location":"moregraphics/#Julia-logos","page":"More graphics","title":"Julia logos","text":"","category":"section"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"A couple of functions in Luxor provide you with instant access to the Julia logo, and the three colored circles:","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"using Luxor, Random # hide\nDrawing(750, 300, \"assets/figures/julia-logo.png\")  # hide\nRandom.seed!(42) # hide\norigin()  # hide\nbackground(\"white\") # hide\n\ncells = Table([300], [350, 350])\n\n@layer begin\n    translate(cells[1])\n    translate(-165, -114)\n    rulers()\n    julialogo()\nend\n\n@layer begin\n    translate(cells[2])\n    translate(-165, -114)\n    rulers()\n    julialogo(action=:clip)\n    for i in 1:500\n        @layer begin\n            translate(rand(0:400), rand(0:250))\n            juliacircles(10)\n        end\n    end\n    clipreset()\n    end\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"(Image: get path)","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"julialogo\njuliacircles","category":"page"},{"location":"moregraphics/#Luxor.julialogo","page":"More graphics","title":"Luxor.julialogo","text":"julialogo(;\n    action=:fill,\n    color=true,\n    bodycolor=colorant\"black\",\n    centered=false)\n\nDraw the Julia logo. The default action is to fill the logo and use the colors:\n\njulialogo()\n\nIf color is false, the bodycolor color is used for the logo.\n\nThe function uses the current drawing state (position, scale, etc).\n\nThe centered keyword lets you center the logo at its mathematical center, but the optical center might lie somewhere else - it's difficult to position well due to its asymmetric design.\n\nTo use the logo as a clipping mask:\n\njulialogo(action=:clip)\n\n(In this case the color setting is automatically ignored.)\n\nTo obtain a stroked (outlined) version:\n\njulialogo(action=:path)\nsethue(\"red\")\nstrokepath()\n\n\n\n\n\n","category":"function"},{"location":"moregraphics/#Luxor.juliacircles","page":"More graphics","title":"Luxor.juliacircles","text":"juliacircles(radius=100;\n    outercircleratio=0.75,\n    innercircleratio=0.65,\n    action=:fill)\n\nDraw the three Julia circles (\"dots\") in color centered at the origin.\n\nThe distance of the centers of each circle from the origin is radius.\n\nThe optional keyword argument outercircleratio (default 0.75) determines the radius of each circle relative to the main radius. So the default is to draw circles of radius 75 points around a larger circle of radius 100.\n\nReturn the three centerpoints.\n\nThe innercircleratio (default 0.65) no longer does anything useful (it used to draw the smaller circles) and will be deprecated.\n\n\n\n\n\n","category":"function"},{"location":"moregraphics/#Hypotrochoids","page":"More graphics","title":"Hypotrochoids","text":"","category":"section"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"hypotrochoid() makes hypotrochoids. The result is a polygon. You can either draw it directly, or pass it on for further polygon fun, as here, which uses offsetpoly() to trace round it a few times.","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"using Luxor # hide\nDrawing(500, 300, \"assets/figures/hypotrochoid.png\")  # hide\norigin()\nbackground(\"grey15\")\nsethue(\"antiquewhite\")\nsetline(1)\np = hypotrochoid(100, 25, 55, :stroke, stepby=0.01, vertices=true)\nfor i in 0:3:15\n    poly(offsetpoly(p, i), :stroke, close=true)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"(Image: hypotrochoid)","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"There's a matching epitrochoid() function.","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"hypotrochoid\nepitrochoid","category":"page"},{"location":"moregraphics/#Luxor.hypotrochoid","page":"More graphics","title":"Luxor.hypotrochoid","text":"hypotrochoid(R, r, d, action=:none;\n        stepby=0.01,\n        period=0.0,\n        vertices=false)\n\nMake a hypotrochoid with short line segments. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius r rolling around the inside  of a fixed circle of radius R, where the point is a distance d from  the center of the interior circle. Things get interesting if you supply non-integral values.\n\nSpecial cases include the hypocycloid, if d = r, and an ellipse, if R = 2r.\n\nstepby, the angular step value, controls the amount of detail, ie the smoothness of the polygon,\n\nIf period is not supplied, or 0, the lowest period is calculated for you.\n\nThe function can return a polygon (a list of points), or draw the points directly using the supplied action. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of pi).\n\n\n\n\n\n","category":"function"},{"location":"moregraphics/#Luxor.epitrochoid","page":"More graphics","title":"Luxor.epitrochoid","text":"epitrochoid(R, r, d, action=:none;\n        stepby=0.01,\n        period=0,\n        vertices=false)\n\nMake a epitrochoid with short line segments. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius r rolling around the outside of a fixed circle of radius R, where the point is a distance d from the center of the circle. Things get interesting if you supply non-integral values.\n\nstepby, the angular step value, controls the amount of detail, ie the smoothness of the polygon.\n\nIf period is not supplied, or 0, the lowest period is calculated for you.\n\nThe function can return a polygon (a list of points), or draw the points directly using the supplied action. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of pi).\n\n\n\n\n\n","category":"function"},{"location":"moregraphics/#Cropmarks","page":"More graphics","title":"Cropmarks","text":"","category":"section"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"If you want cropmarks (aka trim marks), use the cropmarks() function, supplying the centerpoint, followed by the width and height:","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"cropmarks(O, 1200, 1600)\ncropmarks(O, paper_sizes[\"A0\"]...)","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"using Luxor # hide\nDrawing(700, 250, \"assets/figures/cropmarks.png\")  # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"red\")\nbox(O, 150, 150, :stroke)\ncropmarks(O, 150, 150)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"(Image: cropmarks)","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"cropmarks","category":"page"},{"location":"moregraphics/#Luxor.cropmarks","page":"More graphics","title":"Luxor.cropmarks","text":"cropmarks(center, width, height)\n\nDraw cropmarks (also known as trim marks).\n\n\n\n\n\n","category":"function"},{"location":"moregraphics/#Dimensioning","page":"More graphics","title":"Dimensioning","text":"","category":"section"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"Simple dimensioning graphics can be generated with dimension(). To convert from the default unit (PostScript points), or to modify the dimensioning text, supply a function to the format keyword argument.","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"(Image: dimensioning)","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"using Luxor # hide\nDrawing(700, 350, \"assets/figures/dimensioning.svg\")  # hide\norigin() # hide\nbackground(\"white\") # hide\nsetline(0.75)\nsethue(\"purple\")\npentagon = ngonside(O, 120, 5, vertices=true)\npoly(pentagon, :stroke, close=true)\ncircle.(pentagon, 2, :fill)\nfontsize(6)\nlabel.(split(\"12345\", \"\"), :NE, pentagon)\nfontface(\"Menlo\")\nfontsize(10)\nsethue(\"grey30\")\n\ndimension(O, pentagon[4],\n    fromextension = [0, 0])\n\ndimension(pentagon[1], pentagon[2],\n    offset        = -60,\n    fromextension = [20, 50],\n    toextension   = [20, 50],\n    textrotation  = 2œÄ/5,\n    textgap       = 20,\n    format        = (d) -> string(round(d, digits=4), \"pts\"))\n\ndimension(pentagon[2], pentagon[3],\n     offset        = -40,\n     format        =  string)\n\ndimension(pentagon[5], Point(pentagon[5].x, pentagon[4].y),\n    offset        = 60,\n    format        = (d) -> string(\"approximately \",round(d, digits=4)),\n    fromextension = [5, 5],\n    toextension   = [80, 5])\n\ndimension(pentagon[1], midpoint(pentagon[1], pentagon[5]),\n    offset               = 70,\n    fromextension        = [65, -5],\n    toextension          = [65, -5],\n    texthorizontaloffset = -5,\n    arrowheadlength      = 5,\n    format               = (d) ->\n        begin\n            if isapprox(d, 60.0)\n                string(\"exactly \", round(d, digits=4), \"pts\")\n            else\n                string(\"‚âà \", round(d, digits=4), \"pts\")\n            end\n        end)\n\ndimension(pentagon[1], pentagon[5],\n    offset               = 120,\n    fromextension        = [5, 5],\n    toextension          = [115, 5],\n    textverticaloffset   = 0.5,\n    texthorizontaloffset = 0,\n    textgap              = 5)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"dimension","category":"page"},{"location":"moregraphics/#Luxor.dimension","page":"More graphics","title":"Luxor.dimension","text":"dimension(p1::Point, p2::Point;\n    format::Function   = (d) -> string(d), # process the measured value into a string\n    offset             = 0.0,              # left/right, parallel with x axis\n    fromextension      = (10.0, 10.0),     # length of extensions lines left and right\n    toextension        = (10.0, 10.0),     #\n    textverticaloffset = 0.0,              # range 1.0 (top) to -1.0 (bottom)\n    texthorizontaloffset = 0.0,            # range 1.0 (top) to -1.0 (bottom)\n    textgap            = 5,                # gap between start of each arrow (‚âà fontsize?)\n    textrotation       = 0.0,\n    arrowlinewidth     = 1.0,\n    arrowheadlength    = 10,\n    arrowheadangle     = œÄ/8)\n\nCalculate and draw dimensioning graphics for the distance between p1 and p2. The value can be formatted with function format.\n\np1 is the lower on the page (ie probably the higher y value) point, p2 is the higher on the page (ie probably lower y) point.\n\noffset is to the left (-x) when negative.\n\nDimension graphics will be rotated to align with a line between p1 and p2.\n\nIn textverticaloffset, \"vertical\" and \"horizontal\" are best understood by \"looking\" along the line from the first point to the second. textverticaloffset ranges from -1 to 1, texthorizontaloffset in default units.\n\n        toextension\n        [5  ,  5]\n       <---> <--->\n                             to\n       -----------            +\n            ^\n            |\n\n           -50\n\n            |\n            v\n       ----------            +\n                            from\n       <---> <--->\n         [5 , 5]\n       fromextension\n\n            <---------------->\n                  offset\n\nReturns the measured distance and the text.\n\n\n\n\n\n","category":"function"},{"location":"moregraphics/#Barcharts","page":"More graphics","title":"Barcharts","text":"","category":"section"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"For simple barcharts, use the barchart() function, supplying an array of numbers:","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"using Luxor # hide\nDrawing(800, 420, \"assets/figures/bars.png\")  # hide\norigin() # hide\nbackground(\"white\") # hide\nfontsize(7)\nsethue(\"black\")\nv = rand(-100:100, 25)\nbarchart(v, labels=true)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"(Image: bars)","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"To change the way the bars and labels are drawn, define some functions and pass them as keyword arguments:","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"using Luxor, Colors, Random # hide\nDrawing(800, 450, \"assets/figures/bars1.png\")  # hide\n\nRandom.seed!(2) # hide\norigin() # hide\nbackground(\"white\") # hide\nsetopacity(0.8) # hide\nfontsize(8) # hide\nfontface(\"Helvetica-Bold\") # hide\nsethue(\"black\") # hide\n\nfunction mybarfunction(values, i, low, high, barwidth, scaledvalue)\n    @layer begin\n        extremes = extrema(values)\n        sethue(Colors.HSB(rescale(values[i], extremes[1], extremes[2], 0, 360), 1.0, 0.5))\n        csize = rescale(values[i], extremes[1], extremes[2], 5, 15)\n        circle(high, csize, :fill)\n        setline(1)\n        sethue(\"blue\")\n        line(low, high, :stroke)\n        sethue(\"white\")\n        text(string(values[i]), high, halign=:center, valign=:middle)\n    end\nend\n\nfunction mylabelfunction(values, i, low, high, barwidth, scaledvalue)\n    @layer begin\n        translate(low)\n        text(string(values[i]), O + (0, 10), halign=:center, valign=:middle)\n    end\nend\n\nv = rand(1:100, 15)\n\nbbox = BoundingBox() * 0.8\nbox(bbox, :clip)\np = barchart(v, boundingbox=bbox, barfunction=mybarfunction, labelfunction=mylabelfunction)\n\nrule(p[1])\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"(Image: bars 1)","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"barchart    ","category":"page"},{"location":"moregraphics/#Luxor.barchart","page":"More graphics","title":"Luxor.barchart","text":"barchart(values;\n        boundingbox = BoundingBox(O + (-250, -120), O + (250, 120)),\n        bargap=10,\n        margin = 5,\n        border=false,\n        labels=false,\n        labelfunction = (values, i, lowpos, highpos, barwidth, scaledvalue) -> begin\n                label(string(values[i]), :n, highpos, offset=10)\n          end,\n        barfunction =  (values, i, lowpos, highpos, barwidth, scaledvalue) -> begin\n            @layer begin\n                setline(barwidth)\n                line(lowpos, highpos, :stroke)\n            end\n          end)\n\nDraw a barchart where each bar is the height of a value in the values array. The bars will be scaled to fit in a bounding box.\n\nText labels are drawn if the keyword labels=true.\n\nExtended help\n\nThe function returns a vector of points; each is the bottom center of a bar.\n\nDraw a Fibonacci sequence as a barchart:\n\nfib(n) = n > 2 ? fib(n - 1) + fib(n - 2) : 1\nfibs = fib.(1:15)\n@draw begin\n    fontsize(12)\n    barchart(fibs, labels=true)\nend\n\nTo control the drawing of the text and bars, define functions that process the end points:\n\nmybarfunction(values, i, lowpos, highpos, barwidth, scaledvalue)\n\nmylabelfunction(values, i, lowpos, highpos, barwidth, scaledvalue)\n\nand pass them like this:\n\nbarchart(vals, barfunction=mybarfunction)\nbarchart(vals, labelfunction=mylabelfunction)\n\nfunction myprologfunction(values, basepoint, minbarrange, maxbarrange, barchartheight)\n    @layer begin\n        setline(0.2)\n        for i in 0:10:maximum(values)\n            rule(boxbottomcenter(basepoint) + (0, -(rescale(i, minbarrange, maxbarrange) * barchartheight)))\n        end\n    end\nend\n\n\n\n\n\n","category":"function"},{"location":"moregraphics/#Box-maps","page":"More graphics","title":"Box maps","text":"","category":"section"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"The boxmap() function divides a rectangular area into a sorted arrangement of smaller boxes or tiles based on the values of elements in an array.","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"This example uses the Fibonacci sequence to determine the area of the boxes. Notice that the values are sorted in reverse, and are scaled to fit in the available area.","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"using Luxor, Colors, Random # hide\nDrawing(800, 450, \"assets/figures/boxmap.png\")  # hide\nRandom.seed!(13) # hide\norigin() # hide\nbackground(\"white\") # hide\n\nfib = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]\n\n# make a boxmap and store the tiles\ntiles = boxmap(fib, BoundingBox()[1], 800, 450)\n\nfor (n, t) in enumerate(tiles)\n    randomhue()\n    bb = BoundingBox(t)\n    sethue(\"black\")\n    box(bb - 5, :stroke)\n\n    randomhue()\n    box(bb - 8, :fill)\n\n    # text labels\n    sethue(\"white\")\n\n    # rescale text to fit better\n    fontsize(boxwidth(bb) > boxheight(bb) ? boxheight(bb)/4 : boxwidth(bb)/4)\n    text(string(sort(fib, rev=true)[n]),\n        midpoint(bb[1], bb[2]),\n        halign=:center,\n            valign=:middle)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"(Image: boxmap)","category":"page"},{"location":"moregraphics/","page":"More graphics","title":"More graphics","text":"boxmap","category":"page"},{"location":"moregraphics/#Luxor.boxmap","page":"More graphics","title":"Luxor.boxmap","text":"boxmap(A::Array, pt, w, h)\n\nBuild a box map of the values in A with one corner at pt and width w and height h. There are length(A) boxes. The areas of the boxes are proportional to the original values, scaled as necessary.\n\nThe return value is an array of BoxmapTiles. For example:\n\n[BoxmapTile(0.0, 0.0, 10.0, 20.0)\n BoxmapTile(10.0, 0.0, 10.0, 13.3333)\n BoxmapTile(10.0, 13.3333, 10.0, 6.66667)]\n\nwith each tile containing (x, y, w, h). box() and BoundingBox() can work with BoxmapTiles as well.\n\nExample\n\nusing Luxor\n@svg begin\n    fontsize(16)\n    fontface(\"HelveticaBold\")\n    pt = Point(-200, -200)\n    a = rand(10:200, 15)\n    tiles = boxmap(a, Point(-200, -200), 400, 400)\n    for (n, t) in enumerate(tiles)\n        randomhue()\n        bb = BoundingBox(t)\n        box(bb - 2, :stroke)\n        box(bb - 5, :fill)\n        sethue(\"white\")\n        text(string(n), midpoint(bb[1], bb[2]), halign=:center)\n    end\nend 400 400 \"/tmp/boxmap.svg\"\n\n\n\n\n\n","category":"function"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"tables-grids/#Tables-and-grids","page":"Tables and grids","title":"Tables and grids","text":"","category":"section"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"You often want to position graphics at regular locations on the drawing. The positions can be provided by:","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"Tiler: a rectangular grid which you specify by enclosing area, and the number of rows and columns\nPartition: a rectangular grid which you specify by enclosing area, and the width and height of each cell\nGrid and GridHex a rectangular or hexagonal grid, on demand\nTable: a rectangular grid which you specify by providing row and column numbers, row heights and column widths","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"These are types which act as iterators. Their job is to provide you with centerpoints; you'll probably want to use these in combination with the cell's widths and heights.","category":"page"},{"location":"tables-grids/#Tiles-and-partitions","page":"Tables and grids","title":"Tiles and partitions","text":"","category":"section"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"The drawing area (or any other area) can be divided into rectangular tiles (as rows and columns) using the Tiler and Partition iterators.","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"The Tiler iterator returns the center point and tile number of each tile in turn.","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"In this example, every third tile is divided up into subtiles and colored:","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"using Luxor, Random # hide\nDrawing(800, 500, \"assets/figures/tiler.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nRandom.seed!(1) # hide\nfontsize(20) # hide\ntiles = Tiler(800, 500, 4, 5, margin=5)\nfor (pos, n) in tiles\n    randomhue()\n    box(pos, tiles.tilewidth, tiles.tileheight, :fill)\n    if n % 3 == 0\n        gsave()\n        translate(pos)\n        subtiles = Tiler(tiles.tilewidth, tiles.tileheight, 4, 4, margin=5)\n        for (pos1, n1) in subtiles\n            randomhue()\n            box(pos1, subtiles.tilewidth, subtiles.tileheight, :fill)\n        end\n        grestore()\n    end\n    sethue(\"white\")\n    textcentered(string(n), pos + Point(0, 5))\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"(Image: tiler)","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"Partition is like Tiler, but you specify the width and height of the tiles, rather than how many rows and columns of tiles you want.","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"Tiler\nPartition","category":"page"},{"location":"tables-grids/#Luxor.Tiler","page":"Tables and grids","title":"Luxor.Tiler","text":"tiles = Tiler(areawidth, areaheight, nrows, ncols, margin=20)\n\nA Tiler is an iterator that, for each iteration, returns a tuple of:\n\nthe x/y point of the center of each tile in a set of tiles that divide up a rectangular space such as a page into rows and columns (relative to current 0/0)\nthe number of the tile\n\nareawidth and areaheight are the dimensions of the area to be tiled, nrows/ncols are the number of rows and columns required, and margin is applied to all four edges of the area before the function calculates the tile sizes required.\n\nTiler and Partition are similar:\n\nPartition lets you specify the width and height of a cell\nTiler lets you specify how many rows and columns of cells you want, and a margin:\n\ntiles = Tiler(1000, 800, 4, 5, margin=20)\nfor (pos, n) in tiles\n    # the point pos is the center of the tile\nend\n\nYou can access the calculated tile width and height like this:\n\ntiles = Tiler(1000, 800, 4, 5, margin=20)\nfor (pos, n) in tiles\n    ellipse(pos.x, pos.y, tiles.tilewidth, tiles.tileheight, :fill)\nend\n\nIt's sometimes useful to know which row and column you're currently on. tiles.currentrow and tiles.currentcol should have that information for you.\n\nTo use a Tiler to make grid points:\n\nfirst.(collect(Tiler(800, 800, 4, 4))\n\nwhich returns an array of points that are the center points of the grid.\n\n\n\n\n\n","category":"type"},{"location":"tables-grids/#Luxor.Partition","page":"Tables and grids","title":"Luxor.Partition","text":"p = Partition(areawidth, areaheight, tilewidth, tileheight)\n\nA Partition is an iterator that, for each iteration, returns a tuple of:\n\nthe x/y point of the center of each tile in a set of tiles that divide up a\n\nrectangular space such as a page into rows and columns (relative to current 0/0)\n\nthe number of the tile\n\nareawidth and areaheight are the dimensions of the area to be tiled, tilewidth/tileheight are the dimensions of the tiles.\n\nTiler and Partition are similar:\n\nPartition lets you specify the width and height of a cell\nTiler lets you specify how many rows and columns of cells you want, and a margin\n\ntiles = Partition(1200, 1200, 30, 30)\nfor (pos, n) in tiles\n    # the point pos is the center of the tile\nend\n\nYou can access the calculated tile width and height like this:\n\ntiles = Partition(1200, 1200, 30, 30)\nfor (pos, n) in tiles\n    ellipse(pos.x, pos.y, tiles.tilewidth, tiles.tileheight, :fill)\nend\n\nIt's sometimes useful to know which row and column you're currently on:\n\ntiles.currentrow\ntiles.currentcol\n\nshould have that information for you.\n\nUnless the tilewidth and tileheight are exact multiples of the area width and height, you'll see a border at the right and bottom where the tiles won't fit.\n\n\n\n\n\n","category":"type"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"You can obtain the centerpoints of all the tiles in one go with:","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"first.(collect(tiles))","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"or obtain ranges with:","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"tiles[1:2:end]","category":"page"},{"location":"tables-grids/#Tables","page":"Tables and grids","title":"Tables","text":"","category":"section"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"The Table iterator can be used to define tables: rectangular grids with a specific number of rows and columns.","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"Unlike a Tiler, the Table iterator lets you have columns can have different widths, and rows with different heights.","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"(Luxor generally tries to keep to the Julia convention of 'width' -> 'height', 'row' -> 'column'. This flavour of consistency can sometimes be confusing if you're expecting other kinds of consistency, such as 'x before y'...)","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"Tables don't store data, of course, but are designed to help you draw tabular data.","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"To create a simple table with 3 rows and 4 columns, using the default width and height (100):","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"julia> t = Table(3, 4);","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"When you use this as an iterator, you can get the coordinates of the center of each cell, and its number:","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"julia> for i in t\n           println(\"row: $(t.currentrow), column: $(t.currentcol), center: $(i[1])\")\n       end\nrow: 1, column: 1, center: Luxor.Point(-150.0, -100.0)\nrow: 1, column: 2, center: Luxor.Point(-50.0, -100.0)\nrow: 1, column: 3, center: Luxor.Point(50.0, -100.0)\nrow: 1, column: 4, center: Luxor.Point(150.0, -100.0)\nrow: 2, column: 1, center: Luxor.Point(-150.0, 0.0)\nrow: 2, column: 2, center: Luxor.Point(-50.0, 0.0)\nrow: 2, column: 3, center: Luxor.Point(50.0, 0.0)\nrow: 2, column: 4, center: Luxor.Point(150.0, 0.0)\nrow: 3, column: 1, center: Luxor.Point(-150.0, 100.0)\nrow: 3, column: 2, center: Luxor.Point(-50.0, 100.0)\nrow: 3, column: 3, center: Luxor.Point(50.0, 100.0)\nrow: 3, column: 4, center: Luxor.Point(150.0, 100.0)","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"You can also access row and column information:","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"julia> for r in 1:size(t)[1]\n           for c in 1:size(t)[2]\n               @show t[r, c]\n           end\n       end\nt[r, c] = Luxor.Point(-150.0, -100.0)\nt[r, c] = Luxor.Point(-50.0, -100.0)\nt[r, c] = Luxor.Point(50.0, -100.0)\nt[r, c] = Luxor.Point(150.0, -100.0)\nt[r, c] = Luxor.Point(-150.0, 0.0)\nt[r, c] = Luxor.Point(-50.0, 0.0)\nt[r, c] = Luxor.Point(50.0, 0.0)\nt[r, c] = Luxor.Point(150.0, 0.0)\nt[r, c] = Luxor.Point(-150.0, 100.0)\nt[r, c] = Luxor.Point(-50.0, 100.0)\nt[r, c] = Luxor.Point(50.0, 100.0)\nt[r, c] = Luxor.Point(150.0, 100.0)","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"The next example creates a table with 10 rows and 10 columns, where each cell is 50 units wide and 35 high.","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"using Luxor, Random # hide\nDrawing(600, 400, \"assets/figures/table2.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nRandom.seed!(42) # hide\nfontface(\"Helvetica-Bold\") # hide\nfontsize(20) # hide\nsethue(\"black\")\n\nt = Table(10, 10, 50, 35) # 10 rows, 10 columns, 50 wide, 35 high\n\nhundred = 1:100\n\nfor n in 1:length(t)\n   text(string(hundred[n]), t[n], halign=:center, valign=:middle)\nend\n\nsetopacity(0.5)\nsethue(\"thistle\")\ncircle.(t[3, :], 20, :fill) # row 3, every column\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"(Image: table 2)","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"You can access rows or columns in the usual Julian way.","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"Notice that the table is drawn row by row, whereas 2D Julia arrays are usually accessed column by column.","category":"page"},{"location":"tables-grids/#Varying-row-heights-and-column-widths","page":"Tables and grids","title":"Varying row heights and column widths","text":"","category":"section"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"To specify varying row heights and column widths, supply arrays or ranges to the Table constructor. The next example has logarithmically increasing row heights, and four columns of width 130 points:","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"using Luxor # hide\nDrawing(600, 400, \"assets/figures/table1.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\n\nt = Table(10 .^ range(0.7, length=25, stop=1.5), fill(130, 4))\n\nfor (pt, n) in t\n    setgray(rescale(n, 1, length(t), 0, 1))\n    box(pt, t.colwidths[t.currentcol], t.rowheights[t.currentrow], :fill)\n    sethue(\"white\")\n    fontsize(t.rowheights[t.currentrow])\n    text(string(n), pt, halign=:center, valign=:middle)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"(Image: table 1)","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"To fill table cells, it's useful to be able to access the table's row and column specifications (using the colwidths and rowheights fields), and iteration can also provide information about the current row and column being processed (currentrow and currentcol).","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"To ensure that graphic elements don't stray outside the cell walls, you can use a clipping region.","category":"page"},{"location":"tables-grids/#Drawing-arrays-and-dataframes","page":"Tables and grids","title":"Drawing arrays and dataframes","text":"","category":"section"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"With a little bit of extra work you can write code that draws objects like arrays and dataframes combining text with graphic features. For example, this code draws arrays visually and numerically.","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"using Luxor, Random # hide\nfunction drawbar(t::Table, data, row, column, minvalue, maxvalue, barheight)\n    setline(1.5)\n    cellwidth = t.colwidths[column] - 10\n    leftmargin = t[row, column] - (cellwidth/2, 0)\n    sethue(\"gray70\")\n    box(leftmargin - (0, barheight/2), leftmargin + (cellwidth, barheight/2), :fill)\n    boxwidth = rescale(data[row, column], minvalue, maxvalue, 0, cellwidth)\n    sethue(\"red\")\n    box(leftmargin - (0, barheight/2), leftmargin + (boxwidth, barheight/2), :fill)\n    sethue(\"black\")\n    line(leftmargin + (boxwidth, -barheight/2),\n         leftmargin + (boxwidth, +barheight/2),\n         :stroke)\n    text(string(round(data[row, column], digits=3)), t[row, column] - (cellwidth/2, 10),\n         halign=:left)\nend\n\nDrawing(700, 250, \"assets/figures/arraytable.svg\")  # hide\norigin() # hide\nbackground(\"white\") # hide\nRandom.seed!(42) # hide\nA = rand(6, 6)\nl, h = extrema(A)\nrt, ct = size(A)\nt = Table(size(A), (80, 30))\nfontface(\"Georgia\")\nfontsize(12)\nfor r in 1:rt\n    for c in 1:ct\n        drawbar(t, A, r, c, l, h, 10)\n    end\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"(Image: array table)","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"Table","category":"page"},{"location":"tables-grids/#Luxor.Table","page":"Tables and grids","title":"Luxor.Table","text":"t = Table(nrows, ncols)\nt = Table(nrows, ncols, colwidth, rowheight)\nt = Table(rowheights, columnwidths)\n\nTables are centered at O, but you can supply a point after the specifications.\n\nt = Table(nrows, ncols, centerpoint)\nt = Table(nrows, ncols, colwidth, rowheight, centerpoint)\nt = Table(rowheights, columnwidths, centerpoint)\n\nExamples\n\nSimple tables\n\nt = Table(4, 3) # 4 rows and 3 cols, default is 100w, 50 h\nt = Table(4, 3, 80, 30)   # 4 rows of 30pts high, 3 cols of 80pts wide\nt = Table(4, 3, (80, 30)) # same\nt = Table((4, 3), (80, 30)) # same\n\nSpecify row heights and column widths instead of quantities:\n\nt = Table([60, 40, 100], 50) # 3 different height rows, 1 column 50 wide\nt = Table([60, 40, 100], [100, 60, 40]) # 3 rows, 3 columns\nt = Table(fill(30, (10)), [50, 50, 50]) # 10 rows 30 high, 3 columns 10 wide\nt = Table(50, [60, 60, 60]) # just 1 row (50 high), 3 columns 60 wide\nt = Table([50], [50]) # just 1 row, 1 column, both 50 units wide\nt = Table(50, 50, 10, 5) # 50 rows, 50 columns, 10 units wide, 5 units high\nt = Table([6, 11, 16, 21, 26, 31, 36, 41, 46], [6, 11, 16, 21, 26, 31, 36, 41, 46])\nt = Table(15:5:55, vcat(5:2:15, 15:-2:5))\n #  table has 108 cells, with:\n #  row heights: 15 20 25 30 35 40 45 50 55\n #  col widths:  5 7 9 11 13 15 15 13 11 9 7 5\nt = Table(vcat(5:10:60, 60:-10:5), vcat(5:10:60, 60:-10:5))\nt = Table(vcat(5:10:60, 60:-10:5), 50) # 1 column 50 units wide\nt = Table(vcat(5:10:60, 60:-10:5), 1:5:50)\n\nA Table is an iterator that, for each iteration, returns a tuple of:\n\nthe x/y point of the center of cells arranged in rows and columns (relative to current 0/0)\nthe number of the cell (left to right, then top to bottom)\n\nnrows/ncols are the number of rows and columns required.\n\nIt's sometimes useful to know which row and column you're currently on while iterating:\n\nt.currentrow\nt.currentcol\n\nand row heights and column widths are available in:\n\nt.rowheights\nt.colwidths\n\nbox(t::Table, r, c) can be used to fill table cells:\n\n@svg begin\n    for (pt, n) in (t = Table(8, 3, 30, 15))\n        randomhue()\n        box(t, t.currentrow, t.currentcol, :fill)\n        sethue(\"white\")\n        text(string(n), pt)\n    end\nend\n\nor without iteration, using cellnumber:\n\n@svg begin\n    t = Table(8, 3, 30, 15)\n    for n in eachindex(t)\n        randomhue()\n        box(t, n, :fill)\n        sethue(\"white\")\n        text(string(n), t[n])\n    end\nend\n\nTo use a Table to make grid points:\n\njulia> first.(collect(Table(10, 6)))\n60-element Array{Luxor.Point,1}:\n Luxor.Point(-10.0, -18.0)\n Luxor.Point(-6.0, -18.0)\n Luxor.Point(-2.0, -18.0)\n ‚ãÆ\n Luxor.Point(2.0, 18.0)\n Luxor.Point(6.0, 18.0)\n Luxor.Point(10.0, 18.0)\n\nwhich returns an array of points that are the center points of the cells in the table.\n\n\n\n\n\n","category":"type"},{"location":"tables-grids/#Grids","page":"Tables and grids","title":"Grids","text":"","category":"section"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"You might also find a use for a grid. Luxor provides a simple grid utility. Grids are lazy: they'll supply the next point on the grid when you ask for it.","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"Define a rectangular grid with GridRect, and a hexagonal grid with GridHex. Get the next grid point from a grid with nextgridpoint(grid).","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"using Luxor, Random # hide\nDrawing(700, 250, \"assets/figures/grids.png\")  # hide\nbackground(\"white\") # hide\nfontsize(14) # hide\ntranslate(50, 50) # hide\nRandom.seed!(42) # hide\ngrid = GridRect(O, 40, 80, (10 - 1) * 40)\nfor i in 1:20\n    randomhue()\n    p = nextgridpoint(grid)\n    squircle(p, 20, 20, :fill)\n    sethue(\"white\")\n    text(string(i), p, halign=:center)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"(Image: grids)","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"using Luxor, Random # hide\nDrawing(700, 400, \"assets/figures/grid-hex.png\")  # hide\nbackground(\"white\") # hide\nfontsize(22) # hide\nRandom.seed!(42)\ntranslate(100, 100) # hide\nradius = 70\ngrid = GridHex(O, radius, 600)\n\nfor i in 1:15\n    randomhue()\n    p = nextgridpoint(grid)\n    ngon(p, radius-5, 6, œÄ/2, :fillstroke)\n    sethue(\"white\")\n    text(string(i), p, halign=:center)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"(Image: hex grid)","category":"page"},{"location":"tables-grids/","page":"Tables and grids","title":"Tables and grids","text":"GridRect\nGridHex\nnextgridpoint","category":"page"},{"location":"tables-grids/#Luxor.GridRect","page":"Tables and grids","title":"Luxor.GridRect","text":"GridRect(startpoint, xspacing, yspacing, width, height)\n\nDefine a rectangular grid, to start at startpoint and proceed along the x-axis in steps of xspacing, then along the y-axis in steps of yspacing.\n\nGridRect(startpoint, xspacing=100.0, yspacing=100.0, width=1200.0, height=1200.0)\n\nFor a column, set the xspacing to 0:\n\ngrid = GridRect(O, 0, 40)\n\nTo get points from the grid, use nextgridpoint(g::Grid).\n\njulia> grid = GridRect(O, 0, 40);\njulia> nextgridpoint(grid)\nLuxor.Point(0.0, 0.0)\n\njulia> nextgridpoint(grid)\nLuxor.Point(0.0, 40.0)\n\nWhen you run out of grid points, you'll wrap round and start again.\n\n\n\n\n\n","category":"type"},{"location":"tables-grids/#Luxor.GridHex","page":"Tables and grids","title":"Luxor.GridHex","text":"GridHex(startpoint, radius, width=1200.0, height=1200.0)\n\nDefine a hexagonal grid, to start at startpoint and proceed along the x-axis and then along the y-axis, radius is the radius of a circle that encloses each hexagon. The distance in x between the centers of successive hexagons is:\n\nfracsqrt(3) radius2\n\nTo get the next point from the grid, use nextgridpoint(g::Grid).\n\nWhen you run out of grid points, you'll wrap round and start again.\n\n\n\n\n\n","category":"type"},{"location":"tables-grids/#Luxor.nextgridpoint","page":"Tables and grids","title":"Luxor.nextgridpoint","text":"nextgridpoint(g::GridRect)\n\nReturns the next available (or even the first) grid point of a grid.\n\n\n\n\n\nnextgridpoint(g::GridHex)\n\nReturns the next available grid point of a hexagonal grid.\n\n\n\n\n\n","category":"function"},{"location":"clipping/","page":"Clipping","title":"Clipping","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"clipping/#Clipping","page":"Clipping","title":"Clipping","text":"","category":"section"},{"location":"clipping/","page":"Clipping","title":"Clipping","text":"Use clip() to turn the current path into a clipping region, masking any graphics outside the path. clippreserve() keeps the current path, but also uses it as a clipping region. clipreset() resets it. :clip is also an action for drawing functions like circle().","category":"page"},{"location":"clipping/","page":"Clipping","title":"Clipping","text":"using Luxor # hide\nDrawing(400, 250, \"assets/figures/simpleclip.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nsetline(3) # hide\nsethue(\"grey50\")\nsetdash(\"dotted\")\ncircle(O, 100, :stroke)\ncircle(O, 100, :clip)\nsethue(\"magenta\")\nbox(O, 125, 200, :fill)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"clipping/","page":"Clipping","title":"Clipping","text":"(Image: simple clip)","category":"page"},{"location":"clipping/","page":"Clipping","title":"Clipping","text":"clip\nclippreserve\nclipreset","category":"page"},{"location":"clipping/#Luxor.clip","page":"Clipping","title":"Luxor.clip","text":"clip()\n\nEstablish a new clipping region by intersecting the current clipping region with the current path and then clearing the current path.\n\nAn existing clipping region is enforced through and after a gsave()-grestore() block, but a clipping region set inside a gsave()-grestore() block is lost after grestore(). [?]\n\n\n\n\n\n","category":"function"},{"location":"clipping/#Luxor.clippreserve","page":"Clipping","title":"Luxor.clippreserve","text":"clippreserve()\n\nEstablish a new clipping region by intersecting the current clipping region with the current path, but keep the current path.\n\n\n\n\n\n","category":"function"},{"location":"clipping/#Luxor.clipreset","page":"Clipping","title":"Luxor.clipreset","text":"clipreset()\n\nReset the clipping region to the current drawing's extent.\n\n\n\n\n\n","category":"function"},{"location":"clipping/","page":"Clipping","title":"Clipping","text":"This example uses the built-in function that draws the Julia logo. The clip action lets you use the shapes as a mask for clipping subsequent graphics, which in this example are randomly-colored circles:","category":"page"},{"location":"clipping/","page":"Clipping","title":"Clipping","text":"(Image: julia logo mask)","category":"page"},{"location":"clipping/","page":"Clipping","title":"Clipping","text":"function draw(x, y)\n    foregroundcolors = Colors.diverging_palette(rand(0:360), rand(0:360), 200, s = 0.99, b=0.8)\n    gsave()\n    translate(x-100, y)\n    julialogo(action=:clip)\n    for i in 1:500\n        sethue(foregroundcolors[rand(1:end)])\n        circle(rand(-50:350), rand(0:300), 15, :fill)\n    end\n    grestore()\nend\n\ncurrentwidth = 500 # pts\ncurrentheight = 500 # pts\nDrawing(currentwidth, currentheight, \"/tmp/clipping-tests.pdf\")\norigin()\nbackground(\"white\")\nsetopacity(.4)\ndraw(0, 0)\nfinish()\npreview()","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"text/#Text-and-fonts","page":"Text","title":"Text and fonts","text":"","category":"section"},{"location":"text/#A-tale-of-two-APIs","page":"Text","title":"A tale of two APIs","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"There are two ways to draw text in Luxor. You can use either the so-called 'toy' API or the 'pro' API. Both have their advantages and disadvantages. Also, font selection and availability varies a lot across the three operating systems. You may have to experiment to find code patterns that work for you.","category":"page"},{"location":"text/#The-Toy-API","page":"Text","title":"The Toy API","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"Use:","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"text(string, [position]) to place text at a position, otherwise at 0/0, and optionally specify the horizontal and vertical alignment\nfontface(fontname) to specify the fontname\nfontsize(fontsize) to specify the fontsize","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor # hide\nDrawing(600, 100, \"assets/figures/toy-text-example.png\") # hide\norigin() # hide\nbackground(\"azure\") # hide\nsethue(\"black\") # hide\nfontsize(16)\nfontface(\"Georgia-Bold\")\ntext(\"Georgia: a serif typeface designed in 1993 by Matthew Carter.\", halign=:center)\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text placement)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(If the specified font is unavailable on the current system configuration, the default, usually Times/Helvetica or DejaVu, is used.)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"The label() function also uses the Toy API.","category":"page"},{"location":"text/#The-Pro-API","page":"Text","title":"The Pro API","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"Use:","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"setfont(fontname, fontsize) to specify the fontname and size\nsettext(text, [position]) to place the text at a position, and optionally specify horizontal and vertical alignment, rotation (in degrees counterclockwise!), and the presence of any pseudo-Pango-flavored markup.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor # hide\nDrawing(600, 100, \"assets/figures/pro-text-example.png\") # hide\norigin() # hide\nbackground(\"azure\") # hide\nsethue(\"black\") # hide\nsetfont(\"Georgia Bold\", 16)\nsettext(\"Georgia: a serif typeface designed in 1993 by Matthew Carter.\", halign=\"center\")\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text placement)","category":"page"},{"location":"text/#Specifying-the-font-(\"Toy\"-API)","page":"Text","title":"Specifying the font (\"Toy\" API)","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"Use fontface(fontname) to choose a font, and fontsize(n) to set the font size.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"fontface\nfontsize\nget_fontsize","category":"page"},{"location":"text/#Luxor.fontface","page":"Text","title":"Luxor.fontface","text":"fontface(fontname)\n\nSelect a font to use. (Toy API)\n\n\n\n\n\n","category":"function"},{"location":"text/#Luxor.fontsize","page":"Text","title":"Luxor.fontsize","text":"fontsize(n)\n\nSet the font size to n units. The default size is 10 units. (Toy API)\n\n\n\n\n\n","category":"function"},{"location":"text/#Luxor.get_fontsize","page":"Text","title":"Luxor.get_fontsize","text":"get_fontsize()\n\nReturn the font size set by fontsize or. more precisely. the y-scale of the Cairo font matrix if Cairo.set_font_matrix is used directly. (Toy API)\n\nThis only works if Cairo is at least at v1.0.5.\n\n\n\n\n\n","category":"function"},{"location":"text/#Specifying-the-font-(\"Pro\"-API)","page":"Text","title":"Specifying the font (\"Pro\" API)","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"To select a font in the Pro text API, use setfont() and supply both the font name and a size.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"setfont","category":"page"},{"location":"text/#Luxor.setfont","page":"Text","title":"Luxor.setfont","text":"setfont(family, fontsize)\n\nSelect a font and specify the size.\n\nExample:\n\nsetfont(\"Helvetica\", 24)\nsettext(\"Hello in Helvetica 24 using the Pro API\", Point(0, 10))\n\n\n\n\n\n","category":"function"},{"location":"text/#Placing-text-(\"Toy\"-API)","page":"Text","title":"Placing text (\"Toy\" API)","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"Use text() to place text.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor # hide\nDrawing(400, 150, \"assets/figures/text-placement.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nfontsize(80) # hide\nsethue(\"black\") # hide\npt1 = Point(-100, 0)\npt2 = Point(0, 0)\npt3 = Point(100, 0)\nsethue(\"black\")\ntext(\"1\",  pt1, halign=:left,   valign = :bottom)\ntext(\"2\",  pt2, halign=:center, valign = :bottom)\ntext(\"3\",  pt3, halign=:right,  valign = :bottom)\ntext(\"4\",  pt1, halign=:left,   valign = :top)\ntext(\"5\", pt2, halign=:center, valign = :top)\ntext(\"6\",  pt3, halign=:right,  valign = :top)\nsethue(\"red\")\nmap(p -> circle(p, 4, :fill), [pt1, pt2, pt3])\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text placement)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor # hide\nDrawing(400, 300, \"assets/figures/text-rotation.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"black\") # hide\nfontsize(10)\nfontface(\"Georgia\")\n[text(string(Œ∏), Point(40cos(Œ∏), 40sin(Œ∏)), angle=Œ∏) for Œ∏ in 0:œÄ/12:47œÄ/24]\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text rotation)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"text","category":"page"},{"location":"text/#Luxor.text","page":"Text","title":"Luxor.text","text":"text(str)\ntext(str, pos)\ntext(str, pos, angle=pi/2)\ntext(str, x, y)\ntext(str, pos, halign=:left)\ntext(str, valign=:baseline)\ntext(str, valign=:baseline, halign=:left)\ntext(str, pos, valign=:baseline, halign=:left)\n\nDraw the text in the string str at x/y or pt, placing the start of the string at the point. If you omit the point, it's placed at the current 0/0.\n\nangle specifies the rotation of the text relative to the current x-axis.\n\nHorizontal alignment halign can be :left, :center, (also :centre) or :right.  Vertical alignment valign can be :baseline, :top, :middle, or :bottom.\n\nThe default alignment is :left, :baseline.\n\nThis uses textextents() to query the dimensions of the text. This returns values of the built in to the font. You can't find\n\nThis uses Cairo's Toy text API.\n\n\n\n\n\n","category":"function"},{"location":"text/#Placing-text-(\"Pro\"-API)","page":"Text","title":"Placing text (\"Pro\" API)","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"Use settext() to place text. You can include some pseudo-HTML markup.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor # hide\nDrawing(400, 150, \"assets/figures/pro-text-placement.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nrulers()\nsethue(\"black\")\nsettext(\"<span font='26' background ='green' foreground='red'> Hey</span>\n    <i>italic</i> <b>bold</b> <sup>superscript</sup>\n    <tt>monospaced</tt>\",\n    halign=\"center\",\n    markup=true,\n    angle=10) # degrees counterclockwise!\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: pro text placement)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"settext","category":"page"},{"location":"text/#Luxor.settext","page":"Text","title":"Luxor.settext","text":"settext(text, pos;\n    halign = \"left\",\n    valign = \"bottom\",\n    angle  = 0, # degrees!\n    markup = false)\n\nsettext(text;\n    kwargs)\n\nDraw the text at pos (if omitted defaults to 0/0). If no font is specified, on macOS the default font is Times Roman.\n\nTo align the text, use halign, one of \"left\", \"center\", or \"right\", and valign, one of \"top\", \"center\", or \"bottom\".\n\nangle is the rotation - in counterclockwise degrees, rather than Luxor's default clockwise (+x-axis to +y-axis) radians.\n\nIf markup is true, then the string can contain some HTML-style markup. Supported tags include:\n\n<b>, <i>, <s>, <sub>, <sup>, <small>, <big>, <u>, <tt>, and <span>\n\nThe <span> tag can contains things like this:\n\n<span font='26' background='green' foreground='red'>unreadable text</span>\n\n\n\n\n\n","category":"function"},{"location":"text/#Notes-on-fonts","page":"Text","title":"Notes on fonts","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"Fonts are loaded when you first start using Luxor/Cairo in a Julia session. This partly explains why starting a Luxor/Cairo session can take a few seconds.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"On macOS, the fontname required by the Toy API's fontface() should be the PostScript name of a currently activated font. You can find this out using, for example, the FontBook application.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"On macOS, a list of currently activated fonts can be found (after a while) with the shell command:","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"system_profiler SPFontsDataType","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"Fonts currently activated by a Font Manager can be found and used by the Toy API but not by the Pro API (at least on my macOS computer currently).","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"On macOS, you can obtain a list of fonts that fontconfig considers are installed and available for use (via the Pro Text API with setfont()) using the shell command:","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"fc-list | cut -f 2 -d \":\"","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"although typically this lists only those fonts in /System/Library/Fonts and /Library/Fonts, and not ~/Library/Fonts.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(There is a Julia interface to fontconfig at Fontconfig.jl. See also FreeTypeAbstraction.jl)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"In the Pro API, the default font is Times Roman (on macOS). In the Toy API, the default font is Helvetica (on macOS).","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"One difference between settext() and text() (on macOS) is that many more missing Unicode glyphs are automatically substituted by other fonts when you use the former.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"Cairo.jl (and hence Luxor.jl) doesn't support emoji currently. üò¢","category":"page"},{"location":"text/#Text-to-paths","page":"Text","title":"Text to paths","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"textoutlines(string, position, action) converts the text into graphic path(s), places them starting at position, and applies the action.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor # hide\nDrawing(400, 400, \"assets/figures/textoutlines.png\") # hide\norigin() # hide\nfontface(\"Times-Roman\")\nfontsize(500)\nsetline(4)\nsethue(\"maroon2\")\ntextoutlines(\"&\", O, :path, valign=:middle, halign=:center)\nfillpreserve()\nsethue(\"black\")\nstrokepath()\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text outlines)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"textoutlines","category":"page"},{"location":"text/#Luxor.textoutlines","page":"Text","title":"Luxor.textoutlines","text":"textoutlines(s::AbstractString, pos::Point=O, action::Symbol=:none;\n    halign=:left,\n    valign=:baseline,\n    startnewpath=true)\n\nConvert text to a graphic path and apply action.\n\nBy default this function discards any current path, unless you use startnewpath=false\n\nSee also textpath().\n\n\n\n\n\n","category":"function"},{"location":"text/","page":"Text","title":"Text","text":"textpath() converts the text into graphic paths suitable for further manipulation.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"textpath","category":"page"},{"location":"text/#Luxor.textpath","page":"Text","title":"Luxor.textpath","text":"textpath(t)\n\nConvert the text in string t and adds closed paths to the current path, for subsequent filling/stroking etc...\n\nTypically you'll have to use pathtopoly() or getpath() or getpathflat() then work through the one or more path(s). Or use textoutlines().\n\n\n\n\n\n","category":"function"},{"location":"text/#Text-and-font-dimensions-(\"Toy\"-API-only)","page":"Text","title":"Text and font dimensions (\"Toy\" API only)","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"The textextents(str) function returns the dimensions of the string str, given the current font. There has to be a current drawing before this function is called.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"width and height are stored in elements 3 and 4. The first two elements are the offsets (\"bearings\") from the reference point (green) to the bounding box. The last two elements determine where the next (\"advance\") character should start (blue).","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: textextents)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"textextents","category":"page"},{"location":"text/#Luxor.textextents","page":"Text","title":"Luxor.textextents","text":"textextents(str)\n\nReturn an array of six Float64s containing the measurements of the string str when set using the current font settings (Toy API):\n\n1 x_bearing\n\n2 y_bearing\n\n3 width\n\n4 height\n\n5 x_advance\n\n6 y_advance\n\nThe x and y bearings are the displacement from the reference point to the upper-left corner of the bounding box. It is often zero or a small positive value for x displacement, but can be negative x for characters like \"j\"; it's almost always a negative value for y displacement.\n\nThe width and height then describe the size of the bounding box. The advance takes you to the suggested reference point for the next letter. Note that bounding boxes for subsequent blocks of text can overlap if the bearing is negative, or the advance is smaller than the width would suggest.\n\nExample:\n\ntextextents(\"R\")\n\nreturns\n\n[1.18652; -9.68335; 8.04199; 9.68335; 9.74927; 0.0]\n\n\n\n\n\n","category":"function"},{"location":"text/","page":"Text","title":"Text","text":"note: Note\nThere is currently no equivalent of this function for the \"Pro\" API.","category":"page"},{"location":"text/#Labels","page":"Text","title":"Labels","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"The label() function places text relative to a specific point, and you can use compass points or angles to indicate where it should be. So :N (for North) places a text label directly above the point, as does 3œÄ/2.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor # hide\nDrawing(400, 350, \"assets/figures/labels.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"black\")\nfontsize(15)\noctagon = ngon(O, 100, 8, 0, vertices=true)\n\ncompass = [:SE, :S, :SW, :W, :NW, :N, :NE, :E, :SE]\n\nfor i in 1:8\n    circle(octagon[i], 5, :fill)\n    label(string(compass[i]), compass[i], octagon[i], leader=true, leaderoffsets=[0.2, 0.9], offset=50)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: labels)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"label","category":"page"},{"location":"text/#Luxor.label","page":"Text","title":"Luxor.label","text":"label(txt::AbstractString, alignment::Symbol=:N, pos::Point=O;\n    offset=5,\n    leader=false,\n    leaderoffsets=[0.0, 1.0])\n\nAdd a text label at a point, positioned relative to that point, for example, :N signifies North and places the text directly above that point.\n\nUse one of :N, :S, :E, :W, :NE, :SE, :SW, :NW to position the label relative to that point.\n\nlabel(\"text\")          # positions text at North (above), relative to the origin\nlabel(\"text\", :S)      # positions text at South (below), relative to the origin\nlabel(\"text\", :S, pt)  # positions text South of pt\nlabel(\"text\", :N, pt, offset=20)  # positions text North of pt, offset by 20\n\nThe default offset is 5 units.\n\nIf leader is true, draw a line as well.\n\nleaderoffsts uses normalized fractions (see between()) to specify the gap between the designated points and the start and end of the lines.\n\nTODO: Negative offsets don't give good results.\n\n\n\n\n\nlabel(txt::AbstractString, rotation::Float64, pos::Point=O;\n    offset=5,\n    leader=false,\n    leaderoffsets=[0.0, 1.0])\n\nAdd a text label at a point, positioned relative to that point, for example, 0.0 is East, pi is West.\n\nlabel(\"text\", pi)          # positions text to the left of the origin\n\n\n\n\n\n","category":"function"},{"location":"text/#Text-on-a-curve","page":"Text","title":"Text on a curve","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"Use textcurve(str) to draw a string str on a circular arc or spiral.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor # hide\nDrawing(800, 800, \"assets/figures/text-spiral.png\") #¬†hide\n\norigin() #¬†hide\nbackground(\"ivory\") #¬†hide\nsethue(\"royalblue4\") #¬†hide\nfontsize(7)\nfontface(\"Menlo\")\ntextstring = join(names(Base), \" \")\ntextcurve(\"this spiral contains every word in julia names(Base): \" * textstring,\n    -œÄ/2,\n    350, 0, 0,\n    spiral_in_out_shift = -8.0,\n    letter_spacing = 0,\n    spiral_ring_step = 0)\nfontsize(35)\nfontface(\"Avenir-Black\")\ntextcentered(\"julia names(Base)\", 0, 0)\nfinish() #¬†hide\n\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text on a curve or spiral)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"For shorter strings, textcurvecentered() tries to place the text on a circular arc by its center point.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor # hide\nDrawing(400, 250, \"assets/figures/text-centered.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nfontface(\"Arial-Black\")\nfontsize(24) # hide\nsethue(\"black\") # hide\nsetdash(\"dot\") # hide\nsetline(0.25) # hide\ncircle(O, 100, :stroke)\ntextcurvecentered(\"hello world\", -œÄ/2, 100, O;\n    clockwise = true,\n    letter_spacing = 0,\n    baselineshift = -20\n    )\ntextcurvecentered(\"hello world\", œÄ/2, 100, O;\n    clockwise = false,\n    letter_spacing = 0,\n    baselineshift = 10\n    )\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text centered on curve)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"textcurve\ntextcurvecentered","category":"page"},{"location":"text/#Luxor.textcurve","page":"Text","title":"Luxor.textcurve","text":"textcurve(the_text, start_angle, start_radius, x_pos = 0, y_pos = 0;\n      # optional keyword arguments:\n      spiral_ring_step = 0,    # step out or in by this amount\n      letter_spacing = 0,      #¬†tracking/space between chars, tighter is (-), looser is (+)\n      spiral_in_out_shift = 0, # + values go outwards, - values spiral inwards\n      clockwise = true\n      )\n\nPlace a string of text on a curve. It can spiral in or out.\n\nstart_angle is relative to +ve x-axis, arc/circle is centered on (x_pos,y_pos) with radius start_radius.\n\n\n\n\n\n","category":"function"},{"location":"text/#Luxor.textcurvecentered","page":"Text","title":"Luxor.textcurvecentered","text":"textcurvecentered(the_text, the_angle, the_radius, center::Point;\n      clockwise = true,\n      letter_spacing = 0,\n      baselineshift = 0\n\nThis version of the textcurve() function is designed for shorter text strings that need positioning around a circle. (A cheesy effect much beloved of hipster brands and retronauts.)\n\nletter_spacing adjusts the tracking/space between chars, tighter is (-), looser is (+)).  baselineshift moves the text up or down away from the baseline.\n\ntextcurvecentred (UK spelling) is a synonym\n\n\n\n\n\n","category":"function"},{"location":"text/#Text-clipping","page":"Text","title":"Text clipping","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"You can use newly-created text paths as a clipping region - here the text paths are filled with names of randomly chosen Julia functions:","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text clipping)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor\n\ncurrentwidth = 1250 # pts\ncurrentheight = 800 # pts\nDrawing(currentwidth, currentheight, \"/tmp/text-path-clipping.png\")\n\norigin()\nbackground(\"darkslategray3\")\n\nfontsize(600)                             #¬†big fontsize to use for clipping\nfontface(\"Agenda-Black\")\nstr = \"julia\"                             # string to be clipped\nw, h = textextents(str)[3:4]              #¬†get width and height\n\ntranslate(-(currentwidth/2) + 50, -(currentheight/2) + h)\n\ntextpath(str)                             #¬†make text into a path\nsetline(3)\nsetcolor(\"black\")\nfillpreserve()                            # fill but keep\nclip()                                    # and use for clipping region\n\nfontface(\"Monaco\")\nfontsize(10)\nnamelist = map(x->string(x), names(Base)) #¬†get list of function names in Base.\n\nlet\n    x = -20\n    y = -h\n    while y < currentheight\n        sethue(rand(7:10)/10, rand(7:10)/10, rand(7:10)/10)\n        s = namelist[rand(1:end)]\n        text(s, x, y)\n        se = textextents(s)\n        x += se[5]                            # move to the right\n        if x > w\n            x = -20                            # next row\n            y += 10\n        end\n    end\nend\n\nfinish()\npreview()","category":"page"},{"location":"text/#Text-blocks,-boxes,-and-wrapping","page":"Text","title":"Text blocks, boxes, and wrapping","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"Longer lines of text can be made to wrap inside an imaginary rectangle with textwrap(). Specify the required width of the rectangle, and the location of the top left corner.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"\nusing Luxor # hide\nDrawing(500, 400, \"assets/figures/text-wrapping.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nfontface(\"Georgia\")\nfontsize(12) # hide\nsethue(\"black\") # hide\n\nloremipsum = \"\"\"Lorem ipsum dolor sit amet, consectetur\nadipiscing elit. Nunc placerat lorem ullamcorper,\nsagittis massa et, elementum dui. Sed dictum ipsum vel\ncommodo pellentesque. Aliquam erat volutpat. Nam est\ndolor, vulputate a molestie aliquet, rutrum quis lectus.\nSed lectus mauris, tristique et tempor id, accumsan\npharetra lacus. Donec quam magna, accumsan a quam\nquis, mattis hendrerit nunc. Nullam vehicula leo ac\nleo tristique, a condimentum tortor faucibus.\"\"\"\n\nsetdash(\"dot\")\nbox(O, 200, 200, :stroke)\ntextwrap(loremipsum, 200, O - (200/2, 200/2))\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text wrapping)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"textwrap() accepts a function that allows you to insert code that responds to the next line's linenumber, contents, position, and height.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor, Colors # hide\nDrawing(500, 400, \"assets/figures/text-wrapping-1.png\") # hide\norigin() # hide\nbackground(\"white\") # hide\nfontface(\"Georgia\")\nfontsize(12) # hide\nsethue(\"black\") # hide\n\nloremipsum = \"\"\"Lorem ipsum dolor sit amet, consectetur\nadipiscing elit. Nunc placerat lorem ullamcorper,\nsagittis massa et, elementum dui. Sed dictum ipsum vel\ncommodo pellentesque. Aliquam erat volutpat. Nam est\ndolor, vulputate a molestie aliquet, rutrum quis lectus.\nSed lectus mauris, tristique et tempor id, accumsan\npharetra lacus. Donec quam magna, accumsan a quam\nquis, mattis hendrerit nunc. Nullam vehicula leo ac\nleo tristique, a condimentum tortor faucibus.\"\"\"\n\ntextwrap(loremipsum, 200, O - (200/2, 200/2),\n    (lnumber, str, pt, l) -> begin\n        sethue(Colors.HSB(rescale(lnumber, 1, 15, 0, 360), 1, 1))\n        text(string(\"line \", lnumber), pt - (50, 0))\n    end)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: text wrapped)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"The textbox() function also draws text inside a box, but doesn't alter the lines, and doesn't force the text to a specific width. Supply an array of strings and the top left position. The leading argument specifies the distance between the lines, so should be set relative to the current font size (as set with fontsize()).","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"This example counts the number of characters drawn, using a simple closure. The function returns the position of the start of what would have been the next line.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor, Colors # hide\nDrawing(600, 300, \"assets/figures/textbox.png\") # hide\norigin() # hide\nbackground(\"ivory\") # hide\nsethue(\"black\") # hide\nfontface(\"Georgia\")\nfontsize(30)\n\nloremipsum = \"\"\"Lorem ipsum dolor sit amet, consectetur\nadipiscing elit. Nunc placerat lorem ullamcorper,\nsagittis massa et, elementum dui. Sed dictum ipsum vel\ncommodo pellentesque. Aliquam erat volutpat. Nam est\ndolor, vulputate a molestie aliquet, rutrum quis lectus.\nSed lectus mauris, tristique et tempor id, accumsan\npharetra lacus. Donec quam magna, accumsan a quam\nquis, mattis hendrerit nunc. Nullam vehicula leo ac\nleo tristique, a condimentum tortor faucibus.\"\"\"\n\n_counter() = (a = 0; (n) -> a += n)\ncounter = _counter()\n\ntranslate(boxtopleft(BoundingBox()))\nfontface(\"Georgia\")\nfontsize(20)\n\nfinishpos = textbox(filter(!isempty, split(loremipsum, \"\\n\")),\n    O + (5, 0),\n    leading = 28,\n    linefunc = (lnumber, str, pt, h) -> begin\n        text(string(lnumber), pt - (30, 0))\n        counter(length(str))\n    end)\n\nfontsize(10)\ntext(string(counter(0), \" characters\"), finishpos)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: textbox)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"textwrap\ntextbox\nsplittext","category":"page"},{"location":"text/#Luxor.textwrap","page":"Text","title":"Luxor.textwrap","text":"textwrap(s::T where T<:AbstractString, width::Real, pos::Point;\n    rightgutter=5,\n    leading=0)\ntextwrap(s::T where T<:AbstractString, width::Real, pos::Point, linefunc::Function;\n    rightgutter=5,\n    leading=0)\n\nDraw the string in s by splitting it at whitespace characters into lines, so that each line is no longer than width units. The text starts at pos such that the first line of text is drawn entirely below a line drawn horizontally through that position. Each line is aligned on the left side, below pos.\n\nSee also textbox().\n\nOptionally, before each line, execute the function linefunc(linenumber, linetext, startpos, leading).\n\nIf you don't supply a value for leading, the font's built-in extents are used.\n\nText with no whitespace characters won't wrap. You can write a simple chunking function to split a string or array into chunks:\n\nchunk(x, n) = [x[i:min(i+n-1,length(x))] for i in 1:n:length(x)]\n\nFor example:\n\ntextwrap(the_text, 300, boxtopleft(BoundingBox()) + 20,\n    (ln, lt, sp, ht) -> begin\n        c = count(t -> occursin(r\"[[:punct:]]\", t), split(lt, \"\"))\n        @layer begin\n            fontface(\"Menlo\")\n            sethue(\"darkred\")\n            text(string(\"[\", c, \"]\"), sp + (310, 0))\n        end\n    end)\n\nputs a count of the number of punctuation characters in each line at the end of the line.\n\nReturns the position of what would have been the next line.\n\n\n\n\n\n","category":"function"},{"location":"text/#Luxor.textbox","page":"Text","title":"Luxor.textbox","text":"textbox(lines::Array, pos::Point=O;\n    leading = 12,\n    linefunc::Function = (linenumber, linetext, startpos, height) -> (),\n    alignment=:left)\n\nDraw the strings in the array lines vertically downwards. leading controls the spacing between each line (default 12), and alignment determines the horizontal alignment (default :left).\n\nOptionally, before each line, execute the function linefunc(linenumber, linetext, startpos, height).\n\nReturns the position of what would have been the next line.\n\nSee also textwrap(), which modifies the text so that the lines fit into a specified width.\n\n\n\n\n\ntextbox(s::AbstractString, pos::Point=O;\n    leading = 12,\n    linefunc::Function = (linenumber, linetext, startpos, height) -> (),\n    alignment=:left)\n\n\n\n\n\n","category":"function"},{"location":"text/#Luxor.splittext","page":"Text","title":"Luxor.splittext","text":"splittext(s)\n\nSplit the text in string s into an array, but keep all the separators attached to the preceding word.\n\n\n\n\n\n","category":"function"},{"location":"text/#Text-tracking","page":"Text","title":"Text tracking","text":"","category":"section"},{"location":"text/","page":"Text","title":"Text","text":"Use texttrack() to track or letter-space text, i.e. vary the spacing between every letter. (\"Kerning\" is when you do this for just a pair of letters.) The units are 1/1000 em, so the actual distance of \"50 units of tracking\" varies depending on the current font size.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"But really, don‚Äôt track text unless you have to.","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"using Luxor # hide\nDrawing(600, 600, \"assets/figures/texttrack.svg\") # hide\norigin() # hide\nbackground(\"white\") # hide\nsethue(\"black\") # hide\n\nfunction text_tracking_example()\n    fonts = [\n        \"Verdana\",\n        \"TrebuchetMS\",\n        \"Times-Roman\",\n        \"Georgia\",\n        \"Monaco\"]\n    fsize = 16\n    grid = GridRect(boxtopleft(BoundingBox() * 0.9), 0, 20)\n    tracking = 50\n    for f in fonts\n        fontsize(fsize)\n        fontface(f)\n        texttrack(\"This is some text in $(f): it‚Äôs been tracked by +$(tracking)\",\n            nextgridpoint(grid), tracking, fsize)\n        text(\"This is some text in $(f): it‚Äôs not been tracked\",\n            nextgridpoint(grid))\n        texttrack(\"This is some text in $(f): it‚Äôs been tracked by -$(tracking)\",\n            nextgridpoint(grid), -tracking, fsize)\n    end\n\n    finish() # hide\nend\n\ntext_tracking_example()\nnothing # hide","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"(Image: textbox)","category":"page"},{"location":"text/","page":"Text","title":"Text","text":"texttrack","category":"page"},{"location":"text/#Luxor.texttrack","page":"Text","title":"Luxor.texttrack","text":"texttrack(txt, pos, tracking, fontsize=12)\n\nPlace the text in txt at pos, left-justified, and letter space ('track') the text using the value in tracking.\n\nThe tracking units depend on the current font size! 1 is 1/1000 em. In a 6‚Äëpoint font, 1 em equals 6 points; in a 10‚Äëpoint font, 1 em equals 10 points.\n\nA value of -50 would tighten the letter spacing noticeably. A value of 50 would make the text more open.\n\n\n\n\n\n","category":"function"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"transforms/#Transforms-and-matrices","page":"Transforms and matrices","title":"Transforms and matrices","text":"","category":"section"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"For basic transformations of the drawing space, use scale(sx, sy), rotate(a), and translate(tx, ty).","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"translate(pos) (or translate(x, y)) shifts the current axes to pos (or by the specified amounts in x and y). It's relative and cumulative, rather than absolute:","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor, Colors, Random # hide\nDrawing(600, 200, \"assets/figures/translate.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(1) # hide\nsetline(1) # hide\norigin()\nfor i in range(0, step=30, length=6)\n    sethue(HSV(i, 1, 1)) # from Colors\n    setopacity(0.5)\n    circle(0, 0, 40, :fillpreserve)\n    setcolor(\"black\")\n    strokepath()\n    translate(50, 0)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"(Image: translate)","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"scale(x, y) or scale(n) scales the current workspace by the specified amounts. Again, it's relative to the current scale, not to the document's original.","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor, Colors, Random # hide\nDrawing(400, 200, \"assets/figures/scale.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(1) # hide\nsetline(1) # hide\norigin()\nfor i in range(0, step=30, length=6)\n    sethue(HSV(i, 1, 1)) # from Colors\n    circle(0, 0, 90, :fillpreserve)\n    setcolor(\"black\")\n    strokepath()\n    scale(0.8, 0.8)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"(Image: scale)","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"rotate() rotates the current workspace by the specified amount about the current 0/0 point. It's relative to the previous rotation, not to the document's original.","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor, Random # hide\nDrawing(400, 200, \"assets/figures/rotate.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(1) # hide\nsetline(1) # hide\norigin()\nsetopacity(0.7) # hide\nfor i in 1:8\n    randomhue()\n    squircle(Point(40, 0), 20, 30, :fillpreserve)\n    sethue(\"black\")\n    strokepath()\n    rotate(œÄ/4)\nend\nfinish() # hide\nnothing # hide","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"(Image: rotate)","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"To return home after many changes, you can use setmatrix([1, 0, 0, 1, 0, 0]) to reset the matrix to the default. origin() resets the matrix then moves the origin to the center of the page.","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"rescale() is a convenient utility function for linear interpolation (also called a \"lerp\").","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"scale\nrotate\ntranslate","category":"page"},{"location":"transforms/#Luxor.scale","page":"Transforms and matrices","title":"Luxor.scale","text":"scale(x, y)\n\nScale workspace by x and y.\n\nExample:\n\nscale(0.2, 0.3)\n\n\n\n\n\nscale(f)\n\nScale workspace by f in both x and y.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.rotate","page":"Transforms and matrices","title":"Luxor.rotate","text":"rotate(a::Float64)\n\nRotate workspace by a radians clockwise (from positive x-axis to positive y-axis).\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.translate","page":"Transforms and matrices","title":"Luxor.translate","text":"translate(point)\ntranslate(x::Real, y::Real)\n\nTranslate the workspace to x and y or to pt.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Scaling-of-lines","page":"Transforms and matrices","title":"Scaling of lines","text":"","category":"section"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"Line thicknesses are not scaled. For example, with a line thickness set by setline(1), lines drawn before and after scale(2) will be the same thickness. If you want line thicknesses to respond to the current scale, so that after say setline(1), lines change thickness after calls to scale(n), you could define your own strokeraw() function that calls the cairo_stroke primitive directly:","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"import Cairo\nfunction strokeraw()\n    ccall((:cairo_stroke, Cairo._jl_libcairo), Nothing, (Ptr{Nothing},), Luxor.get_current_cr().ptr)\nend","category":"page"},{"location":"transforms/#Matrices-and-transformations","page":"Transforms and matrices","title":"Matrices and transformations","text":"","category":"section"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"In Luxor, there's always a current matrix. It's a six element array:","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"beginbmatrix\n1  0  0 \n0  1  0 \nendbmatrix","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"which is usually handled in Julia/Cairo/Luxor as a simple vector/array:","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"julia> getmatrix()\n6-element Array{Float64,1}:\n   1.0\n   0.0\n   0.0\n   1.0\n   0.0\n   0.0","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"transform(a) transforms the current workspace by 'multiplying' the current matrix with matrix a. For example, transform([1, 0, xskew, 1, 50, 0]) skews the current matrix by xskew radians and moves it 50 in x and 0 in y.","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor # hide\nfname = \"assets/figures/transform.png\" # hide\npagewidth, pageheight = 450, 100 # hide\nDrawing(pagewidth, pageheight, fname) # hide\norigin() # hide\nbackground(\"white\") # hide\ntranslate(-200, 0) # hide\n\nfunction boxtext(p, t)\n    sethue(\"grey30\")\n    box(p, 30, 50, :fill)\n    sethue(\"white\")\n    textcentered(t, p)\nend\n\nfor i in 0:5\n    xskew = tand(i * 5.0)\n    transform([1, 0, xskew, 1, 50, 0])\n    boxtext(O, string(round(rad2deg(xskew), digits=1), \"¬∞\"))\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"(Image: transform)","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"getmatrix() gets the current matrix, setmatrix(a) sets the matrix to array a.","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"getmatrix\nsetmatrix\ntransform\ncrossproduct\nblendmatrix\nrotationmatrix\nscalingmatrix\ntranslationmatrix","category":"page"},{"location":"transforms/#Luxor.getmatrix","page":"Transforms and matrices","title":"Luxor.getmatrix","text":"getmatrix()\n\nGet the current matrix. Returns an array of six float64 numbers:\n\nxx component of the affine transformation\nyx component of the affine transformation\nxy component of the affine transformation\nyy component of the affine transformation\nx0 translation component of the affine transformation\ny0 translation component of the affine transformation\n\nSome basic matrix transforms:\n\ntranslate\n\ntransform([1, 0, 0, 1, dx, dy]) shifts by dx, dy\n\nscale\n\ntransform([fx 0 0 fy 0 0]) scales by fx and fy\n\nrotate\n\ntransform([cos(a), -sin(a), sin(a), cos(a), 0, 0]) rotates around to a radians\n\nrotate around O: [c -s s c 0 0]\n\nshear\n\ntransform([1 0 a 1 0 0]) shears in x direction by a\n\nshear in y direction by a: [1 a 0 1 0 0]\n\nx-skew\n\ntransform([1, 0, tan(a), 1, 0, 0]) skews in x by a\n\ny-skew\n\ntransform([1, tan(a), 0, 1, 0, 0]) skews in y by a\n\nflip\n\ntransform([fx, 0, 0, fy, centerx * (1 - fx), centery * (fy-1)]) flips with center at centerx/centery\n\nreflect\n\ntransform([1 0 0 -1 0 0]) reflects in xaxis\n\ntransform([-1 0 0 1 0 0]) reflects in yaxis\n\nWhen a drawing is first created, the matrix looks like this:\n\ngetmatrix() = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]\n\nWhen the origin is moved to 400/400, it looks like this:\n\ngetmatrix() = [1.0, 0.0, 0.0, 1.0, 400.0, 400.0]\n\nTo reset the matrix to the original:\n\nsetmatrix([1.0, 0.0, 0.0, 1.0, 0.0, 0.0])\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.setmatrix","page":"Transforms and matrices","title":"Luxor.setmatrix","text":"setmatrix(m::Array)\n\nChange the current matrix to matrix m. Use getmatrix() to get the current matrix.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.transform","page":"Transforms and matrices","title":"Luxor.transform","text":"transform(a::Array)\n\nModify the current matrix by multiplying it by matrix a.\n\nFor example, to skew the current state by 45 degrees in x and move by 20 in y direction:\n\ntransform([1, 0, tand(45), 1, 0, 20])\n\nUse getmatrix() to get the current matrix.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.crossproduct","page":"Transforms and matrices","title":"Luxor.crossproduct","text":"crossproduct(p1::Point, p2::Point)\n\nThis is the perp dot product, really, not the crossproduct proper (which is 3D):\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.blendmatrix","page":"Transforms and matrices","title":"Luxor.blendmatrix","text":"blendmatrix(b::Blend, m)\n\nSet the matrix of a blend.\n\nTo apply a sequence of matrix transforms to a blend:\n\nA = [1 0 0 1 0 0]\nAj = cairotojuliamatrix(A)\nSj = scalingmatrix(2, .2) * Aj\nTj = translationmatrix(10, 0) * Sj\nA1 = juliatocairomatrix(Tj)\nblendmatrix(b, As)\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.rotationmatrix","page":"Transforms and matrices","title":"Luxor.rotationmatrix","text":"rotationmatrix(a)\n\nReturn a 3x3 Julia matrix that will apply a rotation through a radians.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.scalingmatrix","page":"Transforms and matrices","title":"Luxor.scalingmatrix","text":"scalingmatrix(sx, sy)\n\nReturn a 3x3 Julia matrix that will apply a scaling by sx and sy.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.translationmatrix","page":"Transforms and matrices","title":"Luxor.translationmatrix","text":"translationmatrix(x, y)\n\nReturn a 3x3 Julia matrix that will apply a translation in x and y.\n\n\n\n\n\n","category":"function"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"Use the getscale(), gettranslation(), and getrotation() functions to find the current values of the current matrix. These can also find the values of arbitrary 3x3 matrices.","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"getscale\ngettranslation\ngetrotation","category":"page"},{"location":"transforms/#Luxor.getscale","page":"Transforms and matrices","title":"Luxor.getscale","text":"getscale(R::Matrix)\ngetscale()\n\nGet the current scale of a Julia 3x3 matrix, or the current Luxor scale.\n\nReturns a tuple of x and y values.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.gettranslation","page":"Transforms and matrices","title":"Luxor.gettranslation","text":"gettranslation(R::Matrix)\ngettranslation()\n\nGet the current translation of a Julia 3x3 matrix, or the current Luxor translation.\n\nReturns a tuple of x and y values.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.getrotation","page":"Transforms and matrices","title":"Luxor.getrotation","text":"getrotation(R::Matrix)\ngetrotation()\n\nGet the rotation of a Julia 3x3 matrix, or the current Luxor rotation.\n\nbeginbmatrix\na  b  tx \nc  d  ty \n0  0  1  \nendbmatrix\n\nThe rotation angle is atan(-b, a) or atan(c, d).\n\n\n\n\n\n","category":"function"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"You can convert between the 6-element and 3x3 versions of a transformation matrix using the functions cairotojuliamatrix() and juliatocairomatrix().","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"cairotojuliamatrix\njuliatocairomatrix","category":"page"},{"location":"transforms/#Luxor.cairotojuliamatrix","page":"Transforms and matrices","title":"Luxor.cairotojuliamatrix","text":"cairotojuliamatrix(c)\n\nReturn a 3x3 Julia matrix that's the equivalent of the six-element matrix in c.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#Luxor.juliatocairomatrix","page":"Transforms and matrices","title":"Luxor.juliatocairomatrix","text":"juliatocairomatrix(c)\n\nReturn a six-element matrix that's the equivalent of the 3x3 Julia matrix in c.\n\n\n\n\n\n","category":"function"},{"location":"transforms/#World-position","page":"Transforms and matrices","title":"World position","text":"","category":"section"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"If you use translate() to move the origin to different places on a drawing, you can use getworldposition() to find the \"true\" world coordinates of points. In the following example, we temporarily translate to a random point, and \"drop a pin\" that remembers the new origin in terms of the drawing's world coordinates. After the temporary translation is over, we have a record of where it was.","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"using Luxor, Random # hide\nDrawing(600, 400, \"assets/figures/getworldposition.png\") # hide\nbackground(\"white\") # hide\nRandom.seed!(3) # hide\nsetline(1) # hide\norigin()\n\n@layer begin\n    translate(0.7rand(BoundingBox()))\n    pin = getworldposition()\nend\n\nlabel(\"you went ... \", :n, O, offset = 10)\nlabel(\"... here\", :n, pin, offset = 20)\narrow(O, pin)\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"(Image: translate)","category":"page"},{"location":"transforms/","page":"Transforms and matrices","title":"Transforms and matrices","text":"getworldposition","category":"page"},{"location":"transforms/#Luxor.getworldposition","page":"Transforms and matrices","title":"Luxor.getworldposition","text":"getworldposition(pt::Point = O;\n    centered=true)\n\nReturn the world coordinates of pt.\n\nThe default coordinate system for Luxor/Cairo is that the top left corner is 0/0. If you use origin(), everything moves to the center of the drawing, and this function with the default centered option assumes an origin() function. If you choose centered=false, the returned coordinates will be relative to the top left corner of the drawing.\n\norigin()\ntranslate(120, 120)\n@show currentpoint()      # => Point(0.0, 0.0)\n@show getworldposition()  # => Point(120.0, 120.0)\n\n\n\n\n\n","category":"function"},{"location":"functionindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"functionindex/","page":"Index","title":"Index","text":"","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"examples/#Examples","page":"A few examples","title":"Examples","text":"","category":"section"},{"location":"examples/#The-obligatory-\"Hello-World\"","page":"A few examples","title":"The obligatory \"Hello World\"","text":"","category":"section"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"Here's the \"Hello world\":","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"(Image: \"Hello world\")","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"using Luxor\nDrawing(1000, 1000, \"hello-world.png\")\norigin()\nbackground(\"black\")\nsethue(\"red\")\nfontsize(50)\ntext(\"hello world\")\nfinish()\npreview()","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"Drawing(1000, 1000, \"hello-world.png\") defines the width, height, location, and type of the finished image. origin() moves the 0/0 point to the centre of the drawing surface (by default it's at the top left corner). Thanks to Colors.jl we can specify colors by name as well as by numeric value: background(\"black\") defines the color of the background of the drawing. text(\"helloworld\") draws the text. It's placed at the current 0/0 point and left-justified if you don't specify otherwise. finish() completes the drawing and saves the PNG image in the file. preview() tries to display the saved file, perhaps using another application (eg Preview on macOS).","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"The macros @png, @svg, @pdf, @draw, and @imagematrix provide shortcuts for making and previewing graphics without you having to provide the usual set-up and finish instructions:","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"# using Luxor\n\n@png begin\n        fontsize(50)\n        circle(Point(0, 0), 150, :stroke)\n        text(\"hello world\", halign=:center, valign=:middle)\n     end","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"(Image: background)","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"@svg begin\n    sethue(\"red\")\n    randpoint = Point(rand(-200:200), rand(-200:200))\n    circle(randpoint, 2, :fill)\n    sethue(\"black\")\n    foreach(f -> arrow(f, between(f, randpoint, .1), arrowheadlength=6),\n        first.(collect(Table(fill(20, 15), fill(20, 15)))))\nend","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"(Image: background)","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"The @draw macro is useful if you work in Juno/VS Code IDEs or a notebook environment such as Jupyter or Pluto and don't need to always save your work in files. It creates a PNG format drawing in memory, rather than saved in a file. It's displayed in the plot pane or in the next cell.","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"@draw begin\n    setopacity(0.85)\n    steps = 20\n    gap   = 2\n    for (n, Œ∏) in enumerate(range(0, step=2œÄ/steps, length=steps))\n        sethue([Luxor.julia_green,\n            Luxor.julia_red,\n            Luxor.julia_purple,\n            Luxor.julia_blue][mod1(n, 4)])\n        sector(Point(0, 0), 50, 250 + 2n, Œ∏, Œ∏ + 2œÄ/steps - deg2rad(gap), :fill)\n    end\nend","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"(Image: background)","category":"page"},{"location":"examples/#The-Julia-logos","page":"A few examples","title":"The Julia logos","text":"","category":"section"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"Luxor contains built-in functions that draw the Julia logo, either in color or a single color, and the three Julia circles.","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"using Luxor\nDrawing(600, 400, \"assets/figures/julia-logos.png\")\norigin()\nbackground(\"white\")\n\nfor Œ∏ in range(0, step=œÄ/8, length=16)\n    gsave()\n    scale(0.2)\n    rotate(Œ∏)\n    translate(350, 0)\n    julialogo(action=:fill, bodycolor=randomhue())\n    grestore()\nend\n\ngsave()\nscale(0.3)\njuliacircles()\ngrestore()\n\ntranslate(150, -150)\nscale(0.3)\njulialogo()\nfinish()\n\n# preview()\nnothing # hide","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"(Image: background)","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"The gsave() function saves the current drawing environment temporarily, and any subsequent changes such as the scale() and rotate() operations are discarded when you call the next grestore() function.","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"Use the extension to specify the format: for example, change julia-logos.png to julia-logos.svg or julia-logos.pdf or julia-logos.eps to produce SVG, PDF, or EPS format output.","category":"page"},{"location":"examples/#Something-a-bit-more-complicated:-a-Sierpinski-triangle","page":"A few examples","title":"Something a bit more complicated: a Sierpinski triangle","text":"","category":"section"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"Here's a version of the Sierpinski recursive triangle, clipped to a circle.","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"(Image: Sierpinski)","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"# Subsequent examples will omit these setup and finishing functions:\n#\n# using Luxor, Colors\n# Drawing()\n# background(\"white\")\n# origin()\n\nfunction triangle(points, degree)\n    sethue(cols[degree])\n    poly(points, :fill)\nend\n\nfunction sierpinski(points, degree)\n    triangle(points, degree)\n    if degree > 1\n        p1, p2, p3 = points\n        sierpinski([p1, midpoint(p1, p2),\n                        midpoint(p1, p3)], degree-1)\n        sierpinski([p2, midpoint(p1, p2),\n                        midpoint(p2, p3)], degree-1)\n        sierpinski([p3, midpoint(p3, p2),\n                        midpoint(p1, p3)], degree-1)\n    end\nend\n\nfunction draw(n)\n    circle(Point(0, 0), 75, :clip)\n    points = ngon(Point(0, 0), 150, 3, -œÄ/2, vertices=true)\n    sierpinski(points, n)\nend\n\ndepth = 8 #¬†12 is ok, 20 is right out (on my computer, at least)\ncols = distinguishable_colors(depth) # from Colors.jl\ndraw(depth)\n\n# finish()\n# preview()","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"The Point type is an immutable composite type containing x and y fields that specify a 2D point.","category":"page"},{"location":"examples/#Working-in-IDEs-and-notebooks","page":"A few examples","title":"Working in IDEs and notebooks","text":"","category":"section"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"You can use an environment such as a Jupyter or Pluto notebook or the Juno or VS Code IDEs, and load Luxor at the start of a session. The first drawing will take a few seconds, because the Cairo graphics engine needs to warm up. Subsequent drawings are then much quicker. (This is true of much graphics and plotting work. Julia compiles each function when it first encounters it, and then calls the compiled versions thereafter.)","category":"page"},{"location":"examples/#Working-in-Jupyter","page":"A few examples","title":"Working in Jupyter","text":"","category":"section"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"(Image: Jupyter)","category":"page"},{"location":"examples/#Working-in-VS-Code","page":"A few examples","title":"Working in VS Code","text":"","category":"section"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"(Image: VS Code)","category":"page"},{"location":"examples/#Working-in-Pluto","page":"A few examples","title":"Working in Pluto","text":"","category":"section"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"(Image: Pluto)","category":"page"},{"location":"examples/#Images-as-matrices","page":"A few examples","title":"Images as matrices","text":"","category":"section"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"With the @imagematrix macro, you can create your drawing with vector graphics in the usual way, but the result is returned as a matrix. This example processes an ampersand in Images.jl.","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"using Luxor, Colors, Images, ImageFiltering\n\nm = @imagematrix begin\n        background(\"black\")\n        sethue(\"white\")\n        fontface(\"Georgia\")\n        fontsize(180)\n        text(\"&\", halign=:center, valign=:middle)\nend 200 200\n\nfunction convertmatrixtocolors(m)\n    return convert.(Colors.RGBA, m)\nend\n\nimg = convertmatrixtocolors(m)\n\nimfilter(img, Kernel.gaussian(10))","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"(Image: image matrix)","category":"page"},{"location":"examples/#Feature-gallery","page":"A few examples","title":"Feature gallery","text":"","category":"section"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"Here's a quick visual overview of some of the features in Luxor.jl:","category":"page"},{"location":"examples/","page":"A few examples","title":"A few examples","text":"(Image: \"luxor gallery\")","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"animation/#Animation-helper-functions","page":"Animation","title":"Animation helper functions","text":"","category":"section"},{"location":"animation/","page":"Animation","title":"Animation","text":"Luxor provides some functions to help you create animations‚Äîat least, it provides some assistance in creating lots of individual frames that can later be stitched together to form a moving animation, such as a GIF or MP4.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"There are four steps to creating an animation.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"1 Use Movie to create a Movie object which determines the title and dimensions.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"2 Define some functions that draw the graphics for specific frames.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"3 Define one or more Scenes that call these functions for specific frames.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"4 Call the animate(movie::Movie, scenes) function, passing in the scenes. This creates all the frames and saves them in a temporary directory. Optionally, you can ask for ffmpeg (if it's installed) to make an animated GIF for you.","category":"page"},{"location":"animation/#Example","page":"Animation","title":"Example","text":"","category":"section"},{"location":"animation/","page":"Animation","title":"Animation","text":"demo = Movie(400, 400, \"test\")\n\nfunction backdrop(scene, framenumber)\n    background(\"black\")\nend\n\nfunction frame(scene, framenumber)\n    sethue(Colors.HSV(framenumber, 1, 1))\n    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    circle(polar(100, -œÄ/2 - (eased_n * 2œÄ)), 80, :fill)\n    text(string(\"frame $framenumber of $(scene.framerange.stop)\"),\n        Point(O.x, O.y-190),\n        halign=:center)\n    text(scene.opts,\n        boxbottomcenter(BoundingBox()),\n        halign=:center,\n        valign=:bottom)\nend\n\nanimate(demo, [\n    Scene(demo, backdrop, 0:359),\n    Scene(demo, frame, 0:359,\n        easingfunction=easeinoutcubic,\n        optarg=\"made with Julia\")\n    ],\n    creategif=true)","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"(Image: animation example)","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"In this example, the movie uses two scenes, each specifying a function to draw frames from 0 to 359. For each frame numbered 0 to 359, the graphics are drawn by both the backdrop() and frame() functions, in that order. A drawing is automatically created (in PNG format) and centered (origin()) so you can start drawing immediately. The finish() function is automatically called when all the drawing functions in the scenes have completed, and the process starts afresh for the next frame. The second scene, calling the frame() function, shows how you can pass optional information to the function.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"Movie\nScene\nanimate","category":"page"},{"location":"animation/#Luxor.Movie","page":"Animation","title":"Luxor.Movie","text":"The Movie and Scene types and the animate() function are designed to help you create the frames that can be used to make an animated GIF or movie.\n\n1 Provide width, height, title, and optionally a frame range to the Movie constructor:\n\ndemo = Movie(400, 400, \"test\", 1:500)\n\n2 Define one or more scenes and scene-drawing functions.\n\n3 Run the animate() function, calling those scenes.\n\nExample\n\nbang = Movie(400, 100, \"bang\")\n\nbackdrop(scene, framenumber) =  background(\"black\")\n\nfunction frame1(scene, framenumber)\n    background(\"white\")\n    sethue(\"black\")\n    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    circle(O, 40 * eased_n, :fill)\nend\n\nanimate(bang, [\n    Scene(bang, backdrop, 0:200),\n    Scene(bang, frame1, 0:200, easingfunction=easeinsine)],\n    creategif=true,\n    pathname=\"/tmp/animationtest.gif\")\n\n\n\n\n\n\n","category":"type"},{"location":"animation/#Luxor.Scene","page":"Animation","title":"Luxor.Scene","text":"The Scene type defines a function to be used to render a range of frames in a movie.\n\nthe movie created by Movie()\nthe framefunction is a function taking two arguments: the scene and the framenumber.\nthe framerange determines which frames are processed by the function. Defaults to the entire movie.\nthe optional easingfunction can be accessed by the framefunction to vary the transition speed\nthe optional opts which is a single argument of an abstract type which can be accessed within the framefunction\n\n\n\n\n\n","category":"type"},{"location":"animation/#Luxor.animate","page":"Animation","title":"Luxor.animate","text":"animate(movie::Movie, scenelist::Array{Scene, 1};\n    creategif=false,\n    framerate=30,\n    pathname=\"\",\n    tempdirectory=\"\",\n    usenewffmpeg=true)\n\nCreate the movie defined in movie by rendering the frames define in the array of scenes in scenelist.\n\nIf creategif is true, the function attempts to call the ffmpeg utility on the resulting frames to build a GIF animation. This will be stored in pathname (an existing file will be overwritten; use a \".gif\" suffix), or in (movietitle).gif in a temporary directory. ffmpeg should be installed and available, of course, if this is to work.\n\nIn suitable environments, the resulting animation is displayed in the Plots window.\n\nExample\n\nanimate(bang, [\n    Scene(bang, backdrop, 0:200),\n    Scene(bang, frame1, 0:200, easingfunction=easeinsine)],\n    creategif=true,\n    pathname=\"/tmp/animationtest.gif\")\n\nThe usenewffmpeg option, true by default, uses single-pass palette generation and more complex filtering provided by recent versions of the ffmpeg utility, mainly to cope with transparent backgrounds. If set to false, the behavior is the same as in previous versions of Luxor.\n\n\n\n\n\nanimate(movie::Movie, scene::Scene; creategif=false, framerate=30)\n\nCreate the movie defined in movie by rendering the frames define in scene.\n\n\n\n\n\n","category":"function"},{"location":"animation/#Making-the-animation","page":"Animation","title":"Making the animation","text":"","category":"section"},{"location":"animation/","page":"Animation","title":"Animation","text":"For best results, you'll have to learn how to use something like ffmpeg, with its hundreds of options, which include codec selection, framerate adjustment and color palette tweaking. The creategif option for the animate function makes an attempt at running ffmpeg and assumes that it's already installed. Inside animate(), the first pass creates a GIF color palette, the second builds the file:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"run(`ffmpeg -f image2 -i $(tempdirectory)/%10d.png -vf palettegen\n    -y $(seq.stitle)-palette.png`)\n\nrun(`ffmpeg -framerate 30 -f image2 -i $(tempdirectory)/%10d.png\n    -i $(seq.stitle)-palette.png -lavfi paletteuse -y /tmp/$(seq.stitle).gif`)","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"Many movie editing programs, such as Final Cut Pro, will also let you import sequences of still images into a movie timeline.","category":"page"},{"location":"animation/#Using-scenes","page":"Animation","title":"Using scenes","text":"","category":"section"},{"location":"animation/","page":"Animation","title":"Animation","text":"Sometimes you want to construct an animation that has different components, layers, or scenes. To do this, you can specify scenes that are drawn only for specific frames.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"As an example, consider a simple example showing the sun for each hour of a 24 hour day.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"sun24demo = Movie(400, 400, \"sun24\", 0:23)","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"The backgroundfunction() draws a background that's used for all frames (animated GIFs like constant backgrounds):","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"function backgroundfunction(scene::Scene, framenumber)\n    background(\"black\")\nend","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"A nightskyfunction() draws the night sky:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"function nightskyfunction(scene::Scene, framenumber)\n    sethue(\"midnightblue\")\n    box(O, 400, 400, :fill)\nend","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"A dayskyfunction() draws the daytime sky:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"function dayskyfunction(scene::Scene, framenumber)\n    sethue(\"skyblue\")\n    box(O, 400, 400, :fill)\nend","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"The sunfunction() draws a sun at 24 positions during the day:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"function sunfunction(scene::Scene, framenumber)\n    i = rescale(framenumber, 0, 23, 2pi, 0)\n    gsave()\n    sethue(\"yellow\")\n    circle(polar(150, i), 20, :fill)\n    grestore()\nend","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"Finally a groundfunction() draws the ground:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"function groundfunction(scene::Scene, framenumber)\n    gsave()\n    sethue(\"brown\")\n    box(Point(O.x, O.y + 100), 400, 200, :fill)\n    grestore()\n    sethue(\"white\")\nend","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"Now define a group of Scenes that make up the movie. The scenes specify which functions are to be used, and for which frames:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"backdrop  = Scene(sun24demo, backgroundfunction, 0:23)   # every frame\nnightsky  = Scene(sun24demo, nightskyfunction, 0:6)      # midnight to 06:00\nnightsky1 = Scene(sun24demo, nightskyfunction, 17:23)    # 17:00 to 23:00\ndaysky    = Scene(sun24demo, dayskyfunction, 5:19)       # 05:00 to 19:00\nsun       = Scene(sun24demo, sunfunction, 6:18)          # 06:00 to 18:00\nground    = Scene(sun24demo, groundfunction, 0:23)       # every frame","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"Finally, the animate function scans the scenes in the scenelist for a movie, and calls the functions for each frame to build the animation:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"animate(sun24demo, [\n   backdrop, nightsky, nightsky1, daysky, sun, ground\n   ],\n   framerate=5,\n   creategif=true)","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"(Image: sun24 animation)","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"Notice that for some frames, such as frame 0, 1, or 23, three of the functions are called: for others, such as 7 and 8, four or more functions are called. Also notice that the order of scenes and the use of backgrounds is important.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"An alternative approach is to use the incoming framenumber as the master parameter that determines the position and appearance of all the graphics.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"function frame(scene, framenumber)\n    background(\"black\")\n    n   = rescale(framenumber, scene.framerange.start, scene.framerange.stop, 0, 1)\n    n2œÄ = rescale(n, 0, 1, 0, 2œÄ)\n    sethue(n, 0.5, 0.5)\n    box(BoundingBox(), :fill)\n    if 0.25 < n < 0.75\n        sethue(\"yellow\")\n        circle(polar(150, n2œÄ + œÄ/2), 20, :fill)\n    end\n    if n < 0.25 || n > 0.75\n        sethue(\"white\")\n        circle(polar(150, n2œÄ + œÄ/2), 20, :fill)\n    end\nend","category":"page"},{"location":"animation/#Passing-information-to-the-frame()-function","page":"Animation","title":"Passing information to the frame() function","text":"","category":"section"},{"location":"animation/","page":"Animation","title":"Animation","text":"If you want to pass information to the frame function, such as an array of values, try these:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"function frame(scene, framenumber, datapoints)\n...\nend\n\nsomedata = Datapoints[...]\n\nanimate(demo, [\n    Scene(demo, (s, f) -> frame(s, f, somedata),\n        0:100,\n        optarg=somedata)\n    ],\n    creategif=true,\n    pathname=\"...\")","category":"page"},{"location":"animation/#Easing-functions","page":"Animation","title":"Easing functions","text":"","category":"section"},{"location":"animation/","page":"Animation","title":"Animation","text":"Transitions for animations often use non-constant and non-linear motions, and these are usually provided by easing functions. Luxor defines some of the basic easing functions and they're listed in the (unexported) array Luxor.easingfunctions. Each scene can have one easing function.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"Most easing functions have names constructed like this:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"ease[in|out|inout][expo|circ|quad|cubic|quart|quint]","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"and there's an easingflat() linear transition.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"using Luxor # hide\nfunction draweasingfunction(f, pos, w, h)\n    @layer begin\n        translate(pos)\n        setline(0.5)\n        sethue(\"black\")\n        box(O, w, h, :stroke)\n        sethue(\"purple\")\n        for i in 0:0.005:1.0\n            circle(Point(-w/2, h/2) + Point(w * i, -f(i, 0, h, 1)), 1, :fill)\n        end\n        sethue(\"black\")\n        text(replace(string(f), \"Luxor.\" => \"\"), Point(0, h/2 - 20), halign=:center)\n    end\nend\n\nDrawing(650, 650, \"assets/figures/easingfunctions.png\") # hide\nbackground(\"white\") # hide\norigin() # hide\nt = Tiler(650, 650, 5, 5)\nmargin=5\nfontsize(10)\nfontface(\"Menlo\")\nfor (pos, n) in t\n    n > length(Luxor.easingfunctions) && continue\n    draweasingfunction(Luxor.easingfunctions[n], pos,\n        t.tilewidth-margin, t.tileheight-margin)\nend\n\nfinish() # hide\nnothing # hide","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"In these graphs, the horizontal axis is time (between 0 and 1), and the vertical axis is the parameter value (between 0 and 1).","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"(Image: easing function summary)","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"One way to use an easing function in a frame-making function is like this:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"function moveobject(scene, framenumber)\n    background(\"white\")\n    ...\n    easedframenumber = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    ...","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"This takes the current frame number, compares it with the end frame number of the scene, then adjusts it.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"In the next example, the purple dot has sinusoidal easing motion, the green has cubic, and the red has quintic. They all traverse the drawing in the same time, but have different accelerations and decelerations.","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"(Image: animation easing example)","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"fastandfurious = Movie(400, 100, \"easingtests\")\nbackdrop(scene, framenumber) =  background(\"black\")\nfunction frame1(scene, framenumber)\n    sethue(\"purple\")\n    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    circle(Point(-180 + (360 * eased_n), -20), 10, :fill)\nend\nfunction frame2(scene, framenumber)\n    sethue(\"green\")\n    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    circle(Point(-180 + (360 * eased_n), 0), 10, :fill)\nend\nfunction frame3(scene, framenumber)\n    sethue(\"red\")\n    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)\n    circle(Point(-180 + (360 * eased_n), 20), 10, :fill)\nend\nanimate(fastandfurious, [\n    Scene(fastandfurious, backdrop, 0:200),\n    Scene(fastandfurious, frame1,   0:200, easingfunction=easeinsine),\n    Scene(fastandfurious, frame2,   0:200, easingfunction=easeinoutcubic),\n    Scene(fastandfurious, frame3,   0:200, easingfunction=easeinoutquint)\n    ],\n    creategif=true)","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"Here's the definition of one of the easing functions:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"function easeoutquad(t, b, c, d)\n    t /= d\n    return -c * t * (t - 2) + b\nend","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"Here:","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"t is the current time (framenumber) of the transition\nb is the beginning value of the property\nc is the change between the beginning and destination value of the property\nd is the total length of the transition","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"The easeinoutbezier() function accepts two additional arguments, two normalized control points of a normalized Bezier curve from Point(0, 0) to Point(1, 1). You can use these to define the shape of a custom easing transition. The Bezier curve's y coordinate determines the acceleration. [?]","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"(Image: animation of bezier easing)","category":"page"},{"location":"animation/","page":"Animation","title":"Animation","text":"easingflat\nlineartween\neaseinquad\neaseoutquad\neaseinoutquad\neaseincubic\neaseoutcubic\neaseinoutcubic\neaseinquart\neaseoutquart\neaseinoutquart\neaseinquint\neaseoutquint\neaseinoutquint\neaseinsine\neaseoutsine\neaseinoutsine\neaseinexpo\neaseoutexpo\neaseinoutexpo\neaseincirc\neaseoutcirc\neaseinoutcirc\neaseinoutinversequad\neaseinoutbezier","category":"page"},{"location":"animation/#Luxor.easingflat","page":"Animation","title":"Luxor.easingflat","text":"easingflat(t, b, c, d)\n\nA flat easing function, same as lineartween().\n\nFor all easing functions, the four parameters are:\n\nt time, ie the current framenumber\nb beginning position or bottom value of the range\nc total change in position or top value of the range\nd duration, ie a framecount\n\nt/d or t/=d normalizes t to between 0 and 1\n... * c scales up to the required range value\n... + b adds the initial offset\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.lineartween","page":"Animation","title":"Luxor.lineartween","text":"default linear transition - no easing, no acceleration\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinquad","page":"Animation","title":"Luxor.easeinquad","text":"easeinquad(t, b, c, d)\n\nquadratic easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeoutquad","page":"Animation","title":"Luxor.easeoutquad","text":"easeoutquad(t, b, c, d)\n\nquadratic easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinoutquad","page":"Animation","title":"Luxor.easeinoutquad","text":"easeinoutquad(t, b, c, d)\n\nquadratic easing in/out - acceleration until halfway, then deceleration\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeincubic","page":"Animation","title":"Luxor.easeincubic","text":"easeincubic(t, b, c, d)\n\ncubic easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeoutcubic","page":"Animation","title":"Luxor.easeoutcubic","text":"easeoutcubic(t, b, c, d)\n\ncubic easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinoutcubic","page":"Animation","title":"Luxor.easeinoutcubic","text":"easeinoutcubic(t, b, c, d)\n\ncubic easing in/out - acceleration until halfway, then deceleration\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinquart","page":"Animation","title":"Luxor.easeinquart","text":"easeinquart(t, b, c, d)\n\nquartic easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeoutquart","page":"Animation","title":"Luxor.easeoutquart","text":"easeoutquart(t, b, c, d)\n\nquartic easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinoutquart","page":"Animation","title":"Luxor.easeinoutquart","text":"easeinoutquart(t, b, c, d)\n\nquartic easing in/out - acceleration until halfway, then deceleration\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinquint","page":"Animation","title":"Luxor.easeinquint","text":"easeinquint(t, b, c, d)\n\nquintic easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeoutquint","page":"Animation","title":"Luxor.easeoutquint","text":"easeoutquint(t, b, c, d)\n\nquintic easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinoutquint","page":"Animation","title":"Luxor.easeinoutquint","text":"easeinoutquint(t, b, c, d)\n\nquintic easing in/out - acceleration until halfway, then deceleration\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinsine","page":"Animation","title":"Luxor.easeinsine","text":"easeinsine(t, b, c, d)\n\nsinusoidal easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeoutsine","page":"Animation","title":"Luxor.easeoutsine","text":"easeoutsine(t, b, c, d)\n\nsinusoidal easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinoutsine","page":"Animation","title":"Luxor.easeinoutsine","text":"easeinoutsine(t, b, c, d)\n\nsinusoidal easing in/out - accelerating until halfway, then decelerating\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinexpo","page":"Animation","title":"Luxor.easeinexpo","text":"easeinexpo(t, b, c, d)\n\nexponential easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeoutexpo","page":"Animation","title":"Luxor.easeoutexpo","text":"easeoutexpo(t, b, c, d)\n\nexponential easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinoutexpo","page":"Animation","title":"Luxor.easeinoutexpo","text":"easeinoutexpo(t, b, c, d)\n\nexponential easing in/out - accelerating until halfway, then decelerating\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeincirc","page":"Animation","title":"Luxor.easeincirc","text":"easeincirc(t, b, c, d)\n\ncircular easing in - accelerating from zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeoutcirc","page":"Animation","title":"Luxor.easeoutcirc","text":"easeoutcirc(t, b, c, d)\n\ncircular easing out - decelerating to zero velocity\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinoutcirc","page":"Animation","title":"Luxor.easeinoutcirc","text":"easeinoutcirc(t, b, c, d)\n\ncircular easing in/out - acceleration until halfway, then deceleration\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinoutinversequad","page":"Animation","title":"Luxor.easeinoutinversequad","text":"easeinoutinversequad(t, b, c, d)\n\nease in, then slow down, then speed up, and ease out\n\n\n\n\n\n","category":"function"},{"location":"animation/#Luxor.easeinoutbezier","page":"Animation","title":"Luxor.easeinoutbezier","text":"easeinoutbezier(t, b, c, d, cpt1, cpt2)\n\nThis easing function takes six arguments, the usual t, b, c, and d, but also two points. These are the normalized control points of a Bezier curve drawn between Point(0, 0) to Point(1.0, 1.0). The y value of the Bezier is the eased value for t.\n\nIn your frame() generating function, if a Scene specifies the easeinoutbezier easing function, you can use this:\n\n...\nlineareasing = rescale(framenumber, 1, scene.framerange.stop)\nbeziereasing = scene.easingfunction(lineareasing, 0, 1, 1,\n    Point(0.25, 0.25), Point(0.75, 0.75))\n...\n\nThese two control points lie on the line between 0/0 and 1/1, so it's equivalent to a linear easing (lineartween() or easingflat).\n\nHowever, in the next example, the two control points define a wave-like curve that changes direction before changing back. When animating with this easing function, an object will 'go retrograde' for a while.\n\nlineareasing = rescale(framenumber, 1, scene.framerange.stop)\nbeziereasing = scene.easingfunction(lineareasing, 0, 1, 1,\n    Point(0.01, 1.99), Point(0.99, -1.5))\n\n\n\n\n\n","category":"function"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"DocTestSetup = quote\n    using Luxor, Dates, Colors\nend","category":"page"},{"location":"#Introduction-to-Luxor","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"","category":"section"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Luxor is a Julia package for drawing simple static vector graphics. It provides basic drawing functions and utilities for working with shapes, polygons, clipping masks, PNG and SVG images, turtle graphics, and simple animations.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"The focus of Luxor is on simplicity and ease of use: it should be easier to use than plain Cairo.jl, with shorter names, fewer underscores, default contexts, and simplified functions.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Luxor is thoroughly procedural and static: your code issues a sequence of simple graphics 'commands' until you've completed a drawing, then the results are saved into a PDF, PNG, SVG, or EPS file.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"There are some Luxor-related videos on YouTube, and some Luxor-related blog posts at cormullion.github.io/.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Luxor isn't interactive: for interactive graphics, look at Pluto.jl and Makie.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Please submit issues and pull requests on GitHub. Original version by cormullion, much improved with contributions from the Julia community.","category":"page"},{"location":"#How-can-you-contribute?","page":"Introduction to Luxor","title":"How can you contribute?","text":"","category":"section"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"If you know any geometry you probably know more than me, so there are plenty of improvements to algorithms waiting to be made. There are some TODO comments sprinkled through the code, but plenty more opportunities for improvement.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Update the code, most of which was written for Julia versions 0.2, v0.3 and 0.4 (remember when broadcasting wasn't a thing?) so there are probably many areas where the code could take more advantage of version 1.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"There can always be more tests, as the present tests are mainly visual, showing that something works, but there should be much more testing of things that shouldn't work - inappropriate input, overlapping polygons, coincident or collinear points, anticlockwise polygons, etc.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"More systematic error-handling particularly of geometry errors would be a good idea, rather than sprinkling throw(error())s around when things look wrong.","category":"page"},{"location":"#Installation-and-basic-usage","page":"Introduction to Luxor","title":"Installation and basic usage","text":"","category":"section"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Install the package using the package manager:","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"] add Luxor","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"Cairo.jl and Colors.jl will be installed if necessary.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"To use Luxor, type:","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"using Luxor","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"To test:","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"julia> @svg juliacircles()","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"or","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"julia> @png juliacircles()","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"which should create a graphic file and possibly also display and/or open it, depending on your environment.","category":"page"},{"location":"#Documentation","page":"Introduction to Luxor","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"This documentation was built using Documenter.jl.","category":"page"},{"location":"","page":"Introduction to Luxor","title":"Introduction to Luxor","text":"using Dates # hide\nprintln(\"Documentation built $(Dates.now()) with Julia $(VERSION)\") # hide","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"DocTestSetup = quote\n    using Luxor, Colors\n    end","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Experienced Julia users and programmers fluent in other languages and graphics systems should have no problem using Luxor by referring to the rest of the documentation. For others, here is a short tutorial to help you get started.","category":"page"},{"location":"tutorial/#What-you-need","page":"Tutorial","title":"What you need","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you've already downloaded Julia, and have added the Luxor package successfully (using ] add Luxor):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"$ julia\n               _\n   _       _ _(_)_     |  Documentation: https://docs.julialang.org\n  (_)     | (_) (_)    |\n   _ _   _| |_  __ _   |  Type \"?\" for help, \"]?\" for Pkg help.\n  | | | | | | |/ _` |  |\n  | | |_| | | | (_| |  |  Version 1.0.0 (2018-08-08)\n _/ |\\__'_|_|_|\\__'_|  |  Official https://julialang.org/ release\n|__/                   |\n\n(v1.0) pkg>  add Luxor","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"then you're ready to start.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"You can work in a Jupyter or Pluto notebook, or perhaps use the Atom/Juno or VSCode editor/development environment. It's also possible to work in a text editor (make sure you know how to run a file of Julia code), or, at a pinch, you could use the Julia REPL directly.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Ready? Let's begin. The goal of this tutorial is to do a bit of basic 'compass and ruler' Euclidean geometry, to introduce the basic concepts of Luxor drawings.","category":"page"},{"location":"tutorial/#First-steps","page":"Tutorial","title":"First steps","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We'll have to load just one package for this tutorial:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here's an easy shortcut for making drawings in Luxor. It's a Julia macro, and it's a good way to test that your system's working. Evaluate this code:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@png begin\n    text(\"Hello world\")\n    circle(Point(0, 0), 200, :stroke)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor\nDrawing(725, 600, \"assets/figures/tutorial-hello-world.png\")\nbackground(\"white\")\norigin()\nsethue(\"black\")\ntext(\"Hello world\")\ncircle(Point(0, 0), 200, :stroke)\nfinish()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"What happened? Can you see this image somewhere?","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you're using Juno, the image should appear in the Plots window. If you're working in a Jupyter or Pluto notebook, the image should appear below or above the code. If you're using Julia in a terminal or text editor, the image should have opened up in some other application, or, at the very least, it should have been saved in your current working directory (as luxor-drawing-(time stamp).png). If nothing happened, or if something bad happened, we've got some set-up or installation issues probably unrelated to Luxor...","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Let's press on. The @png macro is an easy way to make a drawing; all it does is save a bit of typing. (The macro expands to enclose your drawing commands with calls to the Drawing(), origin(), finish(), and preview() functions.) There are also @svg and @pdf macros, which do a similar thing. PNGs and SVGs are good because they show up in Juno and Jupyter. SVGs are usually higher quality too, but they're text-based so can become very large and difficult to load if the image is complex. PDF documents are always higher quality, and usually open up in a separate application.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This example illustrates a few things about Luxor drawings:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"There are default values which you don't have to set if you don't want to (file names, colors, font sizes, and so on).\nPositions on the drawing are specified with x and y coordinates stored in the Point type, and you can sometimes omit positions altogether.\nThe text was placed at the origin point (0/0), and by default it's left aligned.\nThe circle wasn't filled, but stroked. We passed the :stroke symbol as an action to the circle() function. Many drawing functions expect some action, such as :fill or :stroke, and sometimes :clip or :fillstroke.\nDid the first drawing takes a few seconds to appear? The Cairo drawing engine takes a little time to warm up. Once it's running, drawings appear much faster.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Once more, with more black, and some rulers:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@png begin\n    text(\"Hello again, world!\", Point(0, 250))\n    circle(Point(0, 0), 200, :fill)\n    rulers()\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor\nDrawing(725, 502, \"assets/figures/tutorial-hello-world-2.png\")\nbackground(\"white\")\norigin()\nsethue(\"black\")\ntext(\"Hello again, world!\", Point(0, 250))\ncircle(Point(0, 0), 200, :fill)\nrulers()\nfinish()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The x-coordinates usually run from left to right, the y-coordinates from top to bottom. So here, Point(0, 250) is a point at the left/right center, but at the bottom of the drawing.","category":"page"},{"location":"tutorial/#Euclidean-eggs","page":"Tutorial","title":"Euclidean eggs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For the main section of this tutorial, we'll attempt to draw Euclid's egg, which involves a bit of geometry.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For now, you can continue to store all the drawing instructions between the @png macro's begin and end markers. Technically, however, working like this at the top-level in Julia (ie without storing instructions in functions which Julia can compile) isn't considered to be 'best practice', because the unit of compilation in Julia is the function. (Look up 'global scope' in the documentation.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@png begin","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"and first define the variable radius to hold a value of 80 units (there are 72 units in a traditional inch):","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    radius=80","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Select gray dotted lines. To specify a color you can supply RGB (or HSB or LAB or LUV) values or use named colors, such as \"red\" or \"green\". \"gray0\" is black, and \"gray100\" is white. (For more information about colors, see Colors.jl.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    setdash(\"dot\")\n    sethue(\"gray30\")","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(You can use setcolor() instead of sethue() ‚Äî the latter doesn't affect the current opacity setting.)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Next, make two points, A and B, which will lie either side of the origin point. This line uses an array comprehension - notice the square brackets enclosing a for loop.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    A, B = [Point(x, 0) for x in [-radius, radius]]","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"x uses two values from the inner array, and a Point using each value is created and stored in its own variable. It seems hardly worth doing for two points, but it shows how you can assign more than one variable at the same time, and also how to generate points.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"With two points defined, draw a line from A to B, and stroke it.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    line(A, B, :stroke)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Draw a stroked circle too. The center of the circle is placed at the origin. You can use the letter O as a short cut for Origin, ie the Point(0, 0).","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    circle(O, radius, :stroke)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor\nDrawing(725, 300, \"assets/figures/tutorial-egg-1.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, :stroke)\ncircle(O, radius, :stroke)\nfinish()\nnothing","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/#Labels-and-dots","page":"Tutorial","title":"Labels and dots","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It's a good idea to label points in geometrical constructions, and to draw small dots to indicate their location clearly. For the latter task, small filled circles will do. For labels, there's a special label() function we can use, which positions a text string close to a point, using angles or points of the compass, so :N places the label to the north of a point.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Edit your previous code by adding instructions to draw some labels and circles:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@png begin\n    radius=80\n    setdash(\"dot\")\n    sethue(\"gray30\")\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    line(A, B, :stroke)\n    circle(Point(0, 0), radius, :stroke)\n# >>>>\n    label(\"A\", :NW, A)\n    label(\"O\", :N,  O)\n    label(\"B\", :NE, B)\n\n    circle.([A, O, B], 2, :fill)\n    circle.([A, B], 2radius, :stroke)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor\nDrawing(725, 400, \"assets/figures/tutorial-egg-2.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\n\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, :stroke)\ncircle(O, radius, :stroke)\nlabel(\"A\", :NW, A)\nlabel(\"O\", :N, O)\nlabel(\"B\", :NE, B)\ncircle.([A, O, B], 2, :fill)\ncircle.([A, B], 2radius, :stroke)\nfinish()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"While we could have drawn all the circles as usual, we've taken the opportunity to introduce a powerful Julia feature called broadcasting. The dot (.) just after the function name in the last two circle() function calls tells Julia to apply the function to all the arguments. We supplied an array of three points, and filled circles were placed at each one. Then we supplied an array of two points and stroked circles were placed there. Notice that we didn't have to supply an array of radius values or an array of actions ‚Äî in each case Julia did the necessary broadcasting (from scalar to vector) for us.","category":"page"},{"location":"tutorial/#Intersect-this","page":"Tutorial","title":"Intersect this","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We're now ready to tackle the job of finding the coordinates of the two points where two circles intersect. There's a Luxor function called intersectionlinecircle() that finds the point or points where a line intersects a circle. So we can find the two points where one of the circles crosses an imaginary vertical line drawn through O. Because of the symmetry, we'll only have to do circle A.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@png begin\n    # as before\n    radius=80\n    setdash(\"dot\")\n    sethue(\"gray30\")\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    line(A, B, :stroke)\n    circle(O, radius, :stroke) # use letter O for Point(0, 0)\n\n    label(\"A\", :NW, A)\n    label(\"O\", :N,  O)\n    label(\"B\", :NE, B)\n\n    circle.([A, O, B], 2, :fill)\n    circle.([A, B], 2radius, :stroke)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The intersectionlinecircle() takes four arguments: two points to define the line and a point/radius pair to define the circle. It returns the number of intersections (probably 0, 1, or 2), followed by the two points.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The line is specified with two points with an x value of 0 and y values of ¬± twice the radius, written in Julia's math-friendly style. The circle is centered at A and has a radius of AB (which is 2radius). Assuming that there are two intersections, we feed these to circle() and label() for drawing and labeling using our new broadcasting superpowers.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# >>>>\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    if nints == 2\n        circle.([C, D], 2, :fill)\n        label.([\"D\", \"C\"], :N, [D, C])\n    end\n\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor\nDrawing(725, 400, \"assets/figures/tutorial-egg-3.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\n\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, :stroke)\ncircle(O, radius, :stroke)\nlabel(\"A\", :NW, A)\nlabel(\"O\", :N, O)\nlabel(\"B\", :NE, B)\ncircle.([A, O, B], 2, :fill)\ncircle.([A, B], 2radius, :stroke)\n\nnints, C, D = intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\nif nints == 2\n    circle.([C, D], 2, :fill)\n    label.([\"D\", \"C\"], :N, [D, C])\nend\n\nfinish()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/#The-upper-circle","page":"Tutorial","title":"The upper circle","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Now for the trickiest part of this construction: a small circle whose center point sits on top of the inner circle and that meets the two larger circles near the point D.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finding this new center point C1 is easy enough, because we can again use intersectionlinecircle() to find the point where the central circle crosses a line from O to D.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Add some more lines to your code:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@png begin\n\n# >>>>\n\n    nints, C1, C2 = intersectionlinecircle(O, D, O, radius)\n    if nints == 2\n        circle(C1, 3, :fill)\n        label(\"C1\", :N, C1)\n    end\n\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor\nDrawing(725, 400, \"assets/figures/tutorial-egg-4.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\n\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, :stroke)\ncircle(O, radius, :stroke)\nlabel(\"A\", :NW, A)\nlabel(\"O\", :N, O)\nlabel(\"B\", :NE, B)\ncircle.([A, O, B], 2, :fill)\ncircle.([A, B], 2radius, :stroke)\n\nnints, C, D = intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\nif nints == 2\n    circle.([C, D], 2, :fill)\n    label.([\"D\", \"C\"], :N, [D, C])\nend\n\nnints, C1, C2 = intersectionlinecircle(O, D, O, radius)\nif nints == 2\n    circle(C1, 3, :fill)\n    label(\"C1\", :N, C1)\nend\nfinish()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The two other points that define this circle lie on the intersections of the large circles with imaginary lines through points A and B passing through the center point C1. We're looking for the lines A-C1-ip, where ip is somewhere on the circle between D and B, and B-C1-ip, where ip is somewhere between A and D.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To find (and draw) these points is straightforward. We'll mark these as intermediate for now, because there are in fact four intersection points but we want just the two nearest the top:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"# >>>>\n\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    circle.([I1, I2, I3, I4], 2, :fill)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"So we can use the distance() function to find the distance between two points, and it's simple enough to compare the values and choose the shortest.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"\n# >>>>\n\n    if distance(C1, I1) < distance(C1, I2)\n       ip1 = I1\n    else\n       ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n       ip2 = I3\n    else\n       ip2 = I4\n    end\n\n    label(\"ip1\", :N, ip1)\n    label(\"ip2\", :N, ip2)\n    circle(C1, distance(C1, ip1), :stroke)\n\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor\nDrawing(725, 400, \"assets/figures/tutorial-egg-5.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\n\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, :stroke)\ncircle(O, radius, :stroke)\nlabel(\"A\", :NW, A)\nlabel(\"O\", :N, O)\nlabel(\"B\", :NE, B)\ncircle.([A, O, B], 2, :fill)\ncircle.([A, B], 2radius, :stroke)\n\nnints, C, D = intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\nif nints == 2\n    circle.([C, D], 2, :fill)\n    label.([\"D\", \"C\"], :N, [D, C])\nend\n\nnints, C1, C2 = intersectionlinecircle(O, D, O, radius)\nif nints == 2\n    circle(C1, 3, :fill)\n    label(\"C1\", :N, C1)\nend\n\n# finding two more points on the circumference\n\nnints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\nnints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\ncircle.([I1, I2, I3, I4], 2, :fill)\n\nif distance(C1, I1) < distance(C1, I2)\n    ip1 = I1\nelse\n   ip1 = I2\nend\nif distance(C1, I3) < distance(C1, I4)\n   ip2    = I3\nelse\n   ip2 = I4\nend\n\nlabel(\"ip1\", :N, ip1)\nlabel(\"ip2\", :N, ip2)\ncircle(C1, distance(C1, ip1), :stroke)\n\nfinish()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/#Eggs-at-the-ready","page":"Tutorial","title":"Eggs at the ready","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"We now know all the points on the egg's perimeter, and the centers of the circular arcs. To draw the outline, we'll use the arc2r() function four times. This function takes: a center point and two points that together define a circular arc, plus an action.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The shape consists of four curves, so we'll use the :path action. Instead of immediately drawing the shape, like the :fill and :stroke actions do, this action adds a section to the current path.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"\n    label(\"ip1\", :N, ip1)\n    label(\"ip2\", :N, ip2)\n    circle(C1, distance(C1, ip1), :stroke)\n\n# >>>>\n\n    setline(5)\n    setdash(\"solid\")\n\n    arc2r(B,    A,  ip1, :path) # centered at B, from A to ip1\n    arc2r(C1, ip1,  ip2, :path)\n    arc2r(A,  ip2,    B, :path)\n    arc2r(O,    B,    A, :path)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Finally, once we've added all four sections to the path we can stroke and fill it. If you want to use separate styles for the stroke and fill, you can use a preserve version of the first action. This applies the action but keeps the path available for more actions.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    strokepreserve()\n    setopacity(0.8)\n    sethue(\"ivory\")\n    fillpath()\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor\nDrawing(725, 400, \"assets/figures/tutorial-egg-6.png\")\nbackground(\"white\")\norigin()\nradius=80\nsetdash(\"dot\")\nsethue(\"gray30\")\n\nA, B = [Point(x, 0) for x in [-radius, radius]]\nline(A, B, :stroke)\ncircle(O, radius, :stroke)\nlabel(\"A\", :NW, A)\nlabel(\"O\", :N, O)\nlabel(\"B\", :NE, B)\ncircle.([A, O, B], 2, :fill)\ncircle.([A, B], 2radius, :stroke)\n\nnints, C, D =\n    intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\nif nints == 2\n    circle.([C, D], 2, :fill)\n    label.([\"D\", \"C\"], :N, [D, C])\nend\n\nnints, C1, C2 = intersectionlinecircle(O, D, O, radius)\nif nints == 2\n    circle(C1, 3, :fill)\n    label(\"C1\", :N, C1)\nend\n\n# finding two more points on the circumference\n\nnints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\nnints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\ncircle.([I1, I2, I3, I4], 2, :fill)\n\nif distance(C1, I1) < distance(C1, I2)\n    ip1 = I1\nelse\n   ip1 = I2\nend\nif distance(C1, I3) < distance(C1, I4)\n   ip2    = I3\nelse\n   ip2 = I4\nend\n\nlabel(\"ip1\", :N, ip1)\nlabel(\"ip2\", :N, ip2)\ncircle(C1, distance(C1, ip1), :stroke)\n\nsetline(5)\nsetdash(\"solid\")\n\narc2r(B, A, ip1, :path)\narc2r(C1, ip1, ip2, :path)\narc2r(A, ip2, B, :path)\narc2r(O, B, A, :path)\nstrokepreserve()\nsetopacity(0.8)\nsethue(\"ivory\")\nfillpath()\nfinish()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/#Egg-stroke","page":"Tutorial","title":"Egg stroke","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"To be more generally useful, the above code can be boiled into a single function.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"function egg(radius, action=:none)\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    flag, C1 = intersectionlinecircle(C, D, O, radius)\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    if distance(C1, I1) < distance(C1, I2)\n        ip1 = I1\n    else\n        ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n        ip2 = I3\n    else\n        ip2 = I4\n    end\n\n    newpath()\n    arc2r(B, A, ip1, :path)\n    arc2r(C1, ip1, ip2, :path)\n    arc2r(A, ip2, B, :path)\n    arc2r(O, B, A, :path)\n    closepath()\n\n    do_action(action)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This keeps all the intermediate code and calculations safely hidden away, and it's now possible to draw a Euclidean egg by calling egg(100, :stroke), for example, where 100 is the required width (radius), and :stroke is the required action.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Of course, there's no error checking. This should be added if the function is to be used for any serious applications...!)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that this function doesn't define anything about what color it is, or where it's placed. When called, the function inherits the current drawing environment: scale, rotation, position of the origin, line thickness, color, style, and so on. This lets us write code like this:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@png begin\n    setopacity(0.7)\n    for Œ∏ in range(0, step=œÄ/6, length=12)\n        @layer begin\n            rotate(Œ∏)\n            translate(0, -150)\n            egg(50, :path)\n            setline(10)\n            randomhue()\n            fillpreserve()\n\n            randomhue()\n            strokepath()\n        end\n    end\nend 800 800 \"/tmp/eggstravaganza.png\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor, Random\nRandom.seed!(42)\nDrawing(725, 500, \"assets/figures/tutorial-egg-7.png\")\nfunction egg(radius, action=:none)\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    flag, C1 = intersectionlinecircle(C, D, O, radius)\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    if distance(C1, I1) < distance(C1, I2)\n        ip1 = I1\n    else\n        ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n        ip2 = I3\n    else\n        ip2 = I4\n    end\n\n    newpath()\n    arc2r(B, A, ip1, :path)\n    arc2r(C1, ip1, ip2, :path)\n    arc2r(A, ip2, B, :path)\n    arc2r(O, B, A, :path)\n    closepath()\n    do_action(action)\nend\nbackground(\"white\")\norigin()\nsetopacity(0.7)\nfor Œ∏ in range(0, step=œÄ/6, length=12)\n    @layer begin\n        rotate(Œ∏)\n        translate(0, -150)\n        egg(50, :path)\n        setline(10)\n        randomhue()\n        fillpreserve()\n\n        randomhue()\n        strokepath()\n    end\nend\nfinish()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The loop runs 12 times, with theta increasing from 0 upwards in steps of œÄ/6. But before each egg is drawn, the entire drawing environment is rotated by theta radians and then shifted along the y-axis away from the origin by -150 units (the y-axis values usually increase downwards, so, before any rotation takes place, a shift of -150 looks like an upwards shift). The randomhue() function does what you expect, and the egg() function is passed the :fill action and the radius.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Notice that the four drawing instructions are encased in a @layer begin...end shell. Any change made to the drawing environment inside this shell is discarded after the end. This allows us to make temporary changes to the scale and rotation, etc. and discard them easily once the shapes have been drawn.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Rotations and angles are typically specified in radians. The positive x-axis (a line from the origin increasing in x) starts off heading due east from the origin, and the y-axis due south, and positive angles are clockwise (ie from the positive x-axis towards the positive y-axis). So the second egg in the previous example was drawn after the axes were rotated by œÄ/6 radians clockwise.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"If you look closely you can tell which egg was drawn first ‚Äî it's overlapped on each side by subsequent eggs.","category":"page"},{"location":"tutorial/#Thought-experiments","page":"Tutorial","title":"Thought experiments","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"What would happen if the translation was translate(0, 150) rather than translate(0, -150)?\nWhat would happen if the translation was translate(150, 0) rather than translate(0, -150)?\nWhat would happen if you translated each egg before you rotated the drawing environment?","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Some useful tools for investigating the important aspects of coordinates and transformations include:","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"rulers() to draw the current x and y axes\ngetrotation() to get the current rotation\ngetscale() to get the current scale","category":"page"},{"location":"tutorial/#Polyeggs","page":"Tutorial","title":"Polyeggs","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"As well as stroke and fill actions, you can use the path as a clipping region (:clip), or as the basis for more shape shifting.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The egg() function creates a path and lets you apply an action to it. It's also possible to convert the path into a polygon (an array of points), which lets you do more things with it. The following code converts the egg's path into a polygon, and then moves every other point of the polygon halfway towards the centroid.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@png begin\n    egg(160, :path)\n    pgon = first(pathtopoly())","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The pathtopoly() function converts the current path made by egg(160, :path) into a polygon. Those smooth curves have been approximated by a series of straight line segments. The first() function is used because pathtopoly() returns an array of one or more polygons (paths can consist of a series of loops), and we know that we need only the single path here.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    pc = polycentroid(pgon)\n    circle(pc, 5, :fill)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"polycentroid() finds the centroid of the new polygon.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"This loop steps through the points and moves every odd-numbered one halfway towards the centroid. between() finds a point midway between two specified points. Finally the poly() function draws the array of points.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"    for pt in 1:2:length(pgon)\n        pgon[pt] = between(pc, pgon[pt], 0.5)\n    end\n    poly(pgon, :stroke)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor\nDrawing(725, 500, \"assets/figures/tutorial-egg-8.png\")\nfunction egg(radius, action=:none)\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    flag, C1 = intersectionlinecircle(C, D, O, radius)\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    if distance(C1, I1) < distance(C1, I2)\n        ip1 = I1\n    else\n        ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n        ip2    = I3\n    else\n        ip2 = I4\n    end\n\n    newpath()\n    arc2r(B, A, ip1, :path)\n    arc2r(C1, ip1, ip2, :path)\n    arc2r(A, ip2, B, :path)\n    arc2r(O, B, A, :path)\n    closepath()\n    do_action(action)\nend\nbackground(\"white\")\norigin()\negg(160, :path)\nsethue(\"black\")\npgon = first(pathtopoly())\npc = polycentroid(pgon)\ncircle(pc, 5, :fill)\n\nfor pt in 1:2:length(pgon)\n    pgon[pt] = between(pc, pgon[pt], 0.5)\nend\npoly(pgon, :stroke)\nfinish()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The uneven appearance of the interior points here looks to be a result of the default line join settings. Experiment with setlinejoin(\"round\") to see if this makes the geometry look tidier.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"For a final experiment with our egg() function, here's Luxor's offsetpoly() function struggling to draw around the spiky egg-based polygon.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"@png begin\n    egg(80, :path)\n    pgon = first(pathtopoly()) |> unique\n    pc = polycentroid(pgon)\n\n    for pt in 1:2:length(pgon)\n        pgon[pt] = between(pc, pgon[pt], 0.8)\n    end\n\n    for i in 30:-3:-8\n        randomhue()\n        op = offsetpoly(pgon, i)\n        poly(op, :stroke, close=true)\n    end\nend 800 800 \"/tmp/spike-egg.png\"","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor, Random\nDrawing(725, 600, \"assets/figures/tutorial-egg-9.png\")\nfunction egg(radius, action=:none)\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    flag, C1 = intersectionlinecircle(C, D, O, radius)\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    if distance(C1, I1) < distance(C1, I2)\n        ip1 = I1\n    else\n        ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n        ip2    = I3\n    else\n        ip2 = I4\n    end\n\n    newpath()\n    arc2r(B, A, ip1, :path)\n    arc2r(C1, ip1, ip2, :path)\n    arc2r(A, ip2, B, :path)\n    arc2r(O, B, A, :path)\n    closepath()\n    do_action(action)\nend\nbackground(\"white\")\norigin()\nRandom.seed!(42)\negg(80, :path)\npgon = first(pathtopoly()) |> unique\npc = polycentroid(pgon)\ncircle(pc, 5, :fill)\n\nfor pt in 1:2:length(pgon)\n    pgon[pt] = between(pc, pgon[pt], 0.8)\nend\n\nfor i in 30:-3:-8\n    randomhue()\n    op = offsetpoly(pgon, i)\n    poly(op, :stroke, close=true)\nend\n\nfinish()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: point example)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The small changes in the regularity of the points created by the path-to-polygon conversion and the varying number of samples it made are continually amplified in successive outlinings.","category":"page"},{"location":"tutorial/#Clipping","page":"Tutorial","title":"Clipping","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"A useful feature of Luxor is that you can use shapes as a clipping mask. Graphics can be hidden when they stray outside the boundaries of the mask.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this example, the egg (assuming you're still in the same Julia session in which you've defined the egg() function) isn't drawn, but is defined to act as a clipping mask. Every graphic shape that you draw now is clipped where it crosses the mask. This is specified by the :clip action which is passed to the doaction() function at the end of the egg().","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Here, the graphics are provided by the ngon() function, which draws regular n-sided polygons.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor, Colors\n@svg begin\n    setopacity(0.5)\n    eg(a) = egg(150, a)\n    sethue(\"gold\")\n    eg(:fill)\n    eg(:clip)\n    @layer begin\n       for i in 360:-4:1\n           sethue(Colors.HSV(i, 1.0, 0.8))\n           rotate(œÄ/30)\n           ngon(O, i, 5, 0, :stroke)\n       end\n    end\n    clipreset()\n    sethue(\"red\")\n    eg(:stroke)\nend","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using Luxor, Colors\nDrawing(725, 620, \"assets/figures/tutorial-egg-10.png\")\norigin()\nbackground(\"white\")\nfunction egg(radius, action=:none)\n    A, B = [Point(x, 0) for x in [-radius, radius]]\n    nints, C, D =\n        intersectionlinecircle(Point(0, -2radius), Point(0, 2radius), A, 2radius)\n\n    flag, C1 = intersectionlinecircle(C, D, O, radius)\n    nints, I3, I4 = intersectionlinecircle(A, C1, A, 2radius)\n    nints, I1, I2 = intersectionlinecircle(B, C1, B, 2radius)\n\n    if distance(C1, I1) < distance(C1, I2)\n        ip1 = I1\n    else\n        ip1 = I2\n    end\n    if distance(C1, I3) < distance(C1, I4)\n        ip2    = I3\n    else\n        ip2 = I4\n    end\n\n    newpath()\n    arc2r(B, A, ip1, :path)\n    arc2r(C1, ip1, ip2, :path)\n    arc2r(A, ip2, B, :path)\n    arc2r(O, B, A, :path)\n    closepath()\n    do_action(action)\nend\nsetopacity(0.5)\neg(a) = egg(150, a)\nsethue(\"gold\")\neg(:fill)\neg(:clip)\n@layer begin\n   for i in 360:-4:1\n       sethue(Colors.HSV(i, 1.0, 0.8))\n       rotate(œÄ/30)\n       ngon(O, i, 5, 0, :stroke)\n   end\nend\nclipreset()\nsethue(\"red\")\neg(:stroke)\nfinish()","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: clip example)","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"It's good practice to add a matching clipreset() after the clipping has been completed. Unbalanced clipping can lead to unpredictable results.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Good luck with your explorations!","category":"page"}]
}

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic graphics · Luxor</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Luxor logo"/></a><h1>Luxor</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction to Luxor</a></li><li><a class="toctext" href="examples.html">A few examples</a></li><li class="current"><a class="toctext" href="basics.html">Basic graphics</a><ul class="internal"><li><a class="toctext" href="#Types-1">Types</a></li><li><a class="toctext" href="#Drawings-and-files-1">Drawings and files</a></li><li><a class="toctext" href="#The-drawing-area-1">The drawing area</a></li><li><a class="toctext" href="#Simple-shapes-1">Simple shapes</a></li><li><a class="toctext" href="#Rectangles-and-boxes-1">Rectangles and boxes</a></li><li><a class="toctext" href="#Circles,-ellipses,-and-other-curvey-things-1">Circles, ellipses, and other curvey things</a></li><li><a class="toctext" href="#Lines-and-positions-1">Lines and positions</a></li><li><a class="toctext" href="#Geometry-tools-1">Geometry tools</a></li><li><a class="toctext" href="#Arrows-1">Arrows</a></li><li><a class="toctext" href="#Paths-1">Paths</a></li><li><a class="toctext" href="#Julia-graphics-1">Julia graphics</a></li><li><a class="toctext" href="#Miscellaneous-1">Miscellaneous</a></li></ul></li><li><a class="toctext" href="styling.html">Styling</a></li><li><a class="toctext" href="polygons.html">Polygons</a></li><li><a class="toctext" href="text.html">Text</a></li><li><a class="toctext" href="transforms.html">Transforms and matrices</a></li><li><a class="toctext" href="clipping.html">Clipping</a></li><li><a class="toctext" href="images.html">Images</a></li><li><a class="toctext" href="turtle.html">Turtle graphics</a></li><li><a class="toctext" href="animation.html">Animation</a></li><li><a class="toctext" href="moreexamples.html">More examples</a></li><li><a class="toctext" href="functionindex.html">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="basics.html">Basic graphics</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/docs/src/basics.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h1><a class="nav-anchor" id="The-basics-1" href="#The-basics-1">The basics</a></h1><p>The underlying drawing model is that points are added to paths, then the paths can be filled and/or stroked, using the current graphics state, which specifies colors, line thicknesses and patterns, and opacity. You can modify the drawing space by transforming/rotating/scaling it before you add graphics.</p><p>Many of the drawing functions have an <em>action</em> argument. This can be <code>:nothing</code>, <code>:fill</code>, <code>:stroke</code>, <code>:fillstroke</code>, <code>:fillpreserve</code>, <code>:strokepreserve</code>, <code>:clip</code>. The default is <code>:nothing</code>.</p><p>Positions are usually specified either by x and y coordinates or a <code>Point(x, y)</code>. Angles are usually in radians, measured starting at the positive x-axis turning towards the positive y-axis (which usually points &#39;down&#39; the page or canvas) in radians: &#39;clockwise&#39;.</p><p>Coordinates are specified in PostScript points, where a point is 1/72 of an inch. Three other units are available for distances:</p><ul><li><p>inch (<code>in</code> is unavailable, being used by <code>for</code> syntax)</p></li><li><p>cm   (centimeters)</p></li><li><p>mm   (millimeters)</p></li></ul><p>Because Julia allows you to combine numbers and variables directly, you can type, for example:</p><pre><code class="language-none">rect(Point(20mm, 2cm), 5inch, 22/7inch, :fill)</code></pre><h2><a class="nav-anchor" id="Types-1" href="#Types-1">Types</a></h2><p>The main defined types are <code>Point</code>, <code>Drawing</code>, and <code>Tiler</code>. The Point type holds two coordinates, <code>x</code> and <code>y</code>:</p><pre><code class="language-none">Point(12.0, 13.0)</code></pre><p>It&#39;s immutable, so you want to avoid trying to change the x or y coordinate directly. You can use the letter <strong>O</strong> as a shortcut to refer to the current Origin, <code>Point(0, 0)</code>.</p><p><code>Drawing</code> is how you create new drawings. And you can divide up the drawing area into tiles, using <code>Tiler</code>.</p><h2><a class="nav-anchor" id="Drawings-and-files-1" href="#Drawings-and-files-1">Drawings and files</a></h2><p>To create a drawing, and optionally specify the filename and type, and dimensions, use the <code>Drawing</code> constructor function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.Drawing" href="#Luxor.Drawing"><code>Luxor.Drawing</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Create a new drawing, and optionally specify file type (PNG, PDF, SVG, or EPS) and dimensions.</p><pre><code class="language-none">Drawing()</code></pre><p>creates a drawing, defaulting to PNG format, default filename &quot;luxor-drawing.png&quot;, default size 800 pixels square.</p><p>You can specify dimensions, and use the default target filename:</p><pre><code class="language-none">Drawing(400, 300)</code></pre><p>creates a drawing 400 pixels wide by 300 pixels high, defaulting to PNG format, default filename &quot;luxor-drawing.png&quot;.</p><pre><code class="language-none">Drawing(400, 300, &quot;my-drawing.pdf&quot;)</code></pre><p>creates a PDF drawing in the file &quot;my-drawing.pdf&quot;, 400 by 300 pixels.</p><pre><code class="language-none">Drawing(1200, 800, &quot;my-drawing.svg&quot;)`</code></pre><p>creates an SVG drawing in the file &quot;my-drawing.svg&quot;, 1200 by 800 pixels.</p><pre><code class="language-none">Drawing(1200, 1200/golden, &quot;my-drawing.eps&quot;)</code></pre><p>creates an EPS drawing in the file &quot;my-drawing.eps&quot;, 1200 wide by 741.8 pixels (= 1200 ÷ ϕ) high.</p><pre><code class="language-none">Drawing(&quot;A4&quot;, &quot;my-drawing.pdf&quot;)</code></pre><p>creates a drawing in ISO A4 size (595 wide by 842 high) in the file &quot;my-drawing.pdf&quot;. Other sizes available are:  &quot;A0&quot;, &quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;A4&quot;, &quot;A5&quot;, &quot;A6&quot;, &quot;Letter&quot;, &quot;Legal&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;. Append &quot;landscape&quot; to get the landscape version.</p><pre><code class="language-none">Drawing(&quot;A4landscape&quot;)</code></pre><p>creates the drawing A4 landscape size.</p><p>PDF files default to a white background, but PNG defaults to transparent, unless you specify one using <code>background()</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L156-L193">source</a><br/></section><p>To finish a drawing and close the file, use <code>finish()</code>, and, to launch an external application to view it, use <code>preview()</code>.</p><p>If you&#39;re using Jupyter (IJulia), <code>preview()</code> displays PNG files in the notebook.</p><p><img src="assets/figures/jupyter.png" alt="jupyter"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.finish" href="#Luxor.finish"><code>Luxor.finish</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">finish()</code></pre><p>Finish the drawing, and close the file. You may be able to open it in an external viewer application with <code>preview()</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L204-L209">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.preview" href="#Luxor.preview"><code>Luxor.preview</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">preview()</code></pre><p>If working in Jupyter (IJUlia), display a PNG file in the notebook. On macOS, open the file, which probably uses the default, Preview.app. On Unix, open the file with <code>xdg-open</code>. On Windows, pass the filename to the shell.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L222-L229">source</a><br/></section><p>The global variable <code>currentdrawing</code> (of type Drawing) holds a few parameters which are occasionally useful:</p><pre><code class="language-none">julia&gt; fieldnames(currentdrawing)
10-element Array{Symbol,1}:
:width
:height
:filename
:surface
:cr
:surfacetype
:redvalue
:greenvalue
:bluevalue
:alpha</code></pre><h2><a class="nav-anchor" id="The-drawing-area-1" href="#The-drawing-area-1">The drawing area</a></h2><p>The origin (0/0) starts off at the top left: the x axis runs left to right, and the y axis runs top to bottom.</p><p>The <code>origin()</code> function moves the 0/0 point to the center of the drawing. It&#39;s often convenient to do this at the beginning of a program. You can use functions like <code>scale()</code>, <code>rotate()</code>, and <code>translate()</code> to change the coordinate system.</p><p><code>background()</code> fills the image with a color, covering any previous contents. By default, PDF files have a white background, whereas PNG drawings have no background, so the background appears transparent in other applications. If there is a current clipping region, <code>background()</code> fills just that region. Here, the first <code>background()</code> filled the entire drawing; the calls in the loop fill only the active clipping region, a tile defined by the <code>Tiler</code> iterator:</p><div><pre><code class="language-julia">background(&quot;magenta&quot;)
tiles = Tiler(600, 400, 5, 5, margin=30)
for (pos, n) in tiles
    box(pos, tiles.tilewidth, tiles.tileheight, :clip)
    background(randomhue()...)
    clipreset()
end</code></pre></div><p><img src="assets/figures/backgrounds.png" alt="background"/></p><p>The <code>axes()</code> function draws a couple of lines and text labels in light gray to indicate the position and orientation of the current axes.</p><div><pre><code class="language-julia">background(&quot;gray80&quot;)
origin()
axes()</code></pre></div><p><img src="assets/figures/axes.png" alt="axes"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.background" href="#Luxor.background"><code>Luxor.background</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">background(color)</code></pre><p>Fill the canvas with a single color. Returns the (red, green, blue, alpha) values.</p><p>Examples:</p><pre><code class="language-none">background(&quot;antiquewhite&quot;)
background(&quot;ivory&quot;)</code></pre><p>If Colors.jl is installed:</p><pre><code class="language-none">background(RGB(0, 0, 0))
background(Luv(20, -20, 30))</code></pre><p>If you don&#39;t specify a background color for a PNG drawing, the background will be transparent. You can set a partly or completely transparent background for PNG files by passing a color with an alpha value, such as this &#39;transparent black&#39;:</p><pre><code class="language-none">background(RGBA(0, 0, 0, 0))</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L303-L324">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.axes" href="#Luxor.axes"><code>Luxor.axes</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Draw and label two axes lines starting at <code>O</code>, the current 0/0, and continuing out along the current positive x and y axes.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L284-L287">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.origin" href="#Luxor.origin"><code>Luxor.origin</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">origin()</code></pre><p>Reset the current matrix, and then set the 0/0 origin to the center of the drawing (otherwise it will stay at the top left corner, the default).</p><p>You can refer to the 0/0 point as <code>O</code>. (O = <code>Point(0, 0)</code>),</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L242-L249">source</a><br/></section><h3><a class="nav-anchor" id="Tiles-1" href="#Tiles-1">Tiles</a></h3><p>The drawing area (or any other area) can be divided into rectangular tiles (as rows and columns) using the <code>Tiler</code> iterator, which returns the center point and tile number of each tile.</p><p>In this example, every third tile is divided up into subtiles and colored:</p><div><pre><code class="language-julia">tiles = Tiler(400, 300, 4, 5, margin=5)
for (pos, n) in tiles
    randomhue()
    box(pos, tiles.tilewidth, tiles.tileheight, :fill)
    if n % 3 == 0
        gsave()
        translate(pos)
        subtiles = Tiler(tiles.tilewidth, tiles.tileheight, 4, 4, margin=5)
        for (pos1, n1) in subtiles
            randomhue()
            box(pos1, subtiles.tilewidth, subtiles.tileheight, :fill)
        end
        grestore()
    end
    sethue(&quot;white&quot;)
    textcentred(string(n), pos + Point(0, 5))
end</code></pre></div><p><img src="assets/figures/tiler.png" alt="tiler"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.Tiler" href="#Luxor.Tiler"><code>Luxor.Tiler</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-none">tiles = Tiler(areawidth, areaheight, nrows, ncols, margin=20)</code></pre><p>A Tiler is an iterator that, for each iteration, returns a tuple of:</p><ul><li><p>the <code>x</code>/<code>y</code> point of the center of each tile in a set of tiles that divide up a rectangular space such as a page into rows and columns (relative to current 0/0)</p></li><li><p>the number of the tile</p></li></ul><p><code>areawidth</code> and <code>areaheight</code> are the dimensions of the area to be tiled, <code>nrows</code>/<code>ncols</code> are the number of rows and columns required, and <code>margin</code> is applied to all four edges of the area before the function calculates the tile sizes required.</p><pre><code class="language-none">tiles = Tiler(1000, 800, 4, 5, margin=20)
for (pos, n) in tiles
# the point pos is the center of the tile
end</code></pre><p>You can access the calculated tile width and height like this:</p><pre><code class="language-none">tiles = Tiler(1000, 800, 4, 5, margin=20)
for (pos, n) in tiles
  ellipse(pos.x, pos.y, tiles.tilewidth, tiles.tileheight, :fill)
end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Tiler.jl#L1-L26">source</a><br/></section><h3><a class="nav-anchor" id="Save-and-restore-1" href="#Save-and-restore-1">Save and restore</a></h3><p><code>gsave()</code> saves a copy of the current graphics settings (current axis rotation, position, scale, line and text settings, color, and so on). When the next <code>grestore()</code> is called, all changes you&#39;ve made to the graphics settings will be discarded, and they&#39;ll return to how they were when you last used <code>gsave()</code>. <code>gsave()</code> and <code>grestore()</code> should always be balanced in pairs.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.gsave" href="#Luxor.gsave"><code>Luxor.gsave</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">gsave()</code></pre><p>Save the current color settings on the stack.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L663-L667">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.grestore" href="#Luxor.grestore"><code>Luxor.grestore</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">grestore()</code></pre><p>Replace the current graphics state with the one on top of the stack.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L677-L681">source</a><br/></section><h2><a class="nav-anchor" id="Simple-shapes-1" href="#Simple-shapes-1">Simple shapes</a></h2><p>Functions for making shapes include <code>rect()</code>, <code>box()</code>, <code>circle()</code>, <code>ellipse()</code>, <code>squircle()</code>, <code>arc()</code>, <code>carc()</code>, <code>curve()</code>, <code>sector()</code>, and <code>pie()</code>. There&#39;s also <code>ngon()</code> and <code>star()</code>, listed under Polygons, below.</p><h2><a class="nav-anchor" id="Rectangles-and-boxes-1" href="#Rectangles-and-boxes-1">Rectangles and boxes</a></h2><p><img src="assets/figures/rects.png" alt="rects"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.rect" href="#Luxor.rect"><code>Luxor.rect</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rect(xmin, ymin, w, h, action)</code></pre><p>Create a rectangle with one corner at (<code>xmin</code>/<code>ymin</code>) with width <code>w</code> and height <code>h</code> and then do an action.</p><p>See <code>box()</code> for more ways to do similar things, such as supplying two opposite corners, placing by centerpoint and dimensions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L486-L494">source</a><br/><div><pre><code class="language-none">rect(cornerpoint, w, h, action)</code></pre><p>Create a rectangle with one corner at <code>cornerpoint</code> with width <code>w</code> and height <code>h</code> and do an action.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L503-L508">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">box(cornerpoint1, cornerpoint2, action=:nothing)</code></pre><p>Create a rectangle between two points and do an action.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L513-L517">source</a><br/><div><pre><code class="language-none">box(points::Array, action=:nothing)</code></pre><p>Create a box/rectangle using the first two points of an array of Points to defined opposite corners.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L522-L527">source</a><br/><div><pre><code class="language-none">box(pt::Point, width, height, action=:nothing; vertices=false)</code></pre><p>Create a box/rectangle centered at point <code>pt</code> with width and height. Use <code>vertices=true</code> to return an array of the four corner points rather than draw the box.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L532-L537">source</a><br/><div><pre><code class="language-none">box(x, y, width, height, action=:nothing)</code></pre><p>Create a box/rectangle centered at point <code>x/y</code> with width and height.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L548-L552">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polybbox" href="#Luxor.polybbox"><code>Luxor.polybbox</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Find the bounding box of a polygon (array of points).</p><pre><code class="language-none">polybbox(pointlist::Array)</code></pre><p>Return the two opposite corners (suitable for <code>box()</code>, for example).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/polygons.jl#L30-L36">source</a><br/></section><h2><a class="nav-anchor" id="Circles,-ellipses,-and-other-curvey-things-1" href="#Circles,-ellipses,-and-other-curvey-things-1">Circles, ellipses, and other curvey things</a></h2><p>There are various ways to make circles, including by center and radius, or passing through two points:</p><div><pre><code class="language-julia">p1 = O
p2 = Point(100, 0)
sethue(&quot;red&quot;)
circle(p1, 40, :fill)
sethue(&quot;green&quot;)
circle(p1, p2, :stroke)
sethue(&quot;black&quot;)
arrow(O, Point(0, -40))
map(p -&gt; circle(p, 4, :fill), [p1, p2])</code></pre></div><p><img src="assets/figures/circles.png" alt="circles"/></p><p>Or passing through three points. The <code>center3pts()</code> function returns the center position and radius of a circle passing through three points:</p><div><pre><code class="language-julia">sethue(&quot;black&quot;)
p1 = Point(0, -50)
p2 = Point(100, 0)
p3 = Point(0, 65)
map(p -&gt; circle(p, 4, :fill), [p1, p2, p3])
circle(center3pts(p1, p2, p3)..., :stroke)</code></pre></div><p><img src="assets/figures/center3.png" alt="center and radius of 3 points"/></p><p>With <code>ellipse()</code> you can place ellipses (and circles) by defining the center point and the width and height.</p><div><pre><code class="language-julia">tiles = Tiler(500, 300, 5, 5)
width = 20
height = 25
for (pos, n) in tiles
    randomhue()
    ellipse(pos, width, height, :fill)
    sethue(&quot;black&quot;)
    label = string(round(width/height, 2))
    textcentered(label, pos.x, pos.y + 25)
    width += 2
end</code></pre></div><p><img src="assets/figures/ellipses.png" alt="ellipses"/></p><p>It&#39;s also possible to make polygonal approximations to ellipses from two focal points and a distance.</p><div><pre><code class="language-julia">f1 = Point(-100, 0)
f2 = Point(100, 0)
ellipsepoly = ellipse(f1, f2, 170, :none, vertices=true)
[ begin
    poly(offsetpoly(ellipsepoly, c), close=true, :stroke);
    circle(f1, 2, :fill)
    circle(f2, 2, :fill)
    rotate(pi/48)
  end
     for c in 150:-5:1 ]</code></pre></div><p><img src="assets/figures/ellipses_1.png" alt="more ellipses"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.circle" href="#Luxor.circle"><code>Luxor.circle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">circle(x, y, r, action=:nothing)</code></pre><p>Make a circle of radius <code>r</code> centred at <code>x</code>/<code>y</code>.</p><p><code>action</code> is one of the actions applied by <code>do_action</code>, defaulting to <code>:nothing</code>. You can also use <code>ellipse()</code> to draw circles and place them by their centerpoint.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L3-L10">source</a><br/><div><pre><code class="language-none">circle(pt, r, action)</code></pre><p>Make a circle centred at <code>pt</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L19-L23">source</a><br/><div><pre><code class="language-none">circle(pt1::Point, pt2::Point, action=:nothing)</code></pre><p>Make a circle that passes through two points that define the diameter:</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L27-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.ellipse" href="#Luxor.ellipse"><code>Luxor.ellipse</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Make an ellipse, centered at <code>xc/yc</code>, fitting in a box of width <code>w</code> and height <code>h</code>.</p><pre><code class="language-none">ellipse(xc, yc, w, h, action=:none)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L69-L73">source</a><br/><div><p>Make an ellipse, centered at point <code>c</code>, with width <code>w</code>, and height <code>h</code>.</p><pre><code class="language-none">ellipse(cpt, w, h, action=:none)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L92-L96">source</a><br/><div><pre><code class="language-none">ellipse(focus1::Point, focus2::Point, k, action=:none;
         stepvalue=pi/100,
         vertices=false,
         reversepath=false)</code></pre><p>Build a polygon approximation to an ellipse, given two points and a distance, <code>k</code>, which is the sum of the distances to the focii of any points on the ellipse (or the shortest length of string required to go from one focus to the perimeter and on to the other focus).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L378-L387">source</a><br/></section><p><code>circlepath()</code> constructs a circular path from Bèzier curves, which allows you to use circles as paths.</p><div><pre><code class="language-julia">setline(4)
tiles = Tiler(600, 250, 1, 5)
for (pos, n) in tiles
    randomhue()
    circlepath(pos, tiles.tilewidth/2, :path)
    newsubpath()
    circlepath(pos, rand(5:tiles.tilewidth/2 - 1), :fill, reversepath=true)
end</code></pre></div><p><img src="assets/figures/circle-path.png" alt="circles as paths"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.circlepath" href="#Luxor.circlepath"><code>Luxor.circlepath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">circlepath(center::Point, radius, action=:none;
    reversepath=false,
    kappa = 0.5522847)</code></pre><p>Draw a circle using Bézier curves.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L315-L321">source</a><br/></section><p>A sector (strictly an &quot;annular sector&quot;) has an inner and outer radius, as well as start and end angles.</p><div><pre><code class="language-julia">sector(50, 90, pi/2, 0, :fill)</code></pre></div><p><img src="assets/figures/sector.png" alt="sector"/></p><p>You can supply a value for corner radius. The same sector is drawn but with rounded corners.</p><div><pre><code class="language-julia">sector(50, 90, pi/2, 0, 15, :fill)</code></pre></div><p><img src="assets/figures/sectorrounded.png" alt="sector"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.sector" href="#Luxor.sector"><code>Luxor.sector</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sector(innerradius, outerradius, startangle, endangle, action=:none)</code></pre><p>Make an annular sector centered at the current <code>0/0</code> point.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L191-L195">source</a><br/><div><pre><code class="language-none">sector(innerradius, outerradius, startangle, endangle, cornerradius, action=:none)</code></pre><p>Draw an annular sector with rounded corners, basically a bent sausage shape.</p><p>TODO: The results aren&#39;t 100% accurate at the moment. There are small discontinuities where the curves join.</p><p>The cornerradius is reduced from the supplied value if neceesary to prevent overshoots.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L207-L216">source</a><br/></section><p>A pie (or wedge) has start and end angles.</p><div><pre><code class="language-julia">pie(0, 0, 100, pi/2, pi, :fill)</code></pre></div><p><img src="assets/figures/pie.png" alt="pie"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.pie" href="#Luxor.pie"><code>Luxor.pie</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pie(x, y, radius, startangle, endangle, action=:none)</code></pre><p>Make a pie shape centered at <code>x</code>/<code>y</code>. Angles start at the positive x-axis and are measured clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L274-L279">source</a><br/><div><pre><code class="language-none">pie(centerpoint, radius, startangle, endangle, action=:none)</code></pre><p>Make a pie shape centered at <code>centerpoint</code>.</p><p>Angles start at the positive x-axis and are measured clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L292-L298">source</a><br/></section><p>A <em>squircle</em> is a cross between a square and a circle. You can adjust the squariness and circularity of it to taste:</p><div><pre><code class="language-julia">setline(2)
tiles = Tiler(600, 250, 1, 3)
for (pos, n) in tiles
    sethue(&quot;lavender&quot;)
    squircle(pos, 80, 80, rt=[0.3, 0.5, 0.7][n], :fillpreserve)
    sethue(&quot;grey20&quot;)
    stroke()
    textcentered(&quot;rt = $([0.3, 0.5, 0.7][n])&quot;, pos)
end</code></pre></div><p><img src="assets/figures/squircle.png" alt="squircles"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.squircle" href="#Luxor.squircle"><code>Luxor.squircle</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Make a squircle (basically a rectangle with rounded corners). Specify the center position, horizontal radius (distance from center to a side), and vertical radius (distance from center to top or bottom):</p><pre><code class="language-none">squircle(center::Point, hradius, vradius, action=:none; rt = 0.5, vertices=false)</code></pre><p>The <code>rt</code> option defaults to 0.5, and gives an intermediate shape. Values less than 0.5 make the shape more square. Values above make the shape more round.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L99-L105">source</a><br/></section><p>Or for a simple rounded rectangle, smooth the corners of a box, like so:</p><div><pre><code class="language-julia">setline(4)
polysmooth(box(O, 200, 150, vertices=true), 10, :stroke)</code></pre></div><p><img src="assets/figures/round-rect.png" alt="rounded rect"/></p><h3><a class="nav-anchor" id="Arcs-and-curves-1" href="#Arcs-and-curves-1">Arcs and curves</a></h3><p><code>curve()</code> constructs Bèzier curves from control points:</p><div><pre><code class="language-julia">setline(.5)
pt1 = Point(0, -125)
pt2 = Point(200, 125)
pt3 = Point(200, -125)

sethue(&quot;red&quot;)
map(p -&gt; circle(p, 4, :fill), [O, pt1, pt2, pt3])

line(O, pt1, :stroke)
line(pt2, pt3, :stroke)

sethue(&quot;black&quot;)
setline(3)

move(O)
curve(pt1, pt2, pt3)
stroke()</code></pre></div><p><img src="assets/figures/curve.png" alt="curve"/></p><p>There are a few arc-drawing commands, such as <code>arc()</code>, <code>carc()</code>, and <code>arc2r()</code>. <code>arc2r()</code> draws a circular arc that joins two points:  </p><div><pre><code class="language-julia">tiles = Tiler(700, 200, 1, 6)
for (pos, n) in tiles
    c1, pt2, pt3 = ngon(pos, rand(10:50), 3, rand(0:pi/12:2pi), vertices=true)
    sethue(&quot;black&quot;)
    map(pt -&gt; circle(pt, 4, :fill), [c1, pt3])
    sethue(&quot;red&quot;)
    circle(pt2, 4, :fill)
    randomhue()
    arc2r(c1, pt2, pt3, :stroke)
end</code></pre></div><p><img src="assets/figures/arc2r.png" alt="arc"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.arc" href="#Luxor.arc"><code>Luxor.arc</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going clockwise.</p><pre><code class="language-none">arc(xc, yc, radius, angle1, angle2, action=:nothing)</code></pre><p>Angles are defined relative to the x-axis, positive clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L122-L128">source</a><br/><div><p>Arc with centerpoint.</p><pre><code class="language-none">arc(centerpoint::Point, radius, angle1, angle2, action=:nothing)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L134-L138">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.arc2r" href="#Luxor.arc2r"><code>Luxor.arc2r</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">  arc2r(c1, p2, p3, action=:nothing)</code></pre><p>Make a circular arc centered at <code>c1</code> that starts at <code>p2</code> and ends at <code>p3</code>, going clockwise.</p><p><code>c1</code>-<code>p2</code> really determines the radius. If <code>p3</code> doesn&#39;t lie on the circular path, it will be used only as an indication of the arc&#39;s length, rather than its position.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L157-L163">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.carc" href="#Luxor.carc"><code>Luxor.carc</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going counterclockwise.</p><pre><code class="language-none">carc(xc, yc, radius, angle1, angle2, action=:nothing)</code></pre><p>Angles are defined relative to the x-axis, positive clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L142-L148">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.curve" href="#Luxor.curve"><code>Luxor.curve</code></a> — <span class="docstring-category">Function</span>.</div><div><p>Draw a Bézier curve.</p><pre><code class="language-none"> curve(x1, y1, x2, y2, x3, y3)
 curve(p1, p2, p3)</code></pre><p>The spline starts at the current position, finishing at <code>x3/y3</code> (<code>p3</code>), following two  control points <code>x1/y1</code> (<code>p1</code>) and <code>x2/y2</code> (<code>p2</code>)</p><p><strong></strong></p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L302-L311">source</a><br/></section><h2><a class="nav-anchor" id="Lines-and-positions-1" href="#Lines-and-positions-1">Lines and positions</a></h2><p>There is a &#39;current position&#39; which you can set with <code>move()</code>, and can use implicitly in functions like <code>line()</code>, <code>text()</code>, and <code>curve()</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.move" href="#Luxor.move"><code>Luxor.move</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">move(x, y)
move(pt)</code></pre><p>Move to a point.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L606-L611">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.rmove" href="#Luxor.rmove"><code>Luxor.rmove</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rmove(x, y)</code></pre><p>Move by an amount from the current point. Move relative to current position by <code>x</code> and <code>y</code>:</p><p>Move relative to current position by the <code>pt</code>&#39;s x and y:</p><pre><code class="language-none">rmove(pt)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L615-L623">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.line" href="#Luxor.line"><code>Luxor.line</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">line(x, y)
line(x, y, :action)
line(pt)</code></pre><p>Create a line from the current position to the <code>x/y</code> position and optionally apply an action:</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L627-L633">source</a><br/><div><pre><code class="language-none">line(pt1::Point, pt2::Point, action=:nothing)</code></pre><p>Make a line between two points, <code>pt1</code> and <code>pt2</code> and do an action.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L637-L641">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.rline" href="#Luxor.rline"><code>Luxor.rline</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rline(x, y)
rline(x, y, :action)
rline(pt)</code></pre><p>Create a line relative to the current position to the <code>x/y</code> position and optionally apply an action:</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L648-L655">source</a><br/></section><h2><a class="nav-anchor" id="Geometry-tools-1" href="#Geometry-tools-1">Geometry tools</a></h2><p>You can find the midpoint between two points using <code>midpoint()</code>.</p><p>The following code places a small pentagon at the midpoint of each side of a larger pentagon:</p><div><pre><code class="language-julia">sethue(&quot;red&quot;)
ngon(O, 100, 5, 0, :stroke)

sethue(&quot;darkgreen&quot;)
p5 = ngon(O, 100, 5, 0, vertices=true)

for i in eachindex(p5)
    pt1 = p5[mod1(i, 5)]
    pt2 = p5[mod1(i + 1, 5)]
    midp = midpoint(pt1, pt2)
    ngon(midp, 20, 5, 0, :fill)
end</code></pre></div><p><img src="assets/figures/midpoint.png" alt="arc"/></p><p>A more general function, <code>between()</code>, finds for a value <code>x</code> the corresponding point on a line defined by two points, normalized to the range 0 and 1. So <code>midpoint(p1, p2)</code> and <code>between(p1, p2, 0.5)</code> should return the same point.</p><div><pre><code class="language-julia">sethue(&quot;red&quot;)
p1 = Point(-150, 0)
p2 = Point(150, 40)
line(p1, p2)
stroke()
for i in -0.5:0.1:1.5
    randomhue()
    circle(between(p1, p2, i), 5, :fill)
end</code></pre></div><p><img src="assets/figures/betweenpoint.png" alt="arc"/></p><p>Values less than 0.0 and greater than 1.0 appear to work well too, placing the point on the line if extended.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.midpoint" href="#Luxor.midpoint"><code>Luxor.midpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">midpoint(p1, p2)</code></pre><p>Find the midpoint between two points.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/point.jl#L106-L110">source</a><br/><div><pre><code class="language-none">midpoint(a)</code></pre><p>Find midpoint between the first two elements of an array of points.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/point.jl#L113-L117">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.between" href="#Luxor.between"><code>Luxor.between</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">between(p1::Point, p2::Point, x)</code></pre><p>Find the point between point <code>p1</code> and point <code>p2</code> for <code>x</code>, where <code>x</code> is typically between 0 and 1, so these two should be equivalent:</p><pre><code class="language-none">between(p1, p2, 0.5)</code></pre><p>and</p><pre><code class="language-none">midpoint(p1, p2)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/point.jl#L120-L131">source</a><br/></section><p><code>center3pts()</code> finds the radius and center point of a circle passing through three points which you can then use with functions such as <code>circle()</code> or <code>arc2r()</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.center3pts" href="#Luxor.center3pts"><code>Luxor.center3pts</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">center3pts(a::Point, b::Point, c::Point)</code></pre><p>Find the radius and center point for three points lying on a circle.</p><p>returns <code>(centerpoint, radius)</code> of a circle. Then you can use <code>circle()</code> to place a circle, or <code>arc()</code> to draw an arc passing through those points.</p><p>If there&#39;s no such circle, then you&#39;ll see an error message in the console and the function returns <code>(Point(0,0), 0)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L38-L48">source</a><br/></section><p><code>intersection()</code> finds the intersection of two lines.</p><div><pre><code class="language-julia">pt1, pt2, pt3, pt4 = ngon(O, 100, 5, vertices=true)
line(pt1, pt2, :stroke)
line(pt3, pt4, :stroke)
flag, ip =  intersection(pt1, pt2, pt3, pt4)
if flag
    circle(ip, 5, :fill)
end</code></pre></div><p><img src="assets/figures/intersection.png" alt="arc"/></p><p><code>intersection_line_circle()</code> finds the intersection of a line and a circle. There can be 0, 1, or 2 intersections.</p><div><pre><code class="language-julia">l1 = Point(-100.0, -75.0)
l2 = Point(300.0, 100.0)
rad = 100
cpoint = Point(0, 0)
line(l1, l2, :stroke)
circle(cpoint, rad, :stroke)
nints, ip1, ip2 =  intersection_line_circle(l1, l2, cpoint, rad)
sethue(&quot;black&quot;)
if nints == 2
    circle(ip1, 8, :stroke)
    circle(ip2, 8, :stroke)
end</code></pre></div><p><img src="assets/figures/intersection_line_circle.png" alt="arc"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.intersection" href="#Luxor.intersection"><code>Luxor.intersection</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">intersection(p1::Point, p2::Point, p3::Point, p4::Point)</code></pre><p>Find intersection of two lines <code>p1</code>-<code>p2</code> and <code>p3</code>-<code>p4</code></p><p>This returns a tuple: <code>(boolean, point(x, y))</code>.</p><p>Keyword options and default values:</p><pre><code class="language-none">crossingonly = false</code></pre><p>returns <code>(true, Point(x, y))</code> if the lines intersect somewhere. If <code>crossingonly = true</code>, returns <code>(false, intersectionpoint)</code> if the lines don&#39;t cross, but would intersect at <code>intersectionpoint</code> if continued beyond their current endpoints.</p><pre><code class="language-none">commonendpoints = false</code></pre><p>If <code>commonendpoints= true</code>, will return <code>(false, Point(0, 0))</code> if the lines share a common end point (because that&#39;s not so much an intersection, more a meeting).</p><p>Function returns <code>(false, Point(0, 0))</code> if the lines are undefined,</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/point.jl#L204-L225">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.intersection_line_circle" href="#Luxor.intersection_line_circle"><code>Luxor.intersection_line_circle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">intersection_line_circle(p1::Point, p2::Point, cpoint::Point, r)</code></pre><p>Find the intersection points of a line (extended through points <code>p1</code> and <code>p2</code>) and a circle.</p><p>Return a tuple of <code>(n, pt1, pt2)</code></p><p>where</p><ul><li><p><code>n</code> is the number of intersections, <code>0</code>, <code>1</code>, or <code>2</code></p></li><li><p><code>pt1</code> is first intersection point, or <code>Point(0, 0)</code> if none</p></li><li><p><code>pt2</code> is the second intersection point, or <code>Point(0, 0)</code> if none</p></li></ul><p>The calculated intersection points wont necessarily lie on the line segment between <code>p1</code> and <code>p2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/point.jl#L302-L316">source</a><br/></section><p><code>getnearestpointonline()</code> finds perpendiculars.</p><div><pre><code class="language-julia">end1, end2, pt3 = ngon(O, 100, 3, vertices=true)
map(pt -&gt; circle(pt, 5, :fill), [end1, end2, pt3])
line(end1, end2, :stroke)
arrow(pt3, getnearestpointonline(end1, end2, pt3))</code></pre></div><p><img src="assets/figures/perpendicular.png" alt="arc"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.getnearestpointonline" href="#Luxor.getnearestpointonline"><code>Luxor.getnearestpointonline</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getnearestpointonline(pt1::Point, pt2::Point, startpt::Point)</code></pre><p>Given a line from <code>pt1</code> to <code>pt2</code>, and <code>startpt</code> is the start of a perpendicular heading to meet the line, at what point does it hit the line?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/point.jl#L87-L92">source</a><br/></section><h2><a class="nav-anchor" id="Arrows-1" href="#Arrows-1">Arrows</a></h2><p>You can draw lines or arcs with arrows at the end with <code>arrow()</code>. For straight arrows, supply the start and end points. For arrows as circular arcs, you provide center, radius, and start and finish angles. You can optionally provide dimensions for the <code>arrowheadlength</code> and <code>arrowheadangle</code> of the tip of the arrow (angle in radians between side and center). The default line weight is 1.0, equivalent to <code>setline(1)</code>), but you can specify another.</p><div><pre><code class="language-julia">arrow(O, Point(0, -65))
arrow(O, Point(100, -65), arrowheadlength=20, arrowheadangle=pi/4, linewidth=.3)
arrow(O, 100, pi, pi/2, arrowheadlength=25,   arrowheadangle=pi/12, linewidth=1.25)</code></pre></div><p><img src="assets/figures/arrow.png" alt="arrows"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.arrow" href="#Luxor.arrow"><code>Luxor.arrow</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">arrow(startpoint::Point, endpoint::Point;
    linewidth = 1.0,
    arrowheadlength = 10,
    arrowheadangle = pi/8)</code></pre><p>Draw a line between two points and add an arrowhead at the end. The arrowhead length will be the length of the side of the arrow&#39;s head, and the arrowhead angle is the angle between the sloping side of the arrowhead and the arrow&#39;s shaft.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>), and defaults to 1, but you can specify another value. It doesn&#39;t need stroking/filling, the shaft is <code>stroke()</code>d and the head <code>fill()</code>ed with the current color.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/arrows.jl#L1-L15">source</a><br/><div><pre><code class="language-none">arrow(centerpos::Point, radius, startangle, endangle;
    linewidth = 1.0,
    arrowheadlength = 10,
    arrowheadangle = pi/8)</code></pre><p>Draw a curved arrow, an arc centered at <code>centerpos</code> starting at <code>startangle</code> and ending at <code>endangle</code> with an arrowhead at the end. Angles are measured clockwise from the positive x-axis.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>); you can specify the linewidth.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/arrows.jl#L54-L65">source</a><br/></section><h2><a class="nav-anchor" id="Paths-1" href="#Paths-1">Paths</a></h2><p>A path is a group of points. A path can have subpaths (which can form holes).</p><p>The <code>getpath()</code> function gets the current path as an array of elements, lines and curves. <code>getpathflat()</code> gets the current path as an array of lines with all curves flattened to line segments.</p><div><pre><code class="language-julia">textpath(&quot;N&quot;)
pathdata = getpathflat()
outline = Point[]
for i in pathdata[1:end-1]
    if length(i.points) == 2
        x = i.points[1]
        y = i.points[2]
        push!(outline, Point(x, y))
    end
end
poly(outline, :stroke, close=true)
for i in 5:5:35
    poly(offsetpoly(outline, i), :stroke, close=true)
end</code></pre></div><p><img src="assets/figures/get-path.png" alt="get path"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.newpath" href="#Luxor.newpath"><code>Luxor.newpath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">newpath()</code></pre><p>Create a new path. This is Cairo&#39;s <code>new_path()</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L369-L373">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.newsubpath" href="#Luxor.newsubpath"><code>Luxor.newsubpath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">newsubpath()</code></pre><p>Add a new subpath to the current path. This is Cairo&#39;s <code>new_sub_path()</code> function. It can be used for example to make holes in shapes.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L376-L381">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.closepath" href="#Luxor.closepath"><code>Luxor.closepath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">closepath()</code></pre><p>Close the current path. This is Cairo&#39;s <code>close_path()</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L384-L388">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.getpath" href="#Luxor.getpath"><code>Luxor.getpath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getpath()</code></pre><p>Get the current path and return a CairoPath object, which is an array of <code>element_type</code> and <code>points</code> objects. With the results you can step through and examine each entry:</p><pre><code class="language-none">o = getpath()
for e in o
      if e.element_type == Cairo.CAIRO_PATH_MOVE_TO
          (x, y) = e.points
          move(x, y)
      elseif e.element_type == Cairo.CAIRO_PATH_LINE_TO
          (x, y) = e.points
          # straight lines
          line(x, y)
          stroke()
          circle(x, y, 1, :stroke)
      elseif e.element_type == Cairo.CAIRO_PATH_CURVE_TO
          (x1, y1, x2, y2, x3, y3) = e.points
          # Bezier control lines
          circle(x1, y1, 1, :stroke)
          circle(x2, y2, 1, :stroke)
          circle(x3, y3, 1, :stroke)
          move(x, y)
          curve(x1, y1, x2, y2, x3, y3)
          stroke()
          (x, y) = (x3, y3) # update current point
      elseif e.element_type == Cairo.CAIRO_PATH_CLOSE_PATH
          closepath()
      else
          error(&quot;unknown CairoPathEntry &quot; * repr(e.element_type))
          error(&quot;unknown CairoPathEntry &quot; * repr(e.points))
      end
  end</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L725-L761">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.getpathflat" href="#Luxor.getpathflat"><code>Luxor.getpathflat</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getpathflat()</code></pre><p>Get the current path, like <code>getpath()</code> but flattened so that there are no Bèzier curves.</p><p>Returns a CairoPath which is an array of <code>element_type</code> and <code>points</code> objects.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/Luxor.jl#L764-L770">source</a><br/></section><h2><a class="nav-anchor" id="Julia-graphics-1" href="#Julia-graphics-1">Julia graphics</a></h2><p>A couple of functions in Luxor provide you with instant access to the Julia logo, and the three colored circles:</p><div><pre><code class="language-julia">for (pos, n) in Tiler(750, 250, 1, 2)
    gsave()
    translate(pos - Point(150, 100))
    if n == 1
        julialogo()
    elseif n == 2
        julialogo(action=:clip)
        for i in 1:500
            gsave()
            translate(rand(0:400), rand(0:250))
            juliacircles(10)
            grestore()
        end
        clipreset()
    end
    grestore()
end</code></pre></div><p><img src="assets/figures/julia-logo.png" alt="get path"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.julialogo" href="#Luxor.julialogo"><code>Luxor.julialogo</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">julialogo(;action=:fill, color=true)</code></pre><p>Draw the Julia logo. The logo&#39;s dimensions are about 330 wide and 240 high:</p><pre><code class="language-none">translate(-330/2, -240/2)
julialogo()</code></pre><p>The default action is to fill the logo and use colors:</p><pre><code class="language-none">julialogo()</code></pre><p>To use the logo as a clipping mask:</p><pre><code class="language-none">julialogo(action=:clip)</code></pre><p>(In this case the <code>color</code> setting is automatically ignored.)</p><p>If <code>color</code> is <code>false</code>, the logo will use the current color.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/juliagraphics.jl#L3-L23">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.juliacircles" href="#Luxor.juliacircles"><code>Luxor.juliacircles</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">juliacircles(radius=100)</code></pre><p>Draw the three Julia circles in color at the origin using the given radius.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/juliagraphics.jl#L183-L187">source</a><br/></section><h2><a class="nav-anchor" id="Miscellaneous-1" href="#Miscellaneous-1">Miscellaneous</a></h2><p><code>hypotrochoid()</code> makes hypotrochoids.</p><div><pre><code class="language-julia">origin()
background(&quot;grey20&quot;)
sethue(&quot;antiquewhite&quot;)
setline(1.5)
hypotrochoid(40, 1, 80, :stroke, stepby=pi/2000, period=pi)</code></pre></div><p><img src="assets/figures/hypotrochoid.png" alt="hypotrochoid"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.hypotrochoid" href="#Luxor.hypotrochoid"><code>Luxor.hypotrochoid</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hypotrochoid(R, r, d, action=:none; stepby=0.1, period=0)</code></pre><p>Draw a hypotrochoid with short line segments. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius <code>r</code> rolling around the inside  of a fixed circle of radius <code>R</code>, where the point is a distance <code>d</code> from  the center of the interior circle.</p><p><code>stepby</code> controls the detail level. If <code>period</code> is not supplied, or 0, the lowest period is calculated (somewhat approximately at the moment), and also returned in terms of <code>2pi</code>.</p><p>Special cases include the hypocycloid, if <code>d</code> = <code>r</code>, and an ellipse, if <code>R</code> = <code>2r</code>.</p><p>The polygon might be split if the number of line segments gets too large (currently over 1200).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/tree/43997ffeb7cadd23b60c38b91dd5077d5d94d54a/src/curves.jl#L410-L424">source</a><br/></section><footer><hr/><a class="previous" href="examples.html"><span class="direction">Previous</span><span class="title">A few examples</span></a><a class="next" href="styling.html"><span class="direction">Next</span><span class="title">Styling</span></a></footer></article></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Use geometry tools · Luxor</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/luxor-docs.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Luxor logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Luxor</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction to Luxor</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial/basictutorial/">A first tutorial</a></li><li><a class="tocitem" href="../../tutorial/quickstart/">Quick start</a></li><li><a class="tocitem" href="../../tutorial/simple-animation/">Simple animations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../example/examples/">Simple examples</a></li><li><a class="tocitem" href="../../example/moreexamples/">More examples</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox" checked/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../createdrawings/">Create drawings</a></li><li><a class="tocitem" href="../simplegraphics/">Draw simple shapes</a></li><li class="is-active"><a class="tocitem" href>Use geometry tools</a><ul class="internal"><li><a class="tocitem" href="#Lines-and-distances"><span>Lines and distances</span></a></li><li><a class="tocitem" href="#Points-and-arcs"><span>Points and arcs</span></a></li><li><a class="tocitem" href="#Triangle-centers"><span>Triangle centers</span></a></li><li><a class="tocitem" href="#Intersections"><span>Intersections</span></a></li><li><a class="tocitem" href="#Bounding-boxes"><span>Bounding boxes</span></a></li><li><a class="tocitem" href="#Noise"><span>Noise</span></a></li></ul></li><li><a class="tocitem" href="../tables-grids/">Work with tables and grids</a></li><li><a class="tocitem" href="../colors-styles/">Use colors and styles</a></li><li><a class="tocitem" href="../polygons/">Work with polygons</a></li><li><a class="tocitem" href="../text/">Add text</a></li><li><a class="tocitem" href="../clipping/">Clip graphics</a></li><li><a class="tocitem" href="../images/">Placing images</a></li><li><a class="tocitem" href="../turtle/">Turtle graphics</a></li><li><a class="tocitem" href="../animation/">Make animations</a></li><li><a class="tocitem" href="../livegraphics/">Live graphics and snapshots</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/basics/">Basic concepts</a></li><li><a class="tocitem" href="../../explanation/imagematrix/">Image matrix</a></li><li><a class="tocitem" href="../../explanation/perfectpixels/">Perfect pixels and antialising</a></li><li><a class="tocitem" href="../../explanation/transforms/">Transforms and matrices</a></li><li><a class="tocitem" href="../../explanation/contributing/">Contributing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox"/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../reference/functionindex/">Alphabetical function list</a></li><li><a class="tocitem" href="../../reference/api/">Function reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">How to guides</a></li><li class="is-active"><a href>Use geometry tools</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Use geometry tools</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphics/Luxor.jl/blob/master/docs/src/howto/geometrytools.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Geometry-tools"><a class="docs-heading-anchor" href="#Geometry-tools">Geometry tools</a><a id="Geometry-tools-1"></a><a class="docs-heading-anchor-permalink" href="#Geometry-tools" title="Permalink"></a></h1><h2 id="Lines-and-distances"><a class="docs-heading-anchor" href="#Lines-and-distances">Lines and distances</a><a id="Lines-and-distances-1"></a><a class="docs-heading-anchor-permalink" href="#Lines-and-distances" title="Permalink"></a></h2><p>You can find the midpoint between two points using <a href="../../reference/api/#Luxor.midpoint-Tuple{Array}"><code>midpoint</code></a>.</p><p>The following code places a small pentagon (using <a href="../../reference/api/#Luxor.ngon"><code>ngon</code></a>) at the midpoint of each side of a larger pentagon:</p><pre><code class="language-julia">sethue(&quot;red&quot;)
ngon(O, 100, 5, 0, :stroke)

sethue(&quot;darkgreen&quot;)
p5 = ngon(O, 100, 5, 0, vertices=true)

for i in eachindex(p5)
    pt1 = p5[mod1(i, 5)]
    pt2 = p5[mod1(i + 1, 5)]
    ngon(midpoint(pt1, pt2), 20, 5, 0, :fill)
end</code></pre><p><img src="../../assets/figures/midpoint.png" alt="arc"/></p><p>A more general function, <a href="../../reference/api/#Luxor.between"><code>between</code></a>, finds for a value <code>x</code> between 0 and 1 the corresponding point on a line defined by two points. So <code>midpoint(p1, p2)</code> and <code>between(p1, p2, 0.5)</code> should return the same point.</p><pre><code class="language-julia">sethue(&quot;red&quot;)
p1 = Point(-150, 0)
p2 = Point(150, 40)
line(p1, p2)
strokepath()
for i in -0.5:0.1:1.5
    randomhue()
    circle(between(p1, p2, i), 5, :fill)
end</code></pre><p><img src="../../assets/figures/betweenpoint.png" alt="arc"/></p><p>Values less than 0.0 and greater than 1.0 appear to work well too, placing the point on the line if extended.</p><p><a href="../../reference/api/#Luxor.center3pts-Tuple{Point, Point, Point}"><code>center3pts</code></a> finds the radius and center point of a circle passing through three points which you can then use with functions such as <a href="../../reference/api/#Luxor.circle"><code>circle</code></a> or <a href="../../reference/api/#Luxor.arc2r"><code>arc2r</code></a>.</p><p><a href="../../reference/api/#Luxor.getnearestpointonline-Tuple{Point, Point, Point}"><code>getnearestpointonline</code></a> finds perpendiculars, as does <a href="../../reference/api/#Luxor.perpendicular-Tuple{Point, Point, Any}"><code>perpendicular</code></a>.</p><pre><code class="language-julia">pt1, pt2 = Point(-150, 0), Point(150, 50)
line(pt1, pt2, :stroke)

pt3 = Point(-50, -80)
circle.([pt1, pt2, pt3], 3, :fill)

p = getnearestpointonline(pt1, pt2, pt3)
sethue(&quot;red&quot;)
arrow(pt3, p)
circle(pt3, 4, :fill)

pt4, pt5 = perpendicular(pt1, pt2)
setline(3)

sethue(&quot;black&quot;)
label.(string.([&quot;p&quot;, &quot;pt1&quot;, &quot;pt2&quot;, &quot;pt3&quot;, &quot;pt4&quot;, &quot;pt5&quot;]), :ne, (p, pt1, pt2, pt3, pt4, pt5))

sethue(&quot;green&quot;)
arrow(pt4, pt5)
circle.([pt4, pt5], 4, :fill)</code></pre><p><img src="../../assets/figures/perpendicular.svg" alt="arc"/></p><h2 id="Points-and-arcs"><a class="docs-heading-anchor" href="#Points-and-arcs">Points and arcs</a><a id="Points-and-arcs-1"></a><a class="docs-heading-anchor-permalink" href="#Points-and-arcs" title="Permalink"></a></h2><p>Use <code>isarcclockwise(c, p1, p2)</code> to check whether an arc centered at <code>c</code> running from <code>p1</code> to <code>p2</code> is clockwise.</p><p>The <a href="../../reference/api/#Luxor.pointinverse-Tuple{Point, Any, Any}"><code>pointinverse</code></a> function finds the inverse of a point relative to a reference circle (centerpoint and radius). In the image, each vertex on the star is linked by an arrow to its inverse.</p><pre><code class="language-julia">radius = 80
starradius = 70
sethue(&quot;black&quot;)
points = star(O, starradius, 5, 0.5, π/5, vertices=true)
antipoints = last.(pointinverse.(points, O, radius))

@layer (sethue(&quot;grey90&quot;); poly(antipoints, :fill))
@layer (sethue(&quot;grey75&quot;); poly(points, :fill))
circle(O, radius, :stroke)

prettypoly.((points, antipoints), :none,
    vertexlabels = (n, l) -&gt; (label(string(n), :ne)))
foreach(x -&gt; arrow(x[1] , x[2]), zip(points, antipoints))</code></pre><p><img src="../../assets/figures/pointinverse.png" alt="arc"/></p><p>Use <a href="../../reference/api/#Luxor.anglethreepoints-Tuple{Point, Point, Point}"><code>anglethreepoints</code></a> to find the angle formed by two lines connecting three points:</p><pre><code class="language-julia">function showangle(pt1, pt2, pt3)
    θ = anglethreepoints(pt1, pt2, pt3)
    label(string(round(rad2deg(θ), digits=2), &quot;°&quot;), :w, pt2)
    newpath()
    carc(pt2, 50, 0, -θ, 0)
    strokepath()
end

let
    background(&quot;grey20&quot;)
    sethue(&quot;white&quot;)
    fontsize(12)
    tiles = Tiler(800, 800, 4, 4)
    for (pos, n) in tiles
        @layer begin
            translate(pos)
            pg = [polar(50, 0), O, polar(50, n * -2π/16)]
            poly(pg, :stroke)
            for n in 1:3
                pt1 = pg[1]
                pt2 = pg[2]
                pt3 = pg[3]
                showangle(pt1, pt2, pt3)
            end
        end
    end
end</code></pre><p><img src="../../assets/figures/anglethreepoints.png" alt="angle three points"/></p><p>Functions that help with geometry include <a href="../../reference/api/#Luxor.distance-Tuple{Point, Point}"><code>distance</code></a>, <a href="../../reference/api/#Luxor.getnearestpointonline-Tuple{Point, Point, Point}"><code>getnearestpointonline</code></a>, <a href="../../reference/api/#Luxor.pointlinedistance-Tuple{Point, Point, Point}"><code>pointlinedistance</code></a>, <a href="../../reference/api/#Luxor.slope-Tuple{Any, Any}"><code>slope</code></a>, <a href="../../reference/api/#Luxor.perpendicular-Tuple{Point, Point, Any}"><code>perpendicular</code></a>, <a href="../../reference/api/#Luxor.dotproduct-Tuple{Point, Point}"><code>dotproduct</code></a>, <a href="../../reference/api/#Luxor.@polar-Tuple{Any}"><code>@polar</code></a>, <a href="../../reference/api/#Luxor.polar-Tuple{Any, Any}"><code>polar</code></a>, <a href="../../reference/api/#Luxor.ispointonline-Tuple{Point, Point, Point}"><code>ispointonline</code></a>, <a href="../../reference/api/#Luxor.isarcclockwise-Tuple{Point, Point, Point}"><code>isarcclockwise</code></a>, <a href="../../reference/api/#Luxor.pointinverse-Tuple{Point, Any, Any}"><code>pointinverse</code></a>, <a href="../../reference/api/#Luxor.anglethreepoints-Tuple{Point, Point, Point}"><code>anglethreepoints</code></a>.</p><h2 id="Triangle-centers"><a class="docs-heading-anchor" href="#Triangle-centers">Triangle centers</a><a id="Triangle-centers-1"></a><a class="docs-heading-anchor-permalink" href="#Triangle-centers" title="Permalink"></a></h2><p>To find the center  of a triangle, use one of <a href="../../reference/api/#Luxor.trianglecircumcenter-Tuple{Point, Point, Point}"><code>trianglecircumcenter</code></a>, <a href="../../reference/api/#Luxor.triangleincenter-Tuple{Point, Point, Point}"><code>triangleincenter</code></a>, <a href="../../reference/api/#Luxor.trianglecenter-Tuple{Point, Point, Point}"><code>trianglecenter</code></a>, <a href="../../reference/api/#Luxor.triangleorthocenter-Tuple{Point, Point, Point}"><code>triangleorthocenter</code></a>.</p><pre><code class="language-julia">▲ = Point[Point(-100.0, 0.0), Point(110.0, 30.0), Point(65.0, 90.0)]

@layer begin
    sethue(&quot;red&quot;)
    setline(2)
    poly(▲,  :stroke, close=true)
end

# circumcenter
circle(▲..., :stroke)
cp = trianglecircumcenter(▲...)
circle(cp, 2, :fill)
label(&quot;circumcenter&quot;, :N, cp)

# incenter
cp = triangleincenter(▲...)
circle(cp, 2, :fill)
pt1 = getnearestpointonline(▲[1], ▲[2], cp)
@layer begin
    sethue(&quot;black&quot;)
    circle(cp, distance(cp, pt1), :stroke)
    label(&quot;incenter&quot;, :S, cp)
end

# center
cp = trianglecenter(▲...)
circle(cp, 2, :fill)
label(&quot;center&quot;, :w, cp)

# orthocenter
cp = triangleorthocenter(▲...)
circle(cp, 2, :fill)
label(&quot;orthocenter&quot;, :e, cp)</code></pre><p><img src="../../assets/figures/trianglecenters.svg" alt="triangle centers"/></p><h2 id="Intersections"><a class="docs-heading-anchor" href="#Intersections">Intersections</a><a id="Intersections-1"></a><a class="docs-heading-anchor-permalink" href="#Intersections" title="Permalink"></a></h2><p><a href="../../reference/api/#Luxor.intersectionlines-NTuple{4, Point}"><code>intersectionlines</code></a> finds the intersection of two lines.</p><pre><code class="language-julia">sethue(&quot;black&quot;)
P1, P2, P3, P4 = ngon(O, 100, 5, vertices=true)
label.([&quot;P1&quot;, &quot;P2&quot;, &quot;P3&quot;, &quot;P4&quot;], :N, [P1, P2, P3, P4])
line(P1, P2, :stroke)
line(P4, P3, :stroke)

flag, ip =  intersectionlines(P1, P2, P4, P3)
if flag
    circle(ip, 5, :fill)
end</code></pre><p><img src="../../assets/figures/intersection.png" alt="arc"/></p><p><a href="../../reference/api/#Luxor.intersectionlinecircle-Tuple{Point, Point, Point, Any}"><code>intersectionlinecircle</code></a> finds the intersection of a line and a circle. There can be 0, 1, or 2 intersection points.</p><pre><code class="language-julia">l1 = Point(-100.0, -75.0)
l2 = Point(300.0, 100.0)
rad = 100
cpoint = Point(0, 0)
line(l1, l2, :stroke)
circle(cpoint, rad, :stroke)
nints, ip1, ip2 =  intersectionlinecircle(l1, l2, cpoint, rad)
sethue(&quot;black&quot;)
if nints == 2
    circle(ip1, 8, :stroke)
    circle(ip2, 8, :stroke)
end</code></pre><p><img src="../../assets/figures/intersection_line_circle.png" alt="arc"/></p><p><a href="../../reference/api/#Luxor.intersection2circles-NTuple{4, Any}"><code>intersection2circles</code></a> finds the area of the intersection of two circles, and <a href="../../reference/api/#Luxor.intersectioncirclecircle-NTuple{4, Any}"><code>intersectioncirclecircle</code></a> finds the points where they cross.</p><p>This example shows the areas of two circles, and the area of their intersection.</p><pre><code class="language-julia">c1 = (O, 150)
c2 = (O + (100, 0), 150)

circle(c1... , :stroke)
circle(c2... , :stroke)

sethue(&quot;purple&quot;)
circle(c1... , :clip)
circle(c2... , :fill)
clipreset()

sethue(&quot;black&quot;)

text(string(150^2 * π |&gt; round), c1[1] - (125, 0))
text(string(150^2 * π |&gt; round), c2[1] + (100, 0))
sethue(&quot;white&quot;)
text(string(intersection2circles(c1..., c2...) |&gt; round),
     midpoint(c1[1], c2[1]), halign=:center)

sethue(&quot;red&quot;)
flag, C, D = intersectioncirclecircle(c1..., c2...)
if flag
    circle.([C, D], 5, :fill)
end</code></pre><p><img src="../../assets/figures/intersection2circles.png" alt="intersection of two circles"/></p><h2 id="Bounding-boxes"><a class="docs-heading-anchor" href="#Bounding-boxes">Bounding boxes</a><a id="Bounding-boxes-1"></a><a class="docs-heading-anchor-permalink" href="#Bounding-boxes" title="Permalink"></a></h2><p>The <code>BoundingBox</code> type allows you to use rectangular extents to organize and interact with the 2D drawing area. A <code>BoundingBox</code> holds two points, the opposite corners of a bounding box.</p><p>You can make a BoundingBox from the current drawing, two points, a text string, an existing polygon, or by modifying an existing one.</p><p><code>BoundingBox</code> without arguments defines an extent that encloses the drawing (assuming that the origin is at the center of the drawing—see <a href="../../reference/api/#Luxor.origin-Tuple{Any}"><code>origin</code></a>). Use <code>centered=false</code> if the drawing origin is still at the top left corner.</p><p>This example draws circles at three points: at two of the drawing&#39;s corners and the midway point between them:</p><pre><code class="language-julia">origin()

bb = BoundingBox()
setline(10)
sethue(&quot;orange&quot;)

circle(bb[1], 150, :stroke) # first corner

circle(bb[2], 150, :stroke) # second corner

circle(midpoint(bb...), 150, :stroke) # midpoint

sethue(&quot;blue&quot;)
circle.([bb[1], midpoint(bb[1:2]), bb[2]], 130, :fill)

sethue(&quot;red&quot;)
circle.([first(bb), midpoint(bb...), last(bb)], 100, :fill)</code></pre><p><img src="../../assets/figures/bbox.png" alt="bounding box"/></p><p>You can make a bounding box from a polygon:</p><pre><code class="language-julia">p = star(O, 100, 5, 0.1, π/3.3, vertices=true)
sethue(&quot;antiquewhite&quot;)
box(BoundingBox(p), :fill)

sethue(&quot;black&quot;)
poly(p, :stroke, close=true)</code></pre><p><img src="../../assets/figures/bboxpoly.png" alt="bounding box of polygon"/></p><p>The resulting bounding box objects can be passed to <a href="../../reference/api/#Luxor.box"><code>box</code></a> or <a href="../../reference/api/#Luxor.poly"><code>poly</code></a> to be drawn.</p><p>To convert a bounding box <code>b</code> into a box, use <code>box(b, vertices=true)</code> or <code>convert(Vector{Point}, BoundingBox())</code>.</p><p>You can also do some arithmetic on bounding boxes. In the next example, the bounding box is created from the text &quot;good afternoon&quot;. The bounding box is filled with purple, then increased by 40 units on all sides (blue), also scaled by 1.3 (green), and also shifted by <code>(0, 100)</code> (orange).</p><pre><code class="language-julia">translate(-130,0)
fontsize(40)
str = &quot;good afternoon&quot;
sethue(&quot;purple&quot;)
box(BoundingBox(str), :fill)
sethue(&quot;white&quot;)
text(str)

sethue(&quot;blue&quot;)
modbox = BoundingBox(str) + 40 # add 40 units to all sides
poly(modbox, :stroke, close=true)

sethue(&quot;green&quot;)
modbox = BoundingBox(str) * 1.3
poly(modbox, :stroke, close=true)

sethue(&quot;orange&quot;)
modbox = BoundingBox(str) + (0, 100)
poly(modbox, :fill, close=true)</code></pre><p><img src="../../assets/figures/bbox2.png" alt="bounding boxes 2"/></p><p>You can find the union and intersection of BoundingBoxes, and also find whether a point lies inside one. The following code creates, shrinks, and shifts two bounding boxes (colored yellow and pink), and then draws: their union (a bounding box that includes both), in black outline; and their intersection (a bounding box of their common areas), in red. Then some random points are created (you can pass a bounding box to[<code>rand</code> to get a random point inside the box) and drawn differently depending on whether they&#39;re inside the intersection or outside.</p><pre><code class="language-julia">origin()
setopacity(0.75)
setline(8)

bbox1 = BoundingBox()/2 - (50, 30)
sethue(&quot;yellow&quot;)
box(bbox1, :fill)

bbox2 = BoundingBox()/2  + (50, 30)
sethue(&quot;pink&quot;)
box(bbox2, :fill)

sethue(&quot;black&quot;)
box(bbox1 + bbox2, :stroke)

sethue(&quot;red&quot;)
bothboxes = intersectboundingboxes(bbox1, bbox2)
box(bothboxes, :fill)

for i in 1:500
    pt = rand(bbox1 + bbox2)
    if isinside(pt, bothboxes)
        sethue(&quot;white&quot;)
        circle(pt, 3, :fill)
    else
        sethue(&quot;black&quot;)
        circle(pt, 2, :fill)
    end
end</code></pre><p><img src="../../assets/figures/bbox3.png" alt="intersecting bounding boxes"/></p><p>To find out where a line starting at the center of a bounding box passing through a point crosses or would cross the edges of the box, use <a href="../../reference/api/#Luxor.pointcrossesboundingbox-Tuple{Any, BoundingBox}"><code>pointcrossesboundingbox</code></a>.</p><pre><code class="language-julia">bx = BoundingBox(box(O, 200, 200, :none))
setline(1)
box(bx, :stroke)
for i in 1:10
    pt = randompoint((1.5bx)...)
    pt2 = pointcrossesboundingbox(pt, bx)

    sethue(&quot;grey50&quot;)
    arrow(O, pt)
    sethue(&quot;red&quot;)
    circle(pt2, 3, :stroke)
end</code></pre><p><img src="../../assets/figures/bbox4.png" alt="point crosses bounding box"/></p><h2 id="Noise"><a class="docs-heading-anchor" href="#Noise">Noise</a><a id="Noise-1"></a><a class="docs-heading-anchor-permalink" href="#Noise" title="Permalink"></a></h2><p>For artistic graphics you might prefer noisy input values to purely random ones. Use the <a href="../../reference/api/#Luxor.noise-Union{Tuple{Any}, Tuple{T}} where T&lt;:Integer"><code>noise</code></a> function to obtain smoothly changing random values corresponding to input coordinates. The returned values wander slowly rather than jump about everywhere.</p><p>In this example, the gray value varies gradually as the <a href="../../reference/api/#Luxor.noise-Union{Tuple{Any}, Tuple{T}} where T&lt;:Integer"><code>noise</code></a> function returns values between 0 and 1 depending on the location of the two input values <code>pos.x</code> and <code>pos.y</code>.</p><p>The top two quadrants use a lower value for the <code>detail</code> keyword argument, an integer ()&gt;= 1) specifying how many &quot;octaves&quot; of noise you want.</p><p>The left two quadrants use a lower value for the <code>persistence</code> keyword argument, a floating point number specifying how the amplitude diminishes for each successive level of detail. There is more fine detail when the persistence is higher, particularly when the <code>detail</code> setting is also high.</p><pre><code class="language-julia">tiles = Tiler(800, 400, 200, 200)
sethue(&quot;black&quot;)
for (pos, n) in tiles
    freq = 0.05
    pos.y &lt; 0 ? d = 1      : d = 4
    pos.x &lt; 0 ? pers = 0.3 : pers = 1.0
    ns = noise(freq * pos.x, freq * pos.y,
        detail=d,
        persistence=pers)
    setgray(ns)
    box(pos, tiles.tilewidth, tiles.tileheight, :fillstroke)
end</code></pre><p><img src="../../assets/figures/noise.png" alt="noise"/></p><p>Use <a href="../../reference/api/#Luxor.initnoise-Tuple{Any}"><code>initnoise</code></a> to initialize the noise behaviour.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../simplegraphics/">« Draw simple shapes</a><a class="docs-footer-nextpage" href="../tables-grids/">Work with tables and grids »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Tuesday 6 July 2021 17:42">Tuesday 6 July 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

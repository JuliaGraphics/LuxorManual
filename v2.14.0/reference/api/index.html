<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Function reference · Luxor</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/luxor-docs.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Luxor logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Luxor</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Introduction to Luxor</a></li><li><input class="collapse-toggle" id="menuitem-2" type="checkbox"/><label class="tocitem" for="menuitem-2"><span class="docs-label">Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorial/basictutorial/">A first tutorial</a></li><li><a class="tocitem" href="../../tutorial/quickstart/">Quick start</a></li><li><a class="tocitem" href="../../tutorial/simple-animation/">Simple animations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3" type="checkbox"/><label class="tocitem" for="menuitem-3"><span class="docs-label">Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../example/examples/">Simple examples</a></li><li><a class="tocitem" href="../../example/moreexamples/">More examples</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4" type="checkbox"/><label class="tocitem" for="menuitem-4"><span class="docs-label">How to guides</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../howto/createdrawings/">Create drawings</a></li><li><a class="tocitem" href="../../howto/simplegraphics/">Draw simple shapes</a></li><li><a class="tocitem" href="../../howto/geometrytools/">Use geometry tools</a></li><li><a class="tocitem" href="../../howto/tables-grids/">Work with tables and grids</a></li><li><a class="tocitem" href="../../howto/colors-styles/">Use colors and styles</a></li><li><a class="tocitem" href="../../howto/polygons/">Work with polygons</a></li><li><a class="tocitem" href="../../howto/text/">Add text</a></li><li><a class="tocitem" href="../../howto/clipping/">Clip graphics</a></li><li><a class="tocitem" href="../../howto/images/">Placing images</a></li><li><a class="tocitem" href="../../howto/turtle/">Turtle graphics</a></li><li><a class="tocitem" href="../../howto/animation/">Make animations</a></li><li><a class="tocitem" href="../../howto/livegraphics/">Live graphics and snapshots</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-5" type="checkbox"/><label class="tocitem" for="menuitem-5"><span class="docs-label">Explanations</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/basics/">Basic concepts</a></li><li><a class="tocitem" href="../../explanation/imagematrix/">Image matrix</a></li><li><a class="tocitem" href="../../explanation/perfectpixels/">Perfect pixels and antialising</a></li><li><a class="tocitem" href="../../explanation/transforms/">Transforms and matrices</a></li><li><a class="tocitem" href="../../explanation/contributing/">Contributing</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-6" type="checkbox" checked/><label class="tocitem" for="menuitem-6"><span class="docs-label">Reference</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../functionindex/">Alphabetical function list</a></li><li class="is-active"><a class="tocitem" href>Function reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Function reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Function reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphics/Luxor.jl/blob/master/docs/src/reference/api.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><article class="docstring"><header><a class="docstring-binding" id="Luxor.@draw" href="#Luxor.@draw"><code>Luxor.@draw</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@draw drawing-instructions [width] [height]</code></pre><p>Preview an PNG drawing, optionally specifying width and height (the default is 600 by 600). The drawing is stored in memory, not in a file on disk.</p><p><strong>Examples</strong></p><pre><code class="nohighlight">@draw circle(O, 20, :fill)

@draw circle(O, 20, :fill) 400

@draw circle(O, 20, :fill) 400 1200


@draw begin
         setline(10)
         sethue(&quot;purple&quot;)
         circle(O, 20, :fill)
      end


@draw begin
         setline(10)
         sethue(&quot;purple&quot;)
         circle(O, 20, :fill)
      end 1200 1200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L740-L769">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@drawsvg" href="#Luxor.@drawsvg"><code>Luxor.@drawsvg</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@drawsvg begin
    body
end w h</code></pre><p>Create and preview an SVG drawing. Like <code>@draw</code> but using SVG format.</p><p>Unlike <code>@draw</code> (PNG), there is no background, by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L1124-L1132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@eps" href="#Luxor.@eps"><code>Luxor.@eps</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@eps drawing-instructions [width] [height] [filename]</code></pre><p>Create and preview an EPS drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as <code>filename</code> if supplied, or <code>luxor-drawing(timestamp).eps</code>.</p><p>On some platforms, EPS files are converted automatically to PDF when previewed.</p><p><strong>Examples</strong></p><pre><code class="nohighlight">@eps circle(O, 20, :fill)

@eps circle(O, 20, :fill) 400

@eps circle(O, 20, :fill) 400 1200

@eps circle(O, 20, :fill) 400 1200 &quot;/tmp/A0-version&quot;

@eps circle(O, 20, :fill) 400 1200 &quot;/tmp/A0-version.eps&quot;

@eps begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end

@eps begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end 1200 1200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L692-L726">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@imagematrix" href="#Luxor.@imagematrix"><code>Luxor.@imagematrix</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@imagematrix drawing-instructions [width=256] [height=256]</code></pre><p>Create a drawing and return a matrix of the image.</p><p>This macro returns a matrix of pixels that represent the drawing produced by the vector graphics instructions. It uses the <code>image_as_matrix()</code> function.</p><p>The default drawing is 256 by 256 points.</p><p>You don&#39;t need <code>finish()</code> (the macro calls it), and it&#39;s not previewed by <code>preview()</code>.</p><pre><code class="nohighlight">m = @imagematrix begin
        sethue(&quot;red&quot;)
        box(O, 20, 20, :fill)
    end 60 60

julia&gt;  m[1220:1224] |&gt; show
    ARGB32[ARGB32(0.0N0f8,0.0N0f8,0.0N0f8,0.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8)]
</code></pre><p>If, for some strange reason you want to draw the matrix as another Luxor drawing again, use code such as this:</p><pre><code class="nohighlight">m = @imagematrix begin
        sethue(&quot;red&quot;)
        box(O, 20, 20, :fill)
        sethue(&quot;blue&quot;)
        box(O, 10, 40, :fill)
    end 60 60

function convertmatrixtocolors(m)
    return convert.(Colors.RGBA, m)
end

function drawimagematrix(m)
    d = Drawing(500, 500, &quot;/tmp/temp.png&quot;)
    origin()
    w, h = size(m)
    t = Tiler(500, 500, w, h)
    mi = convertmatrixtocolors(m)
    @show mi[30, 30]
    for (pos, n) in t
        c = mi[t.currentrow, t.currentcol]
        setcolor(c)
        box(pos, t.tilewidth -1, t.tileheight - 1, :fill)
    end
    finish()
    return d
end

drawimagematrix(m)</code></pre><p>Transparency</p><p>The default value for the cells in an image matrix is transparent black. (Luxor&#39;s default color is opaque black.)</p><pre><code class="nohighlight">julia&gt; @imagematrix begin
       end 2 2
2×2 reinterpret(ARGB32, ::Array{UInt32,2}):
 ARGB32(0.0,0.0,0.0,0.0)  ARGB32(0.0,0.0,0.0,0.0)
 ARGB32(0.0,0.0,0.0,0.0)  ARGB32(0.0,0.0,0.0,0.0)</code></pre><p>Setting the background to a partially or completely transparent value may give unexpected results:</p><pre><code class="nohighlight">julia&gt; @imagematrix begin
       background(1, 0.5, 0.0, 0.5) # semi-transparent orange
       end 2 2
2×2 reinterpret(ARGB32, ::Array{UInt32,2}):
 ARGB32(0.502,0.251,0.0,0.502)  ARGB32(0.502,0.251,0.0,0.502)
 ARGB32(0.502,0.251,0.0,0.502)  ARGB32(0.502,0.251,0.0,0.502)</code></pre><p>here the semi-transparent orange color has been partially applied to the transparent background.</p><pre><code class="nohighlight">julia&gt; @imagematrix begin
           sethue(1., 0.5, 0.0)
       paint()
       end 2 2
2×2 reinterpret(ARGB32, ::Array{UInt32,2}):
 ARGB32(1.0,0.502,0.0,1.0)  ARGB32(1.0,0.502,0.0,1.0)
 ARGB32(1.0,0.502,0.0,1.0)  ARGB32(1.0,0.502,0.0,1.0)</code></pre><p>picks up the default alpha of 1.0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L884-L984">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@imagematrix!" href="#Luxor.@imagematrix!"><code>Luxor.@imagematrix!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@imagematrix! buffer drawing-instructions [width=256] [height=256]</code></pre><p>Like <code>@imagematrix</code>, but use an existing UInt32 buffer.</p><pre><code class="nohighlight">w = 200
h  = 150
buffer = zeros(UInt32, w, h)
m = @imagematrix! buffer juliacircles(40) 200 150;
Images.RGB.(m)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L1032-L1044">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@layer-Tuple{Any}" href="#Luxor.@layer-Tuple{Any}"><code>Luxor.@layer</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">The `layer` macro is a shortcut for `gsave()` ... `grestore()`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L514-L516">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@pdf" href="#Luxor.@pdf"><code>Luxor.@pdf</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@pdf drawing-instructions [width] [height] [filename]</code></pre><p>Create and preview an PDF drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as <code>filename</code> if supplied, or <code>luxor-drawing(timestamp).pdf</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight">@pdf circle(O, 20, :fill)

@pdf circle(O, 20, :fill) 400

@pdf circle(O, 20, :fill) 400 1200

@pdf circle(O, 20, :fill) 400 1200 &quot;/tmp/A0-version&quot;

@pdf circle(O, 20, :fill) 400 1200 &quot;/tmp/A0-version.pdf&quot;

@pdf begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end

@pdf begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end 1200 1200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L645-L678">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@png" href="#Luxor.@png"><code>Luxor.@png</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@png drawing-instructions [width] [height] [filename]</code></pre><p>Create and preview an PNG drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as <code>filename</code>, if supplied, or <code>luxor-drawing(timestamp).png</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight">@png circle(O, 20, :fill)

@png circle(O, 20, :fill) 400

@png circle(O, 20, :fill) 400 1200

@png circle(O, 20, :fill) 400 1200 &quot;/tmp/round&quot;

@png circle(O, 20, :fill) 400 1200 &quot;/tmp/round.png&quot;

@png begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end


@png begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end 1200 1200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L598-L631">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@polar-Tuple{Any}" href="#Luxor.@polar-Tuple{Any}"><code>Luxor.@polar</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@polar (p)</code></pre><p>Convert a tuple of two numbers to a Point of x, y Cartesian coordinates.</p><pre><code class="nohighlight">@polar (10, pi/4)
@polar [10, pi/4]</code></pre><p>produces</p><pre><code class="nohighlight">Luxor.Point(7.0710678118654755, 7.071067811865475)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L400-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@savesvg" href="#Luxor.@savesvg"><code>Luxor.@savesvg</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@savesvg begin
    body
end w h</code></pre><p>Like <code>@drawsvg</code> but returns the raw SVG code of the drawing in a string. Uses <code>svgstring</code>.</p><p>Unlike <code>@draw</code> (PNG), there is no background, by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L1144-L1154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@setcolor_str-Tuple{Any}" href="#Luxor.@setcolor_str-Tuple{Any}"><code>Luxor.@setcolor_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><p>Set the current color to a string using a macro.</p><p>For example:</p><pre><code class="nohighlight">setcolor&quot;red&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L77-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@svg" href="#Luxor.@svg"><code>Luxor.@svg</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@svg drawing-instructions [width] [height] [filename]</code></pre><p>Create and preview an SVG drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as <code>filename</code> if supplied, or <code>luxor-drawing-(timestamp).svg</code>.</p><p><strong>Examples</strong></p><pre><code class="nohighlight">@svg circle(O, 20, :fill)

@svg circle(O, 20, :fill) 400

@svg circle(O, 20, :fill) 400 1200

@svg circle(O, 20, :fill) 400 1200 &quot;/tmp/test&quot;

@svg circle(O, 20, :fill) 400 1200 &quot;/tmp/test.svg&quot;

@svg begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end

@svg begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end 1200 1200</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L552-L584">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Tuple{Type{Vector{Point}}, BoundingBox}" href="#Base.convert-Tuple{Type{Vector{Point}}, BoundingBox}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">convert(Point, bbox::BoundingBox)</code></pre><p>Convert a BoundingBox to a four-point clockwise polygon.</p><pre><code class="nohighlight">convert(Vector{Point}, BoundingBox())</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L196-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.in-Tuple{Point, BoundingBox}" href="#Base.in-Tuple{Point, BoundingBox}"><code>Base.in</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">in(pt, bbox::BoundingBox)</code></pre><p>Test whether <code>pt</code> is inside <code>bbox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L482-L485">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.rand-Tuple{BoundingBox}" href="#Base.rand-Tuple{BoundingBox}"><code>Base.rand</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rand(bbox::BoundingBox)</code></pre><p>Return a random <code>Point</code> that lies inside <code>bbox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L474-L477">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Circle" href="#Luxor.Circle"><code>Luxor.Circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Circle(t::Turtle, radius=1.0)</code></pre><p>Draw a filled circle centered at the current position with the given radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L126-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Forward" href="#Luxor.Forward"><code>Luxor.Forward</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Forward(t::Turtle, d=1)</code></pre><p>Move the turtle forward by <code>d</code> units. The stored position is updated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.HueShift" href="#Luxor.HueShift"><code>Luxor.HueShift</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">HueShift(t::Turtle, inc=1.0)</code></pre><p>Shift the Hue of the turtle&#39;s pen forward by <code>inc</code>. Hue values range between 0 and 360. (Don&#39;t start with black, otherwise the saturation and brightness values will be black.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L189-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Message-Tuple{Turtle, Any}" href="#Luxor.Message-Tuple{Turtle, Any}"><code>Luxor.Message</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Message(t::Turtle, txt)</code></pre><p>Write some text at the current position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L177-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Orientation" href="#Luxor.Orientation"><code>Luxor.Orientation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Orientation(t::Turtle, r=0.0)</code></pre><p>Set the turtle&#39;s orientation to <code>r</code> degrees. See also <code>Turn</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Pen_opacity_random-Tuple{Turtle}" href="#Luxor.Pen_opacity_random-Tuple{Turtle}"><code>Luxor.Pen_opacity_random</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Pen_opacity_random(t::Turtle)</code></pre><p>Change the opacity of the pen to some value at random.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L261-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Pencolor-Tuple{Turtle, Any, Any, Any}" href="#Luxor.Pencolor-Tuple{Turtle, Any, Any, Any}"><code>Luxor.Pencolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Pencolor(t::Turtle, r, g, b)</code></pre><p>Set the Red, Green, and Blue colors of the turtle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L219-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Pendown-Tuple{Turtle}" href="#Luxor.Pendown-Tuple{Turtle}"><code>Luxor.Pendown</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Pendown(t::Turtle)</code></pre><p>Put that pen down and start drawing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L108-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Penup-Tuple{Turtle}" href="#Luxor.Penup-Tuple{Turtle}"><code>Luxor.Penup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Penup(t::Turtle)</code></pre><p>Pick that pen up and stop drawing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L117-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Penwidth-Tuple{Turtle, Any}" href="#Luxor.Penwidth-Tuple{Turtle, Any}"><code>Luxor.Penwidth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Penwidth(t::Turtle, w)</code></pre><p>Set the width of the line drawn.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Pop-Tuple{Turtle}" href="#Luxor.Pop-Tuple{Turtle}"><code>Luxor.Pop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Pop(t::Turtle)</code></pre><p>Lift the turtle&#39;s position and orientation off a stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L161-L165">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Push-Tuple{Turtle}" href="#Luxor.Push-Tuple{Turtle}"><code>Luxor.Push</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Push(t::Turtle)</code></pre><p>Save the turtle&#39;s position and orientation on a stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L150-L154">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Randomize_saturation-Tuple{Turtle}" href="#Luxor.Randomize_saturation-Tuple{Turtle}"><code>Luxor.Randomize_saturation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Randomize_saturation(t::Turtle)</code></pre><p>Randomize the saturation of the turtle&#39;s pen color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L205-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Rectangle" href="#Luxor.Rectangle"><code>Luxor.Rectangle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Rectangle(t::Turtle, width=10.0, height=10.0)</code></pre><p>Draw a filled rectangle centered at the current position with the given radius.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Reposition-Tuple{Turtle, Any, Any}" href="#Luxor.Reposition-Tuple{Turtle, Any, Any}"><code>Luxor.Reposition</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Reposition(t::Turtle, pos::Point)
Reposition(t::Turtle, x, y)</code></pre><p>Reposition: pick the turtle up and place it at another position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L241-L246">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Towards-Tuple{Turtle, Point}" href="#Luxor.Towards-Tuple{Turtle, Point}"><code>Luxor.Towards</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Towards(t::Turtle, pos::Point)</code></pre><p>Rotate the turtle to face towards a given point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Turn" href="#Luxor.Turn"><code>Luxor.Turn</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Turn(t::Turtle, r=5.0)</code></pre><p>Increase the turtle&#39;s rotation by <code>r</code> degrees. See also <code>Orientation</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor._argb32_to_rgba-Tuple{Any}" href="#Luxor._argb32_to_rgba-Tuple{Any}"><code>Luxor._argb32_to_rgba</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">_argb32_to_rgba(i)</code></pre><p>Convert a 32bit ARGB Int to a four value array:</p><pre><code class="nohighlight">_argb32_to_rgba(0xFF800000)

4-element Array{Float64,1}:
 1.0
 0.5019607843137255
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L782-L797">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.addstop-Tuple{Cairo.CairoPattern, Any, ColorTypes.Colorant}" href="#Luxor.addstop-Tuple{Cairo.CairoPattern, Any, ColorTypes.Colorant}"><code>Luxor.addstop</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">addstop(b::Blend, offset, col)
addstop(b::Blend, offset, (r, g, b, a))
addstop(b::Blend, offset, string)</code></pre><p>Add a color stop to a blend. The offset specifies the location along the blend&#39;s &#39;control vector&#39;, which varies between 0 (beginning of the blend) and 1 (end of the blend). For linear blends, the control vector is from the start point to the end point. For radial blends, the control vector is from any point on the start circle, to the corresponding point on the end circle.</p><p>Examples:</p><pre><code class="nohighlight">blendredblue = blend(Point(0, 0), 0, Point(0, 0), 1)
addstop(blendredblue, 0, setcolor(sethue(&quot;red&quot;)..., .2))
addstop(blendredblue, 1, setcolor(sethue(&quot;blue&quot;)..., .2))
addstop(blendredblue, 0.5, sethue(randomhue()...))
addstop(blendredblue, 0.5, setcolor(randomcolor()...))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/blends.jl#L71-L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.anglethreepoints-Tuple{Point, Point, Point}" href="#Luxor.anglethreepoints-Tuple{Point, Point, Point}"><code>Luxor.anglethreepoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">anglethreepoints(p1::Point, p2::Point, p3::Point)</code></pre><p>Find the angle formed by two lines defined by three points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L585-L589">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.animate-Tuple{Movie, Scene}" href="#Luxor.animate-Tuple{Movie, Scene}"><code>Luxor.animate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">animate(movie::Movie, scene::Scene; creategif=false, framerate=30)</code></pre><p>Create the movie defined in <code>movie</code> by rendering the frames define in <code>scene</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L235-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.animate-Tuple{Movie, Vector{Scene}}" href="#Luxor.animate-Tuple{Movie, Vector{Scene}}"><code>Luxor.animate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">animate(movie::Movie, scenelist::Array{Scene, 1};
    creategif=false,
    framerate=30,
    pathname=&quot;&quot;,
    tempdirectory=&quot;&quot;,
    usenewffmpeg=true)</code></pre><p>Create the movie defined in <code>movie</code> by rendering the frames define in the array of scenes in <code>scenelist</code>.</p><p>If <code>creategif</code> is <code>true</code>, the function attempts to call the <code>ffmpeg</code> utility on the resulting frames to build a GIF animation. This will be stored in <code>pathname</code> (an existing file will be overwritten; use a &quot;.gif&quot; suffix), or in <code>(movietitle).gif</code> in a temporary directory. <code>ffmpeg</code> should be installed and available, of course, if this is to work.</p><p>In suitable environments, the resulting animation is displayed in the Plots window.</p><p><strong>Example</strong></p><pre><code class="nohighlight">animate(bang, [
    Scene(bang, backdrop, 0:200),
    Scene(bang, frame1, 0:200, easingfunction=easeinsine)],
    creategif=true,
    pathname=&quot;/tmp/animationtest.gif&quot;)</code></pre><p>The <code>usenewffmpeg</code> option, <code>true</code> by default, uses single-pass palette generation and more complex filtering provided by recent versions of the <code>ffmpeg</code> utility, mainly to cope with transparent backgrounds. If set to <code>false</code>, the behavior is the same as in previous versions of Luxor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L122-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arc" href="#Luxor.arc"><code>Luxor.arc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">arc(xc, yc, radius, angle1, angle2, action=:none)</code></pre><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going clockwise, centered at xc, yc.</p><p>Angles are defined relative to the x-axis, positive clockwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L138-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arc" href="#Luxor.arc"><code>Luxor.arc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">arc(centerpoint::Point, radius, angle1, angle2, action=:none)</code></pre><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going clockwise, centered at <code>centerpoint</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L151-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arc2r" href="#Luxor.arc2r"><code>Luxor.arc2r</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">  arc2r(c1::Point, p2::Point, p3::Point, action=:none)</code></pre><p>Add a circular arc centered at <code>c1</code> that starts at <code>p2</code> and ends at <code>p3</code>, going clockwise, to the current path.</p><p><code>c1</code>-<code>p2</code> really determines the radius. If <code>p3</code> doesn&#39;t lie on the circular path,  it will be used only as an indication of the arc&#39;s length, rather than its position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L182-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arc2sagitta" href="#Luxor.arc2sagitta"><code>Luxor.arc2sagitta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">arc2sagitta(p1::Point, p2::Point, s, action=:none)</code></pre><p>Make a clockwise arc starting at <code>p1</code> and ending at <code>p2</code> that reaches a height of <code>s</code>, the sagitta, at the middle. Might append to current path...</p><p>Return tuple of the center point and the radius of the arc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L829-L835">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arrow" href="#Luxor.arrow"><code>Luxor.arrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">arrow(start::Point, finish::Point, height::Vector, action=:stroke;
    keyword arguments...)</code></pre><p>Draw a Bézier arrow between <code>start</code> and <code>finish</code>, with control points defined to fit in an imaginary box defined by the two supplied <code>height</code> values (see <code>bezierfrompoints()</code>). If the height values are different signs, the arrow will change direction on its way.</p><p>Keyword arguments are the same as <a href="#Luxor.arrow"><code>arrow(pt1, pt2, pt3, pt4)</code></a>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">arrow(pts[1], pts[end], [15, 15],
    decoration = 0.5,
    decorate = () -&gt; text(string(pts[1])))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/arrows.jl#L408-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arrow" href="#Luxor.arrow"><code>Luxor.arrow</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">arrow(start::Point, C1::Point, C2::Point, finish::Point, action=:stroke;
    linewidth       = 1.0,
    arrowheadlength = 10,
    arrowheadangle  = pi/8,
    startarrow      = false,
    finisharrow     = true,
    decoration      = 0.5,
    decorate        = nothing
    arrowheadfunction = nothing)</code></pre><p>Draw a Bezier curved arrow, from <code>start</code> to <code>finish</code>, with control points <code>C1</code> and <code>C2</code>. Arrow heads can be added/hidden by changing <code>startarrow</code> and <code>finisharrow</code> options.</p><p>The <code>decorate</code> keyword argument accepts a function that can execute code at one or more locations on the arrow&#39;s shaft. The inherited graphic environment is centered at each point on the shaft given by scalar or vector <code>decoration</code>, and the x-axis is aligned with the direction of the curve at that point.</p><p><strong>Example</strong></p><p>This code draws an arrow head that&#39;s filled with orange and outlined in green.</p><pre><code class="nohighlight">function myarrowheadfunction(originalendpoint, newendpoint, shaftangle)
    @layer begin
        setline(5)
        translate(newendpoint)
        rotate(shaftangle)
        sethue(&quot;orange&quot;)
        ngon(O, 20, 3, 0, :fill)
        sethue(&quot;green&quot;)
        ngon(O, 20, 3, 0, :stroke)
    end
end

@drawsvg begin
    background(&quot;white&quot;)
    arrow(O, 220, 0, π,
        linewidth=10,
        arrowheadlength=30,
        arrowheadangle=π/7,
        clockwise=true,
        arrowheadfunction = myarrowheadfunction)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/arrows.jl#L291-L342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arrow-Tuple{Point, Any, Any, Any}" href="#Luxor.arrow-Tuple{Point, Any, Any, Any}"><code>Luxor.arrow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">arrow(centerpos::Point, radius, startangle, endangle;
    linewidth          = 1.0,
    arrowheadlength    = 10,
    arrowheadangle     = π/8,
    decoration         = 0.5,
    decorate           = nothing,
    arrowheadfunction  = nothing,
    clockwise          = true)</code></pre><p>Draw a curved arrow, an arc centered at <code>centerpos</code> starting at <code>startangle</code> and ending at <code>endangle</code> with an arrowhead at the end. Angles are measured clockwise from the positive x-axis.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>); you can specify the linewidth.</p><p>The <code>decorate</code> keyword argument accepts a zero-argument function that can execute code at one or more locations on the arrow&#39;s shaft. The inherited graphic environment is centered at points on the shaft between 0 and 1 given by scalar or vector <code>decoration</code>, and the x-axis is aligned with the direction of the curve at that point.</p><p>A triangular arrowhead is drawn by default. But you can pass a function to the <code>arrowheadfunction</code> keyword argument that accepts three arguments: the shaft end, the arrow head end, and the shaft angle. Thsi allows you to draw any shape arrowhead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/arrows.jl#L163-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arrow-Tuple{Point, Point}" href="#Luxor.arrow-Tuple{Point, Point}"><code>Luxor.arrow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">arrow(startpoint::Point, endpoint::Point;
    linewidth         = 1.0,
    arrowheadlength   = 10,
    arrowheadangle    = pi/8,
    decoration        = 0.5 or range(),
    decorate          = nothing,
    arrowheadfunction = nothing)</code></pre><p>Draw a line between two points and add an arrowhead at the end. The arrowhead length will be the length of the side of the arrow&#39;s head, and the arrowhead angle is the angle between the sloping side of the arrowhead and the arrow&#39;s shaft.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>), and defaults to 1, but you can specify another value. It doesn&#39;t need stroking/filling, the shaft is stroked and the head filled with the current color.</p><p><strong>Decoration</strong></p><p>The <code>decorate</code> keyword argument accepts a function with zero arguments that can execute code at one or more locations on the arrow&#39;s shaft. The inherited graphic environment is centered at each point on the shaft between 0 and 1 given by scalar or vector <code>decoration</code>, and the x-axis is aligned with the direction of the curve at that point.</p><p><strong>Arrowheads</strong></p><p>A triangular arrowhead is drawn by default. But you can pass a function to the <code>arrowheadfunction</code> keyword argument that accepts three arguments: the shaft end, the arrow head end, and the shaft angle. Thsi allows you to draw any shape arrowhead.</p><p><strong>Example</strong></p><pre><code class="nohighlight">function redbluearrow(shaftendpoint, endpoint, shaftangle)
    @layer begin
        sethue(&quot;red&quot;)
        sidept1 = shaftendpoint  + polar(10, shaftangle + π/2 )
        sidept2 = shaftendpoint  - polar(10, shaftangle + π/2)
        poly([sidept1, endpoint, sidept2], :fill)
        sethue(&quot;blue&quot;)
        poly([sidept1, endpoint, sidept2], :stroke, close=false)
    end
end

@drawsvg begin
    background(&quot;white&quot;)
    arrow(O, O + (120, 120),
        linewidth=4,
        arrowheadlength=40,
        arrowheadangle=π/7,
        arrowheadfunction = redbluearrow)

    arrow(O, 100, 3π/2, π,
        linewidth=4,
        arrowheadlength=20,
        clockwise=false,arrowheadfunction=redbluearrow)
end 800 250</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/arrows.jl#L28-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.arrowhead" href="#Luxor.arrowhead"><code>Luxor.arrowhead</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">arrowhead(target[, action=:fill];
    shaftangle=0,
    headlength=10,
    headangle=pi/8)</code></pre><p>Draw an arrow head. The arrowhead length will be the length of the side of the arrow&#39;s head, and the arrowhead angle is the angle between the sloping side of the arrowhead and the arrow&#39;s shaft.</p><p>This doesn&#39;t use the current linewidth setting (<code>setline()</code>), and defaults to 1, but you can specify another value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/arrows.jl#L1-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.background-Tuple{ColorTypes.Colorant}" href="#Luxor.background-Tuple{ColorTypes.Colorant}"><code>Luxor.background</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">background(color)</code></pre><p>Fill the canvas with a single color. Returns the (red, green, blue, alpha) values.</p><p>Examples:</p><pre><code class="nohighlight">background(&quot;antiquewhite&quot;)
background(1, 0.0, 1.0)
background(1, 0.0, 1.0, .5)</code></pre><p>If Colors.jl is installed:</p><pre><code class="nohighlight">background(RGB(0, 1, 0))
background(RGBA(0, 1, 0))
background(RGBA(0, 1, 0, .5))
background(Luv(20, -20, 30))</code></pre><p>If you don&#39;t specify a background color for a PNG drawing, the background will be transparent. You can set a partly or completely transparent background for PNG files by passing a color with an alpha value, such as this &#39;transparent black&#39;:</p><pre><code class="nohighlight">background(RGBA(0, 0, 0, 0))</code></pre><p>or</p><pre><code class="nohighlight">background(0, 0, 0, 0)</code></pre><p>Returns a tuple <code>(r, g, b, a)</code> of the color that was used to paint the background.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L69-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.barchart-Tuple{Any}" href="#Luxor.barchart-Tuple{Any}"><code>Luxor.barchart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">barchart(values;
        boundingbox = BoundingBox(O + (-250, -120), O + (250, 120)),
        bargap=10,
        margin = 5,
        border=false,
        labels=false,
        labelfunction = (values, i, lowpos, highpos, barwidth, scaledvalue) -&gt; begin
                label(string(values[i]), :n, highpos, offset=10)
          end,
        barfunction =  (values, i, lowpos, highpos, barwidth, scaledvalue) -&gt; begin
            @layer begin
                setline(barwidth)
                line(lowpos, highpos, :stroke)
            end
          end)</code></pre><p>Draw a barchart where each bar is the height of a value in the <code>values</code> array. The bars will be scaled to fit in a bounding box.</p><p>Text labels are drawn if the keyword <code>labels=true</code>.</p><p><strong>Extended help</strong></p><p>The function returns a vector of points; each is the bottom center of a bar.</p><p>Draw a Fibonacci sequence as a barchart:</p><pre><code class="nohighlight">fib(n) = n &gt; 2 ? fib(n - 1) + fib(n - 2) : 1
fibs = fib.(1:15)
@draw begin
    fontsize(12)
    barchart(fibs, labels=true)
end</code></pre><p>To control the drawing of the text and bars, define functions that process the end points:</p><p><code>mybarfunction(values, i, lowpos, highpos, barwidth, scaledvalue)</code></p><p><code>mylabelfunction(values, i, lowpos, highpos, barwidth, scaledvalue)</code></p><p>and pass them like this:</p><pre><code class="language-julia">barchart(vals, barfunction=mybarfunction)
barchart(vals, labelfunction=mylabelfunction)</code></pre><pre><code class="nohighlight">function myprologfunction(values, basepoint, minbarrange, maxbarrange, barchartheight)
    @layer begin
        setline(0.2)
        for i in 0:10:maximum(values)
            rule(boxbottomcenter(basepoint) + (0, -(rescale(i, minbarrange, maxbarrange) * barchartheight)))
        end
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bars.jl#L1-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.between" href="#Luxor.between"><code>Luxor.between</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">between(bb::BoundingBox, x)</code></pre><p>Find a point between the two corners of a BoundingBox corresponding to <code>x</code>, where <code>x</code> is typically between 0 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L307-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.between-Tuple{Point, Point, Any}" href="#Luxor.between-Tuple{Point, Point, Any}"><code>Luxor.between</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">between(p1::Point, p2::Point, x)
between((p1::Point, p2::Point), x)</code></pre><p>Find the point between point <code>p1</code> and point <code>p2</code> for <code>x</code>, where <code>x</code> is typically between 0 and 1. <code>between(p1, p2, 0.5)</code> is equivalent to <code>midpoint(p1, p2)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L149-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezier-Tuple{Any, Point, Point, Point, Point}" href="#Luxor.bezier-Tuple{Any, Point, Point, Point, Point}"><code>Luxor.bezier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bezier(t, A::Point, A1::Point, B1::Point, B::Point)</code></pre><p>Return the result of evaluating the Bezier cubic curve function, <code>t</code> going from 0 to 1, starting at A, finishing at B, control points A1 (controlling A), and B1 (controlling B).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L63-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.beziercurvature-Tuple{Any, Point, Point, Point, Point}" href="#Luxor.beziercurvature-Tuple{Any, Point, Point, Point, Point}"><code>Luxor.beziercurvature</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">beziercurvature(t, A::Point, A1::Point, B1::Point, B::Point)</code></pre><p>Return the curvature of the Bezier curve at <code>t</code> ([0-1]), given start and end points A and B, and control points A1 and B1. The value (kappa) will typically be a value between -0.001 and 0.001 for points with coordinates in the 100-500 range.</p><p>κ(t) is the curvature of the curve at point t, which for a parametric planar curve is:</p><p class="math-container">\[\begin{equation}
\kappa = \frac{\mid \dot{x}\ddot{y}-\dot{y}\ddot{x}\mid}
    {(\dot{x}^2 + \dot{y}^2)^{\frac{3}{2}}}
\end{equation}\]</p><p>The radius of curvature, or the radius of an osculating circle at a point, is 1/κ(t). Values of 1/κ will typically be in the range -1000 to 1000 for points with coordinates in the 100-500 range.</p><p>TODO Fix overshoot...</p><p>...The value of kappa can sometimes collapse near 0, returning NaN (and Inf for radius of curvature).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L90-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierfrompoints-NTuple{4, Point}" href="#Luxor.bezierfrompoints-NTuple{4, Point}"><code>Luxor.bezierfrompoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bezierfrompoints(startpoint::Point, pointonline1::Point,
    pointonline2::Point, endpoint::Point)</code></pre><p>Given four points, return the Bezier curve that passes through all four points, starting at <code>startpoint</code> and ending at <code>endpoint</code>. The two middle points of the returned BezierPathSegment are the two control points that make the curve pass through the two middle points supplied.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L401-L409">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierfrompoints-Tuple{Vector{Point}}" href="#Luxor.bezierfrompoints-Tuple{Vector{Point}}"><code>Luxor.bezierfrompoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bezierfrompoints(ptslist::Array{Point, 1})</code></pre><p>Given four points, return the Bezier curve that passes through all four points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L423-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierpathtopoly-Tuple{BezierPath}" href="#Luxor.bezierpathtopoly-Tuple{BezierPath}"><code>Luxor.bezierpathtopoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bezierpathtopoly(bezierpath::BezierPath; steps=10)</code></pre><p>Convert a Bezier path (an array of Bezier segments, where each segment is a tuple of four points: anchor1, control1, control2, anchor2) to a polygon.</p><p>To make a Bezier path, use <code>makebezierpath()</code> on a polygon.</p><p>The <code>steps</code> optional keyword determines how many line sections are used for each path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L269-L279">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.beziersegmentangles-Tuple{Any, Any}" href="#Luxor.beziersegmentangles-Tuple{Any, Any}"><code>Luxor.beziersegmentangles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">beziersegmentangles(pt1, pt2;
    out = deg2rad(45),
    in  = deg2rad(135))
)</code></pre><p>Return a BezierPathSegment joining <code>pt1</code> and <code>pt2</code> making the angles <code>out</code> at the start and <code>in</code> at the end.</p><p>It&#39;s similar to the tikZ <code>(a) to [out=135, in=45] (b)</code> drawing instruction (but in radians obviously).</p><p><code>out</code> is the angle between a line from <code>pt1</code> to the outgoing Bézier handle makes with the horizontal. <code>in</code> is the angle that a line joining <code>pt2</code> from the preceding Bézier handle makes with the horizontal. So:</p><pre><code class="nohighlight">drawbezierpath(beziersegmentangles(O, O + (100, 0),
    out = deg2rad(45),
    in  = 2π - deg2rad(45)),
    :stroke)</code></pre><p>draws a shape resembling a piece of string fixed at each end and hanging down in the middle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L625-L651">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezierstroke" href="#Luxor.bezierstroke"><code>Luxor.bezierstroke</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bezierstroke(point1, point2, width=0.0)</code></pre><p>Return a BezierPath, a stroked version of a straight line between two points.</p><p>It wil have 2 or 6 Bezier path segments that define a brush or pen shape. If width is 0, the brush shape starts and ends at a point. Otherwise the brush shape starts and ends with the thick end.</p><p>To draw it, use eg <code>drawbezierpath(..., :fill)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L430-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.beziertopoly-Tuple{BezierPathSegment}" href="#Luxor.beziertopoly-Tuple{BezierPathSegment}"><code>Luxor.beziertopoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">beziertopoly(bpseg::BezierPathSegment; steps=10)</code></pre><p>Convert a Bezier segment to a polygon (an array of points).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L217-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezier′-NTuple{5, Any}" href="#Luxor.bezier′-NTuple{5, Any}"><code>Luxor.bezier′</code></a> — <span class="docstring-category">Method</span></header><section><div><p>bezier′(t, A::Point, A1::Point, B1::Point, B::Point)</p><p>Return the first derivative of the Bezier function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L76-L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.bezier′′-NTuple{5, Any}" href="#Luxor.bezier′′-NTuple{5, Any}"><code>Luxor.bezier′′</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">bezier′′(t, A::Point, A1::Point, B1::Point, B::Point)</code></pre><p>Return the second derivative of Bezier function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L83-L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blend-Tuple{Point, Any, Point, Any, Any, Any}" href="#Luxor.blend-Tuple{Point, Any, Point, Any, Any, Any}"><code>Luxor.blend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blend(centerpos1, rad1, centerpos2, rad2, color1, color2)</code></pre><p>Create a radial blend.</p><p>Example:</p><pre><code class="nohighlight">redblue = blend(
    pos, 0,                   # first circle center and radius
    pos, tiles.tilewidth/2,   # second circle center and radius
    &quot;red&quot;,
    &quot;blue&quot;
    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/blends.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blend-Tuple{Point, Any, Point, Any}" href="#Luxor.blend-Tuple{Point, Any, Point, Any}"><code>Luxor.blend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blend(from::Point, startradius, to::Point, endradius)</code></pre><p>Create an empty radial blend.</p><p>Radial blends are defined by two circles that define the start and stop locations. The first point is the center of the start circle, the first radius is the radius of the first circle.</p><p>A new blend is empty. To add colors, use <code>addstop()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/blends.jl#L56-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blend-Tuple{Point, Point, Any, Any}" href="#Luxor.blend-Tuple{Point, Point, Any, Any}"><code>Luxor.blend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blend(pt1::Point, pt2::Point, color1, color2)</code></pre><p>Create a linear blend.</p><p>Example:</p><pre><code class="nohighlight">redblue = blend(pos, pos, &quot;red&quot;, &quot;blue&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/blends.jl#L40-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blend-Tuple{Point, Point}" href="#Luxor.blend-Tuple{Point, Point}"><code>Luxor.blend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blend(from::Point, to::Point)</code></pre><p>Create an empty linear blend.</p><p>A blend is a specification of how one color changes into another. Linear blends are defined by two points: parallel lines through these points define the start and stop locations of the blend. The blend is defined relative to the current axes origin. This means that you should be aware of the current axes when you define blends, and when you use them.</p><p>To add colors, use <code>addstop()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/blends.jl#L3-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blendadjust" href="#Luxor.blendadjust"><code>Luxor.blendadjust</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">blendadjust(ablend, center::Point, xscale, yscale, rot=0)</code></pre><p>Modify an existing blend by scaling, translating, and rotating it so that it will fill a shape properly even if the position of the shape is nowhere near the original location of the blend&#39;s definition.</p><p>For example, if your blend definition was this (notice the <code>1</code>)</p><pre><code class="nohighlight">blendgoldmagenta = blend(
        Point(0, 0), 0,                   # first circle center and radius
        Point(0, 0), 1,                   # second circle center and radius
        &quot;gold&quot;,
        &quot;magenta&quot;
        )</code></pre><p>you can use it in a shape that&#39;s 100 units across and centered at <code>pos</code>, by calling this:</p><pre><code class="nohighlight">blendadjust(blendgoldmagenta, Point(pos.x, pos.y), 100, 100)</code></pre><p>then use <code>setblend()</code>:</p><pre><code class="nohighlight">setblend(blendgoldmagenta)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/blends.jl#L121-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.blendmatrix-Tuple{Cairo.CairoPattern, Any}" href="#Luxor.blendmatrix-Tuple{Cairo.CairoPattern, Any}"><code>Luxor.blendmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">blendmatrix(b::Blend, m)</code></pre><p>Set the matrix of a blend.</p><p>To apply a sequence of matrix transforms to a blend:</p><pre><code class="nohighlight">A = [1 0 0 1 0 0]
Aj = cairotojuliamatrix(A)
Sj = scalingmatrix(2, .2) * Aj
Tj = translationmatrix(10, 0) * Sj
A1 = juliatocairomatrix(Tj)
blendmatrix(b, As)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/blends.jl#L154-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boundingboxesintersect-NTuple{4, Point}" href="#Luxor.boundingboxesintersect-NTuple{4, Point}"><code>Luxor.boundingboxesintersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boundingboxesintersect(bbox1::BoundingBox, bbox2::BoundingBox)
boundingboxesintersect(acorner1::Point, acorner2::Point, bcorner1::Point, bcorner2::Point)</code></pre><p>Return true if the two bounding boxes intersect.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box(bbox::BoundingBox, :action;
        vertices=false)</code></pre><p>Make a box using the bounds in <code>bbox</code>.</p><p>Use <code>vertices=true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L210-L218">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box(cornerpoint1, cornerpoint2, action=:none;
    vertices=false)</code></pre><p>Create a box (rectangle) between two points and do an action.</p><p>Use <code>vertices=true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L41-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box(points::Array, action=:none)</code></pre><p>Create a box/rectangle using the first two points of an array of Points to defined opposite corners.</p><p>Use <code>vertices=true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L63-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box(t::Table, cellnumber::Int, action::Symbol=:none; vertices=false)</code></pre><p>Draw box <code>cellnumber</code> in table <code>t</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Table.jl#L265-L269">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box(x, y, width, height, action=:none)</code></pre><p>Create a box/rectangle centered at point <code>x/y</code> with width and height.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L95-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box(tiles::Tiler, n::T where T &lt;: Integer, action::Symbol=:none;
    vertices=false)</code></pre><p>Draw a box in tile <code>n</code> of tiles <code>tiles</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/tiles-grids.jl#L350-L355">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box(pt, width, height, cornerradius, action=:none)</code></pre><p>Draw a box/rectangle centered at point <code>pt</code> with <code>width</code> and <code>height</code> and round each corner by <code>cornerradius</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box(pt::Point, width, height, action=:none; vertices=false)</code></pre><p>Create a box/rectangle centered at point <code>pt</code> with width and height. Use <code>vertices=true</code> to return an array of the four corner points rather than draw the box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L75-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">box(tile::BoxmapTile, action::Symbol=:none; vertices=false)</code></pre><p>Use a Boxmaptile to make or draw a rectangular box. Use <code>vertices=true</code> to obtain the coordinates.</p><p>Create boxmaps using <code>boxmap()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Boxmaptile.jl#L150-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.box-Union{Tuple{T}, Tuple{Table, T, T}, Tuple{Table, T, T, Symbol}} where T&lt;:Integer" href="#Luxor.box-Union{Tuple{T}, Tuple{Table, T, T}, Tuple{Table, T, T, Symbol}} where T&lt;:Integer"><code>Luxor.box</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">box(t::Table, r::T, c::T, action::Symbol=:none) where T &lt;: Integer</code></pre><p>Draw a box in table <code>t</code> at row <code>r</code> and column <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Table.jl#L255-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxaspectratio-Tuple{BoundingBox}" href="#Luxor.boxaspectratio-Tuple{BoundingBox}"><code>Luxor.boxaspectratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxaspectratio(bb::BoundingBox)</code></pre><p>Return the aspect ratio (the height divided by the width) of bounding box <code>bb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L189-L193">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxbottomcenter-Tuple{BoundingBox}" href="#Luxor.boxbottomcenter-Tuple{BoundingBox}"><code>Luxor.boxbottomcenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxbottomcenter(bb::BoundingBox)</code></pre><p>Return the point at the bottom center of the BoundingBox <code>bb</code>.</p><pre><code class="nohighlight">⋅ ⋅ ⋅
⋅ ⋅ ⋅
⋅ ■ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L404-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxbottomleft-Tuple{BoundingBox}" href="#Luxor.boxbottomleft-Tuple{BoundingBox}"><code>Luxor.boxbottomleft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxbottomleft(bb::BoundingBox)</code></pre><p>Return the point at the bottom left of the BoundingBox <code>bb</code>.</p><pre><code class="nohighlight">⋅ ⋅ ⋅
⋅ ⋅ ⋅
■ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L392-L401">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxbottomright-Tuple{BoundingBox}" href="#Luxor.boxbottomright-Tuple{BoundingBox}"><code>Luxor.boxbottomright</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxbottomright(bb::BoundingBox)</code></pre><p>Return the point at the bottom right of the BoundingBox <code>bb</code>.</p><pre><code class="nohighlight">⋅ ⋅ ⋅
⋅ ⋅ ⋅
⋅ ⋅ ■</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L416-L425">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxdiagonal-Tuple{BoundingBox}" href="#Luxor.boxdiagonal-Tuple{BoundingBox}"><code>Luxor.boxdiagonal</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxdiagonal(bb::BoundingBox)</code></pre><p>Return the length of the diagonal of bounding box <code>bb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L182-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxheight-Tuple{BoundingBox}" href="#Luxor.boxheight-Tuple{BoundingBox}"><code>Luxor.boxheight</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxheight(bb::BoundingBox)</code></pre><p>Return the height of bounding box <code>bb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L175-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxmap-Tuple{Array, Point, Any, Any}" href="#Luxor.boxmap-Tuple{Array, Point, Any, Any}"><code>Luxor.boxmap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxmap(A::Array, pt, w, h)</code></pre><p>Build a box map of the values in <code>A</code> with one corner at <code>pt</code> and width <code>w</code> and height <code>h</code>. There are <code>length(A)</code> boxes. The areas of the boxes are proportional to the original values, scaled as necessary.</p><p>The return value is an array of BoxmapTiles. For example:</p><pre><code class="nohighlight">[BoxmapTile(0.0, 0.0, 10.0, 20.0)
 BoxmapTile(10.0, 0.0, 10.0, 13.3333)
 BoxmapTile(10.0, 13.3333, 10.0, 6.66667)]</code></pre><p>with each tile containing <code>(x, y, w, h)</code>. <code>box()</code> and <code>BoundingBox()</code> can work with BoxmapTiles as well.</p><p><strong>Example</strong></p><pre><code class="nohighlight">using Luxor
@svg begin
    fontsize(16)
    fontface(&quot;HelveticaBold&quot;)
    pt = Point(-200, -200)
    a = rand(10:200, 15)
    tiles = boxmap(a, Point(-200, -200), 400, 400)
    for (n, t) in enumerate(tiles)
        randomhue()
        bb = BoundingBox(t)
        box(bb - 2, :stroke)
        box(bb - 5, :fill)
        sethue(&quot;white&quot;)
        text(string(n), midpoint(bb[1], bb[2]), halign=:center)
    end
end 400 400 &quot;boxmap.svg&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Boxmaptile.jl#L100-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxmiddlecenter-Tuple{BoundingBox}" href="#Luxor.boxmiddlecenter-Tuple{BoundingBox}"><code>Luxor.boxmiddlecenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxmiddlecenter(bb::BoundingBox)</code></pre><p>Return the point at the center of the BoundingBox <code>bb</code>.</p><pre><code class="nohighlight">⋅ ⋅ ⋅
⋅ ■ ⋅
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L368-L377">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxmiddleleft-Tuple{BoundingBox}" href="#Luxor.boxmiddleleft-Tuple{BoundingBox}"><code>Luxor.boxmiddleleft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxmiddleleft(bb::BoundingBox)</code></pre><p>Return the point at the middle left of the BoundingBox <code>bb</code>.</p><pre><code class="nohighlight">⋅ ⋅ ⋅
■ ⋅ ⋅
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L355-L365">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxmiddleright-Tuple{BoundingBox}" href="#Luxor.boxmiddleright-Tuple{BoundingBox}"><code>Luxor.boxmiddleright</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxmiddleright(bb::BoundingBox)</code></pre><p>Return the point at the midde right of the BoundingBox <code>bb</code>.</p><pre><code class="nohighlight">⋅ ⋅ ⋅
⋅ ⋅ ■
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L380-L389">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxtopcenter-Tuple{BoundingBox}" href="#Luxor.boxtopcenter-Tuple{BoundingBox}"><code>Luxor.boxtopcenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxtopcenter(bb::BoundingBox)</code></pre><p>Return the point at the top center of the BoundingBox <code>bb</code>.</p><pre><code class="nohighlight">⋅ ■ ⋅
⋅ ⋅ ⋅
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L329-L339">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxtopleft-Tuple{BoundingBox}" href="#Luxor.boxtopleft-Tuple{BoundingBox}"><code>Luxor.boxtopleft</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxtopleft(bb::BoundingBox)</code></pre><p>Return the point at the top left of the BoundingBox <code>bb</code>.</p><pre><code class="nohighlight">■ ⋅ ⋅
⋅ ⋅ ⋅
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L315-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxtopright-Tuple{BoundingBox}" href="#Luxor.boxtopright-Tuple{BoundingBox}"><code>Luxor.boxtopright</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxtopright(bb::BoundingBox)</code></pre><p>Return the point at the top right of the BoundingBox <code>bb</code>.</p><pre><code class="nohighlight">⋅ ⋅ ■
⋅ ⋅ ⋅
⋅ ⋅ ⋅</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L342-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.boxwidth-Tuple{BoundingBox}" href="#Luxor.boxwidth-Tuple{BoundingBox}"><code>Luxor.boxwidth</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">boxwidth(bb::BoundingBox)</code></pre><p>Return the width of bounding box <code>bb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.brush" href="#Luxor.brush"><code>Luxor.brush</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">brush(pt1, pt2, width=10;
    strokes=10,
    minwidth=0.01,
    maxwidth=0.03,
    twist = -1,
    lowhandle  = 0.3,
    highhandle = 0.7,
    randomopacity = true,
    tidystart = false,
    action = :fill,
    strokefunction = (nbpb) -&gt; nbpb))</code></pre><p>Draw a composite brush stroke made up of some randomized individual filled Bezier paths.</p><p><code>strokefunction</code> allows a function to process a BezierPathSegment or do other things before it&#39;s drawn.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>There is a lot of randomness in this function. Results are unpredictable.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L562-L583">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.buildcolumn-NTuple{5, Any}" href="#Luxor.buildcolumn-NTuple{5, Any}"><code>Luxor.buildcolumn</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">buildcolumn(A, x, y, w, h)</code></pre><p>Make a column of tiles from A.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Boxmaptile.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.buildrow-NTuple{5, Any}" href="#Luxor.buildrow-NTuple{5, Any}"><code>Luxor.buildrow</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">buildrow(A, x, y, w, h)</code></pre><p>Make a row of tiles from A.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Boxmaptile.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.cairotojuliamatrix-Tuple{Array}" href="#Luxor.cairotojuliamatrix-Tuple{Array}"><code>Luxor.cairotojuliamatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cairotojuliamatrix(c)</code></pre><p>Return a 3x3 Julia matrix that&#39;s the equivalent of the six-element matrix in <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/matrix.jl#L154-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.carc" href="#Luxor.carc"><code>Luxor.carc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">carc(xc, yc, radius, angle1, angle2, action=:none)</code></pre><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going counterclockwise, centered at <code>xc</code>/<code>yc</code>.</p><p>Angles are defined relative to the x-axis, positive clockwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L160-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.carc" href="#Luxor.carc"><code>Luxor.carc</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">carc(centerpoint::Point, radius, angle1, angle2, action=:none)</code></pre><p>Add an arc centered at <code>centerpoint</code> to the current path from <code>angle1</code> to <code>angle2</code>, going counterclockwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.carc2r" href="#Luxor.carc2r"><code>Luxor.carc2r</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">carc2r(c1::Point, p2::Point, p3::Point, action=:none)</code></pre><p>Add a circular arc centered at <code>c1</code> that starts at <code>p2</code> and ends at <code>p3</code>, going counterclockwise, to the current path.</p><p><code>c1</code>-<code>p2</code> really determines the radius. If <code>p3</code> doesn&#39;t lie on the circular path, it will be used only as an indication of the arc&#39;s length, rather than its position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L201-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.carc2sagitta" href="#Luxor.carc2sagitta"><code>Luxor.carc2sagitta</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">carc2sagitta(p1::Point, p2::Point, s, action=:none)</code></pre><p>Make a counterclockwise arc starting at <code>p1</code> and ending at <code>p2</code> that reaches a height of <code>s</code>, the sagitta, at the middle. Might append to current path...</p><p>Return tuple of center point and radius of arc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L857-L863">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.center3pts-Tuple{Point, Point, Point}" href="#Luxor.center3pts-Tuple{Point, Point, Point}"><code>Luxor.center3pts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">center3pts(a::Point, b::Point, c::Point)</code></pre><p>Find the radius and center point for three points lying on a circle.</p><p>returns <code>(centerpoint, radius)</code> of a circle.</p><p>If there&#39;s no such circle, the function returns <code>(Point(0, 0), 0)</code>.</p><p>If two of the points are the same, use <code>circle(pt1, pt2)</code> instead.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L49-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circle" href="#Luxor.circle"><code>Luxor.circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circle(pt1::Point, pt2::Point, pt3::Point, action=:none)</code></pre><p>Make a circle that passes through three points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L38-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circle" href="#Luxor.circle"><code>Luxor.circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circle(pt, r, action=:none)</code></pre><p>Make a circle centered at <code>pt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circle" href="#Luxor.circle"><code>Luxor.circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circle(x, y, r, action=:none)</code></pre><p>Make a circle of radius <code>r</code> centered at <code>x</code>/<code>y</code>.</p><p><code>action</code> is one of the actions applied by <code>do_action</code>, defaulting to <code>:none</code>. You can also use <code>ellipse()</code> to draw circles and place them by their centerpoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circle" href="#Luxor.circle"><code>Luxor.circle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circle(pt1::Point, pt2::Point, action=:none)</code></pre><p>Make a circle that passes through two points that define the diameter:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L27-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlecircleinnertangents-Tuple{Point, Any, Point, Any}" href="#Luxor.circlecircleinnertangents-Tuple{Point, Any, Point, Any}"><code>Luxor.circlecircleinnertangents</code></a> — <span class="docstring-category">Method</span></header><section><div><p>circlecircleinnertangents(circle1center::Point, circle1radius, circle2center::Point, circle2radius)</p><p>Find the inner tangents of two circles. These are tangent lines that cross as they skim past one circle and touch the other.</p><p>Returns the four points: tangentpoint1 on circle 1, tangentpoint1 on circle2, tangentpoint2 on circle 1, tangentpoint2 on circle2.</p><p>Returns <code>(O, O, O, O)</code> if inner tangents can&#39;t be found (eg when the circles overlap).</p><p>Use <code>circlecircleoutertangents()</code> to find the outer tangents.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L954-L967">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlecircleoutertangents-Tuple{Point, Any, Point, Any}" href="#Luxor.circlecircleoutertangents-Tuple{Point, Any, Point, Any}"><code>Luxor.circlecircleoutertangents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">circlecircleoutertangents(cpt1::Point, r1, cpt2::Point, r2)</code></pre><p>Return four points, <code>p1</code>, <code>p2,</code>p3<code>,</code>p4<code>, where a line through</code>p1<code>and</code>p2<code>, and a line through</code>p3<code>and</code>p4<code>, form the outer tangents to the circles defined by</code>cpt1/r1<code>and</code>cpt2/r2`.</p><p>Returns four identical points (<code>O</code>) if one of the circles lies inside the other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L885-L893">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlepath" href="#Luxor.circlepath"><code>Luxor.circlepath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">circlepath(center::Point, radius, action=:none;
    reversepath=false,
    kappa = 0.5522847498307936)</code></pre><p>Draw a circle using Bézier curves.</p><p>The magic value, <code>kappa</code>, is <code>4.0 * (sqrt(2.0) - 1.0) / 3.0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L403-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circlepointtangent-Tuple{Point, Any, Point, Any}" href="#Luxor.circlepointtangent-Tuple{Point, Any, Point, Any}"><code>Luxor.circlepointtangent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">circlepointtangent(through::Point, radius, targetcenter::Point, targetradius)</code></pre><p>Find the centers of up to two circles of radius <code>radius</code> that pass through point <code>through</code> and are tangential to a circle that has radius <code>targetradius</code> and center <code>targetcenter</code>.</p><p>This function returns a tuple:</p><ul><li><p>(0, O, O)      - no circles exist</p></li><li><p>(1, pt1, O)    - 1 circle exists, centered at pt1</p></li><li><p>(2, pt1, pt2)  - 2 circles exist, with centers at pt1 and pt2</p></li></ul><p>(The O are just dummy points so that three values are always returned.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L757-L773">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.circletangent2circles-Tuple{Any, Point, Any, Point, Any}" href="#Luxor.circletangent2circles-Tuple{Any, Point, Any, Point, Any}"><code>Luxor.circletangent2circles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">circletangent2circles(radius, circle1center::Point, circle1radius, circle2center::Point, circle2radius)</code></pre><p>Find the centers of up to two circles of radius <code>radius</code> that are tangent to the two circles defined by <code>circle1...</code> and <code>circle2...</code>. These two circles can overlap, but one can&#39;t be inside the other.</p><ul><li><p>(0, O, O)      - no such circles exist</p></li><li><p>(1, pt1, O)    - 1 circle exists, centered at pt1</p></li><li><p>(2, pt1, pt2)  - 2 circles exist, with centers at pt1 and pt2</p></li></ul><p>(The O are just dummy points so that three values are always returned.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L808-L822">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.clip-Tuple{}" href="#Luxor.clip-Tuple{}"><code>Luxor.clip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clip()</code></pre><p>Establish a new clipping region by intersecting the current clipping region with the current path and then clearing the current path.</p><p>An existing clipping region is enforced through and after a <code>gsave()</code>-<code>grestore()</code> block, but a clipping region set inside a <code>gsave()</code>-<code>grestore()</code> block is lost after <code>grestore()</code>. [?]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L228-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.clippreserve-Tuple{}" href="#Luxor.clippreserve-Tuple{}"><code>Luxor.clippreserve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clippreserve()</code></pre><p>Establish a new clipping region by intersecting the current clipping region with the current path, but keep the current path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L239-L244">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.clipreset-Tuple{}" href="#Luxor.clipreset-Tuple{}"><code>Luxor.clipreset</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">clipreset()</code></pre><p>Reset the clipping region to the current drawing&#39;s extent.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L247-L251">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.closepath-Tuple{}" href="#Luxor.closepath-Tuple{}"><code>Luxor.closepath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">closepath()</code></pre><p>Close the current path. This is Cairo&#39;s <code>close_path()</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L149-L153">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.crescent" href="#Luxor.crescent"><code>Luxor.crescent</code></a> — <span class="docstring-category">Function</span></header><section><div><p>crescent(cp1, r1, cp2, r2, action=nothing;             vertices=false,             reversepath=false)</p><p>Create a crescent-shaped polygon, aligned with the current x-axis, by finding the intersection of two circles. The two center positions should be different.</p><p>See also <code>crescent(point, innerradius, outeradius...)</code>.</p><p><strong>Examples</strong></p><p>Create a filled crescent shape from two circles.</p><pre><code class="nohighlight">crescent(O, 100, O + (60, 0), 150, :fill)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L1116-L1134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.crescent" href="#Luxor.crescent"><code>Luxor.crescent</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">crescent(pos, innerradius, outeradius, action=nothing;
    vertices=false,
    reversepath=false,
    steps = 30)</code></pre><p>Create a crescent-shaped polygon, aligned with the current x-axis. If the inner radius is 0, you&#39;ll get a semicircle.</p><p>See also <code>crescent(pos1, innerradius, pos2, outeradius...)</code>.</p><p><strong>Examples</strong></p><p>Create a filled crescent shape with outer radius of 200, inner radius of 130.</p><pre><code class="nohighlight">crescent(O, 130, 200, :fill)</code></pre><p>Create a stroked crescent shape; the inner radius of 0 produces a semicircle.</p><pre><code class="nohighlight">crescent(O, 0, 200, :stroke)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L1070-L1093">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.cropmarks-Tuple{Any, Any, Any}" href="#Luxor.cropmarks-Tuple{Any, Any, Any}"><code>Luxor.cropmarks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cropmarks(center, width, height)</code></pre><p>Draw cropmarks (also known as trim marks). Use current color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L262-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.crossproduct-Tuple{Point, Point}" href="#Luxor.crossproduct-Tuple{Point, Point}"><code>Luxor.crossproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">crossproduct(p1::Point, p2::Point)</code></pre><p>This is the <em>perp dot product</em>, really, not the crossproduct proper (which is 3D):</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L211-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.currentdrawing-Tuple{}" href="#Luxor.currentdrawing-Tuple{}"><code>Luxor.currentdrawing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">currentdrawing()</code></pre><p>Return the current Luxor drawing, if there currently is one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.currentpoint-Tuple{}" href="#Luxor.currentpoint-Tuple{}"><code>Luxor.currentpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">currentpoint()</code></pre><p>Return the current point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L540-L544">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.curve-NTuple{6, Any}" href="#Luxor.curve-NTuple{6, Any}"><code>Luxor.curve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">curve(x1, y1, x2, y2, x3, y3)
curve(p1, p2, p3)</code></pre><p>Add a Bézier curve.</p><p>The spline starts at the current position, finishing at <code>x3/y3</code> (<code>p3</code>), following two control points <code>x1/y1</code> (<code>p1</code>) and <code>x2/y2</code> (<code>p2</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L391-L399">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.dimension-Tuple{Point, Point}" href="#Luxor.dimension-Tuple{Point, Point}"><code>Luxor.dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dimension(p1::Point, p2::Point;
    format::Function   = (d) -&gt; string(d), # process the measured value into a string
    offset             = 0.0,              # left/right, parallel with x axis
    fromextension      = (10.0, 10.0),     # length of extensions lines left and right
    toextension        = (10.0, 10.0),     #
    textverticaloffset = 0.0,              # range 1.0 (top) to -1.0 (bottom)
    texthorizontaloffset = 0.0,            # range 1.0 (top) to -1.0 (bottom)
    textgap            = 5,                # gap between start of each arrow (≈ fontsize?)
    textrotation       = 0.0,
    arrowlinewidth     = 1.0,
    arrowheadlength    = 10,
    arrowheadangle     = π/8)</code></pre><p>Calculate and draw dimensioning graphics for the distance between <code>p1</code> and <code>p2</code>. The value can be formatted with function <code>format</code>.</p><p><code>p1</code> is the lower on the page (ie probably the higher y value) point, <code>p2</code> is the higher on the page (ie probably lower y) point.</p><p><code>offset</code> is to the left (-x) when negative.</p><p>Dimension graphics will be rotated to align with a line between <code>p1</code> and <code>p2</code>.</p><p>In <code>textverticaloffset</code>, &quot;vertical&quot; and &quot;horizontal&quot; are best understood by &quot;looking&quot; along the line from the first point to the second. <code>textverticaloffset</code> ranges from -1 to 1, <code>texthorizontaloffset</code> in default units.</p><pre><code class="nohighlight">        toextension
        [5  ,  5]
       &lt;---&gt; &lt;---&gt;
                             to
       -----------            +
            ^
            |

           -50

            |
            v
       ----------            +
                            from
       &lt;---&gt; &lt;---&gt;
         [5 , 5]
       fromextension

            &lt;----------------&gt;
                  offset</code></pre><p>Returns the measured distance and the text.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/arrows.jl#L464-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.distance-Tuple{Point, Point}" href="#Luxor.distance-Tuple{Point, Point}"><code>Luxor.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance(p1::Point, p2::Point)</code></pre><p>Find the distance between two points (two argument form).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L94-L98">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.do_action-Tuple{Any}" href="#Luxor.do_action-Tuple{Any}"><code>Luxor.do_action</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">do_action(action)</code></pre><p>This is usually called by other graphics functions. Actions for graphics commands include <code>:fill</code>, <code>:stroke</code>, <code>:clip</code>, <code>:fillstroke</code>, <code>:fillpreserve</code>, <code>:strokepreserve</code>, <code>:none</code>, and <code>:path</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L203-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.dotproduct-Tuple{Point, Point}" href="#Luxor.dotproduct-Tuple{Point, Point}"><code>Luxor.dotproduct</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dotproduct(a::Point, b::Point)</code></pre><p>Return the scalar dot product of the two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.douglas_peucker-Tuple{Vector{Point}, Any, Any, Any}" href="#Luxor.douglas_peucker-Tuple{Vector{Point}, Any, Any, Any}"><code>Luxor.douglas_peucker</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Use a non-recursive Douglas-Peucker algorithm to simplify a polygon. Used by <code>simplify()</code>.</p><pre><code class="nohighlight">douglas_peucker(pointlist::Array, start_index, last_index, epsilon)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L123-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.drawbezierpath" href="#Luxor.drawbezierpath"><code>Luxor.drawbezierpath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drawbezierpath(bps::BezierPathSegment, action=:none;
    close=false)</code></pre><p>Draw the Bézier path segment, and apply the action, such as <code>:none</code>, <code>:stroke</code>, <code>:fill</code>, etc. By default the path is open.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L197-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.drawbezierpath" href="#Luxor.drawbezierpath"><code>Luxor.drawbezierpath</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">drawbezierpath(bezierpath::BezierPath, action=:none;
    close=true)</code></pre><p>Draw the Bézier path, and apply the action, such as <code>:none</code>, <code>:stroke</code>, <code>:fill</code>, etc. By default the path is closed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L177-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeincirc-NTuple{4, Any}" href="#Luxor.easeincirc-NTuple{4, Any}"><code>Luxor.easeincirc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeincirc(t, b, c, d)</code></pre><p>circular easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L490-L494">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeincubic-NTuple{4, Any}" href="#Luxor.easeincubic-NTuple{4, Any}"><code>Luxor.easeincubic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeincubic(t, b, c, d)</code></pre><p>cubic easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L322-L326">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinexpo-NTuple{4, Any}" href="#Luxor.easeinexpo-NTuple{4, Any}"><code>Luxor.easeinexpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinexpo(t, b, c, d)</code></pre><p>exponential easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L454-L458">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutbezier" href="#Luxor.easeinoutbezier"><code>Luxor.easeinoutbezier</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">easeinoutbezier(t, b, c, d, cpt1, cpt2)</code></pre><p>This easing function takes six arguments, the usual <code>t</code>, <code>b</code>, <code>c</code>, and <code>d</code>, but also two points. These are the normalized control points of a Bezier curve drawn between <code>Point(0, 0)</code> to <code>Point(1.0, 1.0)</code>. The <code>y</code> value of the Bezier is the eased value for <code>t</code>.</p><p>In your <code>frame()</code> generating function, if a Scene specifies the <code>easeinoutbezier</code> easing function, you can use this:</p><pre><code class="nohighlight">...
lineareasing = rescale(framenumber, 1, scene.framerange.stop)
beziereasing = scene.easingfunction(lineareasing, 0, 1, 1,
    Point(0.25, 0.25), Point(0.75, 0.75))
...</code></pre><p>These two control points lie on the line between <code>0/0</code> and <code>1/1</code>, so it&#39;s equivalent to a linear easing (<code>lineartween()</code> or <code>easingflat</code>).</p><p>However, in the next example, the two control points define a wave-like curve that changes direction before changing back. When animating with this easing function, an object will &#39;go retrograde&#39; for a while.</p><pre><code class="nohighlight">lineareasing = rescale(framenumber, 1, scene.framerange.stop)
beziereasing = scene.easingfunction(lineareasing, 0, 1, 1,
    Point(0.01, 1.99), Point(0.99, -1.5))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L539-L569">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutcirc-NTuple{4, Any}" href="#Luxor.easeinoutcirc-NTuple{4, Any}"><code>Luxor.easeinoutcirc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinoutcirc(t, b, c, d)</code></pre><p>circular easing in/out - acceleration until halfway, then deceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L511-L515">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutcubic-NTuple{4, Any}" href="#Luxor.easeinoutcubic-NTuple{4, Any}"><code>Luxor.easeinoutcubic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinoutcubic(t, b, c, d)</code></pre><p>cubic easing in/out - acceleration until halfway, then deceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L343-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutexpo-NTuple{4, Any}" href="#Luxor.easeinoutexpo-NTuple{4, Any}"><code>Luxor.easeinoutexpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinoutexpo(t, b, c, d)</code></pre><p>exponential easing in/out - accelerating until halfway, then decelerating</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L476-L480">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutinversequad-NTuple{4, Any}" href="#Luxor.easeinoutinversequad-NTuple{4, Any}"><code>Luxor.easeinoutinversequad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinoutinversequad(t, b, c, d)</code></pre><p>ease in, then slow down, then speed up, and ease out</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L525-L529">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutquad-NTuple{4, Any}" href="#Luxor.easeinoutquad-NTuple{4, Any}"><code>Luxor.easeinoutquad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinoutquad(t, b, c, d)</code></pre><p>quadratic easing in/out - acceleration until halfway, then deceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L308-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutquart-NTuple{4, Any}" href="#Luxor.easeinoutquart-NTuple{4, Any}"><code>Luxor.easeinoutquart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinoutquart(t, b, c, d)</code></pre><p>quartic easing in/out - acceleration until halfway, then deceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L378-L382">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutquint-NTuple{4, Any}" href="#Luxor.easeinoutquint-NTuple{4, Any}"><code>Luxor.easeinoutquint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinoutquint(t, b, c, d)</code></pre><p>quintic easing in/out - acceleration until halfway, then deceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L413-L417">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinoutsine-NTuple{4, Any}" href="#Luxor.easeinoutsine-NTuple{4, Any}"><code>Luxor.easeinoutsine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinoutsine(t, b, c, d)</code></pre><p>sinusoidal easing in/out - accelerating until halfway, then decelerating</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L445-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinquad-NTuple{4, Any}" href="#Luxor.easeinquad-NTuple{4, Any}"><code>Luxor.easeinquad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinquad(t, b, c, d)</code></pre><p>quadratic easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L288-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinquart-NTuple{4, Any}" href="#Luxor.easeinquart-NTuple{4, Any}"><code>Luxor.easeinquart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinquart(t, b, c, d)</code></pre><p>quartic easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L357-L361">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinquint-NTuple{4, Any}" href="#Luxor.easeinquint-NTuple{4, Any}"><code>Luxor.easeinquint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinquint(t, b, c, d)</code></pre><p>quintic easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L392-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeinsine-NTuple{4, Any}" href="#Luxor.easeinsine-NTuple{4, Any}"><code>Luxor.easeinsine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeinsine(t, b, c, d)</code></pre><p>sinusoidal easing in - accelerating from zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L427-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutcirc-NTuple{4, Any}" href="#Luxor.easeoutcirc-NTuple{4, Any}"><code>Luxor.easeoutcirc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeoutcirc(t, b, c, d)</code></pre><p>circular easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L500-L504">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutcubic-NTuple{4, Any}" href="#Luxor.easeoutcubic-NTuple{4, Any}"><code>Luxor.easeoutcubic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeoutcubic(t, b, c, d)</code></pre><p>cubic easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutexpo-NTuple{4, Any}" href="#Luxor.easeoutexpo-NTuple{4, Any}"><code>Luxor.easeoutexpo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeoutexpo(t, b, c, d)</code></pre><p>exponential easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L467-L471">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutquad-NTuple{4, Any}" href="#Luxor.easeoutquad-NTuple{4, Any}"><code>Luxor.easeoutquad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeoutquad(t, b, c, d)</code></pre><p>quadratic easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L298-L302">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutquart-NTuple{4, Any}" href="#Luxor.easeoutquart-NTuple{4, Any}"><code>Luxor.easeoutquart</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeoutquart(t, b, c, d)</code></pre><p>quartic easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L367-L371">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutquint-NTuple{4, Any}" href="#Luxor.easeoutquint-NTuple{4, Any}"><code>Luxor.easeoutquint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeoutquint(t, b, c, d)</code></pre><p>quintic easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L402-L406">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easeoutsine-NTuple{4, Any}" href="#Luxor.easeoutsine-NTuple{4, Any}"><code>Luxor.easeoutsine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easeoutsine(t, b, c, d)</code></pre><p>sinusoidal easing out - decelerating to zero velocity</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L436-L440">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.easingflat-NTuple{4, Any}" href="#Luxor.easingflat-NTuple{4, Any}"><code>Luxor.easingflat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">easingflat(t, b, c, d)</code></pre><p>A flat easing function, same as <code>lineartween()</code>.</p><p>For all easing functions, the four parameters are:</p><ul><li><code>t</code> time, ie the current framenumber</li><li><code>b</code> beginning position or bottom value of the range</li><li><code>c</code> total change in position or top value of the range</li><li><code>d</code> duration, ie a framecount</li></ul><ol><li><code>t/d</code> or <code>t/=d</code> normalizes <code>t</code> to between 0 and 1</li><li><code>... * c</code> scales up to the required range value</li><li><code>... + b</code> adds the initial offset</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L267-L283">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ellipse" href="#Luxor.ellipse"><code>Luxor.ellipse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ellipse(focus1::Point, focus2::Point, pt::Point, action=:none;
        stepvalue=pi/100,
        vertices=false,
        reversepath=false)</code></pre><p>Build a polygon approximation to an ellipse, given two points and a point somewhere on the ellipse.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L499-L507">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ellipse" href="#Luxor.ellipse"><code>Luxor.ellipse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ellipse(xc, yc, w, h, action=:none)</code></pre><p>Make an ellipse, centered at <code>xc/yc</code>, fitting in a box of width <code>w</code> and height <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ellipse" href="#Luxor.ellipse"><code>Luxor.ellipse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ellipse(cpt, w, h, action=:none)</code></pre><p>Make an ellipse, centered at point <code>c</code>, with width <code>w</code>, and height <code>h</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L101-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ellipse" href="#Luxor.ellipse"><code>Luxor.ellipse</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ellipse(focus1::Point, focus2::Point, k, action=:none;
        stepvalue=pi/100,
        vertices=false,
        reversepath=false)</code></pre><p>Build a polygon approximation to an ellipse, given two points and a distance, <code>k</code>, which is the sum of the distances to the focii of any points on the ellipse (or the shortest length of string required to go from one focus to the perimeter and on to the other focus).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L470-L479">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ellipseinquad" href="#Luxor.ellipseinquad"><code>Luxor.ellipseinquad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ellipseinquad(qgon, action=:none)</code></pre><p>Calculate a Bézier-based ellipse that fits inside the quadrilateral <code>qgon</code>, an array of with at least four Points, then apply <code>action</code>.</p><p>Returns <code>ellipsecenter, ellipsesemimajor, ellipsesemiminor, ellipseangle</code>:</p><p><code>ellipsecenter</code> the ellipse center</p><p><code>ellipsesemimajor</code> ellipse semimajor axis</p><p><code>ellipsesemiminor</code> ellipse semiminor axis</p><p><code>ellipseangle</code> ellipse rotation</p><p>The function returns <code>O, 0, 0, 0</code> if a suitable ellipse can&#39;t be found. (The qgon is probably not a convex polygon.)</p><p><strong>References</strong></p><p>http://faculty.mae.carleton.ca/John_Hayes/Papers/InscribingEllipse.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L984-L1008">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.epitrochoid" href="#Luxor.epitrochoid"><code>Luxor.epitrochoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">epitrochoid(R, r, d, action=:none;
        stepby=0.01,
        period=0,
        vertices=false)</code></pre><p>Make a epitrochoid with short line segments. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius <code>r</code> rolling around the outside of a fixed circle of radius <code>R</code>, where the point is a distance <code>d</code> from the center of the circle. Things get interesting if you supply non-integral values.</p><p><code>stepby</code>, the angular step value, controls the amount of detail, ie the smoothness of the polygon.</p><p>If <code>period</code> is not supplied, or 0, the lowest period is calculated for you.</p><p>The function can return a polygon (a list of points), or draw the points directly using the supplied <code>action</code>. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of <code>pi</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L563-L582">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.fillpath-Tuple{}" href="#Luxor.fillpath-Tuple{}"><code>Luxor.fillpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fillpath()</code></pre><p>Fill the current path according to the current settings. The current path is then cleared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L164-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.fillpreserve-Tuple{}" href="#Luxor.fillpreserve-Tuple{}"><code>Luxor.fillpreserve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fillpreserve()</code></pre><p>Fill the current path with current settings, but then keep the path current.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.fillstroke-Tuple{}" href="#Luxor.fillstroke-Tuple{}"><code>Luxor.fillstroke</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fillstroke()</code></pre><p>Fill and stroke the current path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.findbeziercontrolpoints-NTuple{4, Point}" href="#Luxor.findbeziercontrolpoints-NTuple{4, Point}"><code>Luxor.findbeziercontrolpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">findbeziercontrolpoints(previouspt::Point,
    pt1::Point,
    pt2::Point,
    nextpt::Point;
    smooth_value=0.5)</code></pre><p>Find the Bézier control points for the line between <code>pt1</code> and <code>pt2</code>, where the point before <code>pt1</code> is <code>previouspt</code> and the next point after <code>pt2</code> is <code>nextpt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L125-L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.finish-Tuple{}" href="#Luxor.finish-Tuple{}"><code>Luxor.finish</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">finish()</code></pre><p>Finish the drawing, and close the file. You may be able to open it in an external viewer application with <code>preview()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L352-L357">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.fontface-Tuple{Any}" href="#Luxor.fontface-Tuple{Any}"><code>Luxor.fontface</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fontface(fontname)</code></pre><p>Select a font to use. (Toy API)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.fontsize-Tuple{Any}" href="#Luxor.fontsize-Tuple{Any}"><code>Luxor.fontsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fontsize(n)</code></pre><p>Set the font size to <code>n</code> units. The default size is 10 units. (Toy API)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L103-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.get_fontsize-Tuple{}" href="#Luxor.get_fontsize-Tuple{}"><code>Luxor.get_fontsize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">get_fontsize()</code></pre><p>Return the font size set by <code>fontsize</code> or. more precisely. the y-scale of the Cairo font matrix if <code>Cairo.set_font_matrix</code> is used directly. (Toy API)</p><blockquote><p>This only works if Cairo is at least at v1.0.5.</p></blockquote></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L111-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getmatrix-Tuple{}" href="#Luxor.getmatrix-Tuple{}"><code>Luxor.getmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getmatrix()</code></pre><p>Get the current matrix. Returns an array of six float64 numbers:</p><ul><li><p>xx component of the affine transformation</p></li><li><p>yx component of the affine transformation</p></li><li><p>xy component of the affine transformation</p></li><li><p>yy component of the affine transformation</p></li><li><p>x0 translation component of the affine transformation</p></li><li><p>y0 translation component of the affine transformation</p></li></ul><p>Some basic matrix transforms:</p><ul><li>translate</li></ul><p><code>transform([1, 0, 0, 1, dx, dy])</code> shifts by <code>dx</code>, <code>dy</code></p><ul><li>scale</li></ul><p><code>transform([fx 0 0 fy 0 0])</code> scales by <code>fx</code> and <code>fy</code></p><ul><li>rotate</li></ul><p><code>transform([cos(a), -sin(a), sin(a), cos(a), 0, 0])</code> rotates around to <code>a</code> radians</p><p>rotate around O: [c -s s c 0 0]</p><ul><li>shear</li></ul><p><code>transform([1 0 a 1 0 0])</code> shears in x direction by <code>a</code></p><p>shear in y direction by <code>a</code>: [1 a 0 1 0 0]</p><ul><li>x-skew</li></ul><p><code>transform([1, 0, tan(a), 1, 0, 0])</code> skews in x by <code>a</code></p><ul><li>y-skew</li></ul><p><code>transform([1, tan(a), 0, 1, 0, 0])</code> skews in y by <code>a</code></p><ul><li>flip</li></ul><p><code>transform([fx, 0, 0, fy, centerx * (1 - fx), centery * (fy-1)])</code> flips with center at <code>centerx</code>/<code>centery</code></p><ul><li>reflect</li></ul><p><code>transform([1 0 0 -1 0 0])</code> reflects in xaxis</p><p><code>transform([-1 0 0 1 0 0])</code> reflects in yaxis</p><p>When a drawing is first created, the matrix looks like this:</p><pre><code class="nohighlight">getmatrix() = [1.0, 0.0, 0.0, 1.0, 0.0, 0.0]</code></pre><p>When the origin is moved to 400/400, it looks like this:</p><pre><code class="nohighlight">getmatrix() = [1.0, 0.0, 0.0, 1.0, 400.0, 400.0]</code></pre><p>To reset the matrix to the original:</p><pre><code class="nohighlight">setmatrix([1.0, 0.0, 0.0, 1.0, 0.0, 0.0])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/matrix.jl#L3-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getmode-Tuple{}" href="#Luxor.getmode-Tuple{}"><code>Luxor.getmode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getmode()</code></pre><p>Return the current compositing/blending mode as a string.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L269-L273">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getnearestpointonline-Tuple{Point, Point, Point}" href="#Luxor.getnearestpointonline-Tuple{Point, Point, Point}"><code>Luxor.getnearestpointonline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getnearestpointonline(pt1::Point, pt2::Point, startpt::Point)</code></pre><p>Given a line from <code>pt1</code> to <code>pt2</code>, and <code>startpt</code> is the start of a perpendicular heading to meet the line, at what point does it hit the line?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L116-L121">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getpath-Tuple{}" href="#Luxor.getpath-Tuple{}"><code>Luxor.getpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getpath()</code></pre><p>Get the current path and return a CairoPath object, which is an array of <code>element_type</code> and <code>points</code> objects. With the results you can step through and examine each entry:</p><pre><code class="nohighlight">o = getpath()
for e in o
      if e.element_type == Cairo.CAIRO_PATH_MOVE_TO
          (x, y) = e.points
          move(x, y)
      elseif e.element_type == Cairo.CAIRO_PATH_LINE_TO
          (x, y) = e.points
          # straight lines
          line(x, y)
          strokepath()
          circle(x, y, 1, :stroke)
      elseif e.element_type == Cairo.CAIRO_PATH_CURVE_TO
          (x1, y1, x2, y2, x3, y3) = e.points
          # Bezier control lines
          circle(x1, y1, 1, :stroke)
          circle(x2, y2, 1, :stroke)
          circle(x3, y3, 1, :stroke)
          move(x, y)
          curve(x1, y1, x2, y2, x3, y3)
          strokepath()
          (x, y) = (x3, y3) # update current point
      elseif e.element_type == Cairo.CAIRO_PATH_CLOSE_PATH
          closepath()
      else
          error(&quot;unknown CairoPathEntry &quot; * repr(e.element_type))
          error(&quot;unknown CairoPathEntry &quot; * repr(e.points))
      end
  end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L562-L598">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getpathflat-Tuple{}" href="#Luxor.getpathflat-Tuple{}"><code>Luxor.getpathflat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getpathflat()</code></pre><p>Get the current path, like <code>getpath()</code> but flattened so that there are no Bèzier curves.</p><p>Returns a CairoPath which is an array of <code>element_type</code> and <code>points</code> objects.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L601-L607">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getrotation-Tuple{Matrix{T} where T}" href="#Luxor.getrotation-Tuple{Matrix{T} where T}"><code>Luxor.getrotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getrotation(R::Matrix)
getrotation()</code></pre><p>Get the rotation of a Julia 3x3 matrix, or the current Luxor rotation.</p><p class="math-container">\[\begin{bmatrix}
a &amp; b &amp; tx \\
c &amp; d &amp; ty \\
0 &amp; 0 &amp; 1  \\
\end{bmatrix}\]</p><p>The rotation angle is <code>atan(-b, a)</code> or <code>atan(c, d)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/matrix.jl#L172-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getscale-Tuple{Matrix{T} where T}" href="#Luxor.getscale-Tuple{Matrix{T} where T}"><code>Luxor.getscale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">getscale(R::Matrix)
getscale()</code></pre><p>Get the current scale of a Julia 3x3 matrix, or the current Luxor scale.</p><p>Returns a tuple of x and y values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/matrix.jl#L198-L205">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.gettranslation-Tuple{Matrix{T} where T}" href="#Luxor.gettranslation-Tuple{Matrix{T} where T}"><code>Luxor.gettranslation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gettranslation(R::Matrix)
gettranslation()</code></pre><p>Get the current translation of a Julia 3x3 matrix, or the current Luxor translation.</p><p>Returns a tuple of x and y values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/matrix.jl#L216-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.getworldposition" href="#Luxor.getworldposition"><code>Luxor.getworldposition</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getworldposition(pt::Point = O;
    centered=true)</code></pre><p>Return the world coordinates of <code>pt</code>.</p><p>The default coordinate system for Luxor/Cairo is that the top left corner is 0/0. If you use <code>origin()</code>, everything moves to the center of the drawing, and this function with the default <code>centered</code> option assumes an <code>origin()</code> function. If you choose <code>centered=false</code>, the returned coordinates will be relative to the top left corner of the drawing.</p><pre><code class="nohighlight">origin()
translate(120, 120)
@show currentpoint()      # =&gt; Point(0.0, 0.0)
@show getworldposition()  # =&gt; Point(120.0, 120.0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L560-L578">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.grestore-Tuple{}" href="#Luxor.grestore-Tuple{}"><code>Luxor.grestore</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">grestore()</code></pre><p>Replace the current graphics state with the one on top of the stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L496-L500">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.gsave-Tuple{}" href="#Luxor.gsave-Tuple{}"><code>Luxor.gsave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gsave()</code></pre><p>Save the current color settings on the stack.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L480-L484">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.hascurrentpoint-Tuple{}" href="#Luxor.hascurrentpoint-Tuple{}"><code>Luxor.hascurrentpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hascurrentpoint()</code></pre><p>Return true if there is a current point. Obtain the current point with <code>currentpoint()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L550-L555">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.highestaspectratio-NTuple{5, Any}" href="#Luxor.highestaspectratio-NTuple{5, Any}"><code>Luxor.highestaspectratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">highestaspectratio()</code></pre><p>Find the highest aspect ratio of a list of rectangles, given the length of the side along which they are to be laid out.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Boxmaptile.jl#L78-L83">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.highlightcells" href="#Luxor.highlightcells"><code>Luxor.highlightcells</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">highlightcells(t::Table, cellnumbers, action::Symbol=:stroke;
        color::Colorant=colorant&quot;red&quot;,
        offset = 0)</code></pre><p>Highlight (draw or fill) one or more cells of table <code>t</code>. <code>cellnumbers</code> is a range, array, or an array of row/column tuples.</p><pre><code class="nohighlight">highlightcells(t, 1:10, :fill, color=colorant&quot;blue&quot;)
highlightcells(t, vcat(1:5, 150), :stroke, color=colorant&quot;magenta&quot;)
highlightcells(t, [(4, 5), (3, 6)])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Table.jl#L278-L289">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.hypotrochoid" href="#Luxor.hypotrochoid"><code>Luxor.hypotrochoid</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">hypotrochoid(R, r, d, action=:none;
        stepby=0.01,
        period=0.0,
        vertices=false)</code></pre><p>Make a hypotrochoid with short line segments. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius <code>r</code> rolling around the inside  of a fixed circle of radius <code>R</code>, where the point is a distance <code>d</code> from  the center of the interior circle. Things get interesting if you supply non-integral values.</p><p>Special cases include the hypocycloid, if <code>d</code> = <code>r</code>, and an ellipse, if <code>R</code> = <code>2r</code>.</p><p><code>stepby</code>, the angular step value, controls the amount of detail, ie the smoothness of the polygon,</p><p>If <code>period</code> is not supplied, or 0, the lowest period is calculated for you.</p><p>The function can return a polygon (a list of points), or draw the points directly using the supplied <code>action</code>. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of <code>pi</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L517-L538">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.image_as_matrix!-Tuple{Any}" href="#Luxor.image_as_matrix!-Tuple{Any}"><code>Luxor.image_as_matrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">image_as_matrix!(buffer)</code></pre><p>Like <code>image_as_matrix()</code>, but use an existing UInt32 buffer.</p><p><code>buffer</code> is a buffer of UInt32.</p><pre><code class="nohighlight">w = 200
h = 150
buffer = zeros(UInt32, w, h)
Drawing(w, h, :image)
origin()
juliacircles(50)
m = image_as_matrix!(buffer)
finish()
# collect(m)) is Array{ARGB32,2}
Images.RGB.(m)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L996-L1015">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.image_as_matrix-Tuple{}" href="#Luxor.image_as_matrix-Tuple{}"><code>Luxor.image_as_matrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">image_as_matrix()</code></pre><p>Return an Array of the current state of the picture as an array of ARGB32.</p><p>A matrix 50 wide and 30 high =&gt; a table 30 rows by 50 cols</p><pre><code class="nohighlight">using Luxor, Images

Drawing(50, 50, :png)
origin()
background(randomhue()...)
sethue(&quot;white&quot;)
fontsize(40)
fontface(&quot;Georgia&quot;)
text(&quot;42&quot;, halign=:center, valign=:middle)
mat = image_as_matrix()
finish()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L843-L864">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.initnoise-Tuple{Any}" href="#Luxor.initnoise-Tuple{Any}"><code>Luxor.initnoise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">initnoise(seed::Int)
initnoise()</code></pre><p>Initialize the noise generation code.</p><pre><code class="nohighlight">julia&gt; initnoise(); noise(1)
0.7453148982810598

julia&gt; initnoise(); noise(1)
0.7027617067916981</code></pre><p>If you provide an integer seed, it will be used to seed <code>Random.seed!()</code>` when the noise code is initialized:</p><pre><code class="nohighlight">julia&gt; initnoise(41); noise(1) # yesterday
0.7134000046640385

julia&gt; initnoise(41); noise(1) # today
0.7134000046640385</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/noise.jl#L179-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.insertvertices!-Tuple{Any}" href="#Luxor.insertvertices!-Tuple{Any}"><code>Luxor.insertvertices!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">insertvertices!(pgon;
    ratio=0.5)</code></pre><p>Insert a new vertex into each edge of a polygon <code>pgon</code>. The default <code>ratio</code> of 0.5 divides the original edge of the polygon into half.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1234-L1240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersectboundingboxes-Tuple{BoundingBox, BoundingBox}" href="#Luxor.intersectboundingboxes-Tuple{BoundingBox, BoundingBox}"><code>Luxor.intersectboundingboxes</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersectboundingboxes(bb1::BoundingBox, bb2::BoundingBox)</code></pre><p>Return a BoundingBox that&#39;s an intersection of the two bounding boxes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L273-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersection2circles-NTuple{4, Any}" href="#Luxor.intersection2circles-NTuple{4, Any}"><code>Luxor.intersection2circles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersection2circles(pt1, r1, pt2, r2)</code></pre><p>Find the area of intersection between two circles, the first centered at <code>pt1</code> with radius <code>r1</code>, the second centered at <code>pt2</code> with radius <code>r2</code>.</p><p>If one circle is entirely within another, that circle&#39;s area is returned.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L672-L679">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersectioncirclecircle-NTuple{4, Any}" href="#Luxor.intersectioncirclecircle-NTuple{4, Any}"><code>Luxor.intersectioncirclecircle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersectioncirclecircle(cp1, r1, cp2, r2)</code></pre><p>Find the two points where two circles intersect, if they do. The first circle is centered at <code>cp1</code> with radius <code>r1</code>, and the second is centered at <code>cp1</code> with radius <code>r1</code>.</p><p>Returns</p><pre><code class="nohighlight">(flag, ip1, ip2)</code></pre><p>where <code>flag</code> is a Boolean <code>true</code> if the circles intersect at the points <code>ip1</code> and <code>ip2</code>. If the circles don&#39;t intersect at all, or one is completely inside the other, <code>flag</code> is <code>false</code> and the points are both Point(0, 0).</p><p>Use <code>intersection2circles()</code> to find the area of two overlapping circles.</p><p>In the pure world of maths, it must be possible that two circles &#39;kissing&#39; only have a single intersection point. At present, this unromantic function reports that two kissing circles have no intersection points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L712-L731">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersectionlinecircle-Tuple{Point, Point, Point, Any}" href="#Luxor.intersectionlinecircle-Tuple{Point, Point, Point, Any}"><code>Luxor.intersectionlinecircle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersectionlinecircle(p1::Point, p2::Point, cpoint::Point, r)</code></pre><p>Find the intersection points of a line (extended through points <code>p1</code> and <code>p2</code>) and a circle.</p><p>Return a tuple of <code>(n, pt1, pt2)</code></p><p>where</p><ul><li><code>n</code> is the number of intersections, <code>0</code>, <code>1</code>, or <code>2</code></li><li><code>pt1</code> is first intersection point, or <code>Point(0, 0)</code> if none</li><li><code>pt2</code> is the second intersection point, or <code>Point(0, 0)</code> if none</li></ul><p>The calculated intersection points won&#39;t necessarily lie on the line segment between <code>p1</code> and <code>p2</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L382-L396">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersectionlines-NTuple{4, Point}" href="#Luxor.intersectionlines-NTuple{4, Point}"><code>Luxor.intersectionlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersectionlines(p0, p1, p2, p3,
    crossingonly=false)</code></pre><p>Find point where two lines intersect.</p><p>If <code>crossingonly == true</code> the point of intersection must lie on both lines.</p><p>If <code>crossingonly == false</code> the point of intersection can be where the lines meet if extended almost to &#39;infinity&#39;.</p><p>Accordng to this function, collinear, overlapping, and parallel lines never intersect. Ie, the line segments might be collinear but have no points in common, or the lines segments might be collinear and have many points in common, or the line segments might be collinear and one is entirely contained within the other.</p><p>If the lines are collinear and share a point in common, that is the intersection point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L431-L450">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.intersectlinepoly-Tuple{Point, Point, Vector{Point}}" href="#Luxor.intersectlinepoly-Tuple{Point, Point, Vector{Point}}"><code>Luxor.intersectlinepoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">intersectlinepoly(pt1::Point, pt2::Point, C)</code></pre><p>Return an array of the points where a line between pt1 and pt2 crosses polygon C.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1036-L1040">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.isarcclockwise-Tuple{Point, Point, Point}" href="#Luxor.isarcclockwise-Tuple{Point, Point, Point}"><code>Luxor.isarcclockwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isarcclockwise(c::Point, A::Point, B::Point)</code></pre><p>Return <code>true</code> if an arc centered at <code>c</code> going from <code>A</code> to <code>B</code> is clockwise.</p><p>If <code>c</code>, <code>A</code>, and <code>B</code> are collinear, then a hemispherical arc could be either clockwise or not.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L220-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.isinside-Tuple{Point, BoundingBox}" href="#Luxor.isinside-Tuple{Point, BoundingBox}"><code>Luxor.isinside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinside(p::Point, bb:BoundingBox)</code></pre><p>Returns <code>true</code> if <code>pt</code> is inside bounding box <code>bb</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L291-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.isinside-Tuple{Point, Vector{Point}}" href="#Luxor.isinside-Tuple{Point, Vector{Point}}"><code>Luxor.isinside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isinside(p, pol; allowonedge=false)</code></pre><p>Is a point <code>p</code> inside a polygon <code>pol</code>? Returns true if it does, or false.</p><p>This is an implementation of the Hormann-Agathos (2001) Point in Polygon algorithm.</p><p>The classification of points lying on the edges of the target polygon, or coincident with its vertices is not clearly defined, due to rounding errors or arithmetical inadequacy. By default these will generate errors, but you can suppress these by setting <code>allowonedge</code> to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L175-L186">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ispointonline-Tuple{Point, Point, Point}" href="#Luxor.ispointonline-Tuple{Point, Point, Point}"><code>Luxor.ispointonline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ispointonline(pt::Point, pt1::Point, pt2::Point;
    extended = false,
    atol = 10E-5)</code></pre><p>Return <code>true</code> if the point <code>pt</code> lies on a straight line between <code>pt1</code> and <code>pt2</code>.</p><p>If <code>extended</code> is false (the default) the point must lie on the line segment between <code>pt1</code> and <code>pt2</code>. If <code>extended</code> is true, the point lies on the line if extended in either direction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L271-L281">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ispointonpoly-Tuple{Point, Vector{Point}}" href="#Luxor.ispointonpoly-Tuple{Point, Vector{Point}}"><code>Luxor.ispointonpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ispointonpoly(pt::Point, pgon;
    atol=10E-5)</code></pre><p>Return <code>true</code> if <code>pt</code> lies on the polygon <code>pgon.</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L313-L318">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ispolyclockwise-Tuple{Vector{Point}}" href="#Luxor.ispolyclockwise-Tuple{Vector{Point}}"><code>Luxor.ispolyclockwise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ispolyclockwise(pgon)</code></pre><p>Returns true if polygon is clockwise. WHEN VIEWED IN A LUXOR DRAWING...?</p><p>TODO This code is still experimental...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1097-L1103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ispolyconvex-Tuple{Any}" href="#Luxor.ispolyconvex-Tuple{Any}"><code>Luxor.ispolyconvex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ispolyconvex(pts)</code></pre><p>Return true if polygon is convex. This tests that every interior angle is less than or equal to 180°.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L615-L620">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.juliacircles" href="#Luxor.juliacircles"><code>Luxor.juliacircles</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">juliacircles(radius=100;
    outercircleratio=0.75,
    innercircleratio=0.65,
    action=:fill)</code></pre><p>Draw the three Julia circles (&quot;dots&quot;) in color centered at the origin.</p><p>The distance of the centers of each circle from the origin is <code>radius</code>.</p><p>The optional keyword argument <code>outercircleratio</code> (default 0.75) determines the radius of each circle relative to the main radius. So the default is to draw circles of radius 75 points around a larger circle of radius 100.</p><p>Return the three centerpoints.</p><p>The <code>innercircleratio</code> (default 0.65) no longer does anything useful (it used to draw the smaller circles) and will be deprecated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/juliagraphics.jl#L226-L241">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.julialogo-Tuple{}" href="#Luxor.julialogo-Tuple{}"><code>Luxor.julialogo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">julialogo(;
    action=:fill,
    color=true,
    bodycolor=colorant&quot;black&quot;,
    centered=false)</code></pre><p>Draw the Julia logo. The default action is to fill the logo and use the colors:</p><pre><code class="nohighlight">julialogo()</code></pre><p>If <code>color</code> is <code>false</code>, the <code>bodycolor</code> color is used for the logo.</p><p>The function uses the current drawing state (position, scale, etc).</p><p>The <code>centered</code> keyword lets you center the logo at its mathematical center, but the optical center might lie somewhere else - it&#39;s difficult to position well due to its asymmetric design.</p><p>To use the logo as a clipping mask:</p><pre><code class="nohighlight">julialogo(action=:clip)</code></pre><p>(In this case the <code>color</code> setting is automatically ignored.)</p><p>To obtain a stroked (outlined) version:</p><pre><code class="nohighlight">julialogo(action=:path)
sethue(&quot;red&quot;)
strokepath()</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/juliagraphics.jl#L23-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.juliatocairomatrix-Tuple{Matrix{T} where T}" href="#Luxor.juliatocairomatrix-Tuple{Matrix{T} where T}"><code>Luxor.juliatocairomatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">juliatocairomatrix(c)</code></pre><p>Return a six-element matrix that&#39;s the equivalent of the 3x3 Julia matrix in <code>c</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/matrix.jl#L163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.label" href="#Luxor.label"><code>Luxor.label</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">label(txt::AbstractString, rotation::Float64, pos::Point=O;
    offset=5,
    leader=false,
    leaderoffsets=[0.0, 1.0])</code></pre><p>Add a text label at a point, positioned relative to that point, for example, <code>0.0</code> is East, <code>pi</code> is West.</p><pre><code class="nohighlight">label(&quot;text&quot;, pi)          # positions text to the left of the origin</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L456-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.label" href="#Luxor.label"><code>Luxor.label</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">label(txt::AbstractString, alignment::Symbol=:N, pos::Point=O;
    offset=5,
    leader=false,
    leaderoffsets=[0.0, 1.0])</code></pre><p>Add a text label at a point, positioned relative to that point, for example, <code>:N</code> signifies North and places the text directly above that point.</p><p>Use one of <code>:N</code>, <code>:S</code>, <code>:E</code>, <code>:W</code>, <code>:NE</code>, <code>:SE</code>, <code>:SW</code>, <code>:NW</code> to position the label relative to that point.</p><pre><code class="nohighlight">label(&quot;text&quot;)          # positions text at North (above), relative to the origin
label(&quot;text&quot;, :S)      # positions text at South (below), relative to the origin
label(&quot;text&quot;, :S, pt)  # positions text South of pt
label(&quot;text&quot;, :N, pt, offset=20)  # positions text North of pt, offset by 20</code></pre><p>The default offset is 5 units.</p><p>If <code>leader</code> is true, draw a line as well.</p><p><code>leaderoffsts</code> uses normalized fractions (see <code>between()</code>) to specify the gap between the designated points and the start and end of the lines.</p><p>TODO: Negative offsets don&#39;t give good results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L394-L420">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.layout-NTuple{5, Any}" href="#Luxor.layout-NTuple{5, Any}"><code>Luxor.layout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">layout(A, x, y, w, h)</code></pre><p>From A, make a row of tiles (if wider than tall) or a column of tiles (if taller than wide).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Boxmaptile.jl#L41-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.layout_spring-Tuple{Matrix{T} where T}" href="#Luxor.layout_spring-Tuple{Matrix{T} where T}"><code>Luxor.layout_spring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">layout_spring(adjmatrix::Array{T,2} where T;
    densityconstant = 2.0,
    maxiterations = 100,
    initialtemperature = 2.0,
    boundingbox=BoundingBox(O - (250, 250), O + (250, 250)))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/graphlayout.jl#L99-L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.layout_tree-Tuple{AbstractVector{T} where T}" href="#Luxor.layout_tree-Tuple{AbstractVector{T} where T}"><code>Luxor.layout_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><p>layout_tree(adjlist)</p><p><code>adj_list</code> must not be cyclic, otherwise welcome to stack overflow...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/graphlayout.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.layoutgraph-Tuple{Matrix{T} where T}" href="#Luxor.layoutgraph-Tuple{Matrix{T} where T}"><code>Luxor.layoutgraph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">layoutgraph(adj_matrix::Array{T,2}; kwargs...)       &lt;--
layoutgraph(adj_list::AbstractVector; kwargs...)     not yet implemented</code></pre><p>Run one of two graph layout algorithms.</p><p>1: Layout the graph in adjacency matrix <code>adj_matrix</code>, using a spring-based method. Returns a tuple of <code>([xcoords], [ycoords])</code>, which are scaled according to the supplied BoundingBox.</p><p><strong>Keyword arguments</strong></p><p>Lay out the graph in <code>adjmatrix</code> using the spring/repulsion model of Fruchterman and Reingold (1991). Returns a tuple of <code>([xcoords], [ycoords])</code>.</p><p><strong>Arguments</strong></p><p><code>am</code> An adjacency matrix of some type. Non-zero of the eltype of the matrix is used to determine if a link exists, but currently no sense of magnitude</p><p><code>densityconstant</code> Constant to adjust the density of resulting layout. The default value is 2.0.</p><p><code>maxiterations</code> how many iterations for applying the forces</p><p><code>initialtemperature</code> the initial temperature controls movement per iteration. The default value is 2.0. Each iteration uses a lower temperature (TEMP = initialtemperature / iter). The idea is that the displacements of vertices are limited to some maximum temperature value, and this decreases over time. As the layout becomes better, the amount of adjustment becomes smaller.</p><p><code>locs_x</code> the starting x values, between -1 and 1. The default values are randomly selected.</p><p><code>locs_y</code> the starting y values, between -1 and 1. The default values are randomly selected.</p><p><code>boundingbox</code> The Luxor BoundingBox into which the graph&#39;s coordinates will fit. Defaults to 500 × 500.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/graphlayout.jl#L28-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.line" href="#Luxor.line"><code>Luxor.line</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">line(pt1::Point, pt2::Point, action=:none)</code></pre><p>Make a line between two points, <code>pt1</code> and <code>pt2</code> and do an action.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L372-L376">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.line-Tuple{Any, Any}" href="#Luxor.line-Tuple{Any, Any}"><code>Luxor.line</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">line(pt)</code></pre><p>Draw a line from the current position to the <code>pt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L364-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.lineartween-NTuple{4, Any}" href="#Luxor.lineartween-NTuple{4, Any}"><code>Luxor.lineartween</code></a> — <span class="docstring-category">Method</span></header><section><div><p>default linear transition - no easing, no acceleration</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.makebezierpath-Tuple{Vector{Point}}" href="#Luxor.makebezierpath-Tuple{Vector{Point}}"><code>Luxor.makebezierpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">makebezierpath(pgon::Array{Point, 1}; smoothing=1.0)</code></pre><p>Return a Bézier path (a BezierPath) that represents a polygon (an array of points). The Bézier path is an array of segments (tuples of 4 points); each segment contains the four points that make up a section of the entire Bézier path. <code>smoothing</code> determines how closely the curve follows the polygon. A value of 0 returns a straight-sided path; as values move above 1 the paths deviate further from the original polygon&#39;s edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L153-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.mask-Tuple{Point, Point, Any, Any}" href="#Luxor.mask-Tuple{Point, Point, Any, Any}"><code>Luxor.mask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mask(point::Point, focus::Point, width, height)
    max = 1.0,
    min = 0.0,
    easingfunction = easingflat)</code></pre><p>Calculate a value between 0 and 1 for a <code>point</code> relative to a rectangular area defined by <code>focus</code>, <code>width</code>, and <code>height</code>. The value will approach <code>max</code> (1.0) at the center, and <code>min</code> (0.0) at the edges.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L304-L313">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.mask-Tuple{Point, Point, Any}" href="#Luxor.mask-Tuple{Point, Point, Any}"><code>Luxor.mask</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mask(point::Point, focus::Point, radius)
    max = 1.0,
    min = 0.0,
    easingfunction = easingflat)</code></pre><p>Calculate a value between 0 and 1 for a <code>point</code> relative to a circular area defined by <code>focus</code> and <code>radius</code>. The value will approach <code>max</code> (1.0) at the center of the circular area, and <code>min</code> (0.0) at the circumference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L278-L287">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.mesh" href="#Luxor.mesh"><code>Luxor.mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mesh(points::Array{Point},
     colors=Array{Colors.Colorant, 1})</code></pre><p>Create a mesh.</p><p>Create a mesh. The first three or four sides of the supplied <code>points</code> polygon define the three or four sides of the mesh shape.</p><p>The <code>colors</code> array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.</p><p><strong>Example</strong></p><pre><code class="nohighlight">@svg begin
    pl = ngon(O, 250, 3, pi/6, vertices=true)
    mesh1 = mesh(pl, [
        &quot;purple&quot;,
        Colors.RGBA(0.0, 1.0, 0.5, 0.5),
        &quot;yellow&quot;
        ])
    setmesh(mesh1)
    setline(180)
    ngon(O, 250, 3, pi/6, :strokepreserve)
    setline(5)
    sethue(&quot;black&quot;)
    strokepath()
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/mesh.jl#L57-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.mesh" href="#Luxor.mesh"><code>Luxor.mesh</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mesh(bezierpath::BezierPath,
     colors=Array{Colors.Colorant, 1})</code></pre><p>Create a mesh. The first three or four elements of the supplied <code>bezierpath</code> define the three or four sides of the mesh shape.</p><p>The <code>colors</code> array define the color of each corner point. Colors are reused if necessary. At least one color should be supplied.</p><p>Use <code>setmesh()</code> to select the mesh, which will be used to fill shapes.</p><p><strong>Example</strong></p><pre><code class="nohighlight">@svg begin
    bp = makebezierpath(ngon(O, 50, 4, 0, vertices=true))
    mesh1 = mesh(bp, [
        &quot;red&quot;,
        Colors.RGB(0, 1, 0),
        Colors.RGB(0, 1, 1),
        Colors.RGB(1, 0, 1)
        ])
    setmesh(mesh1)
    box(O, 500, 500, :fill)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/mesh.jl#L3-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.midpoint-Tuple{Array}" href="#Luxor.midpoint-Tuple{Array}"><code>Luxor.midpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">midpoint(a)</code></pre><p>Find midpoint between the first two elements of an array of points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L142-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.midpoint-Tuple{BoundingBox}" href="#Luxor.midpoint-Tuple{BoundingBox}"><code>Luxor.midpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">midpoint(bb::BoundingBox)</code></pre><p>Returns the point midway between the two points of the BoundingBox. This should also be the center, unless I&#39;ve been very stupid...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L299-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.midpoint-Tuple{Point, Point}" href="#Luxor.midpoint-Tuple{Point, Point}"><code>Luxor.midpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">midpoint(p1, p2)</code></pre><p>Find the midpoint between two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L135-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.move-Tuple{Any, Any}" href="#Luxor.move-Tuple{Any, Any}"><code>Luxor.move</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">move(pt)</code></pre><p>Move to a point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L348-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.nearestindex-Tuple{Vector{T} where T&lt;:Real, Any}" href="#Luxor.nearestindex-Tuple{Vector{T} where T&lt;:Real, Any}"><code>Luxor.nearestindex</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nearestindex(polydistancearray, value)</code></pre><p>Return a tuple of the index of the largest value in <code>polydistancearray</code> less than <code>value</code>, and the difference value. Array is assumed to be sorted.</p><p>(Designed for use with <code>polydistances()</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L870-L877">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.newpath-Tuple{}" href="#Luxor.newpath-Tuple{}"><code>Luxor.newpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newpath()</code></pre><p>Create a new path. This is Cairo&#39;s <code>new_path()</code> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.newsubpath-Tuple{}" href="#Luxor.newsubpath-Tuple{}"><code>Luxor.newsubpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">newsubpath()</code></pre><p>Add a new subpath to the current path. This is Cairo&#39;s <code>new_sub_path()</code> function. It can be used for example to make holes in shapes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L141-L146">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.nextgridpoint-Tuple{GridHex}" href="#Luxor.nextgridpoint-Tuple{GridHex}"><code>Luxor.nextgridpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nextgridpoint(g::GridHex)</code></pre><p>Returns the next available grid point of a hexagonal grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/tiles-grids.jl#L220-L224">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.nextgridpoint-Tuple{GridRect}" href="#Luxor.nextgridpoint-Tuple{GridRect}"><code>Luxor.nextgridpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nextgridpoint(g::GridRect)</code></pre><p>Returns the next available (or even the first) grid point of a grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/tiles-grids.jl#L192-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ngon" href="#Luxor.ngon"><code>Luxor.ngon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ngon(x, y, radius, sides=5, orientation=0, action=:none;
    vertices=false, reversepath=false)</code></pre><p>Draw a regular polygon centered at point <code>centerpos</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L152-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ngon" href="#Luxor.ngon"><code>Luxor.ngon</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ngon(centerpos, radius, sides=5, orientation=0, action=:none;
    vertices=false,
    reversepath=false)</code></pre><p>Draw a regular polygon centered at point <code>centerpos</code>.</p><p>Find the vertices of a regular n-sided polygon centered at <code>x</code>, <code>y</code> with circumradius <code>radius</code>.</p><p>The polygon is constructed counterclockwise, starting with the first vertex drawn below the positive x-axis.</p><p>If you just want the raw points, use keyword argument <code>vertices=true</code>, which returns the array of points. Compare:</p><pre><code class="language-julia">ngon(0, 0, 4, 4, 0, vertices=true) # returns the polygon&#39;s points:

    4-element Array{Luxor.Point, 1}:
    Luxor.Point(2.4492935982947064e-16, 4.0)
    Luxor.Point(-4.0, 4.898587196589413e-16)
    Luxor.Point(-7.347880794884119e-16, -4.0)
    Luxor.Point(4.0, -9.797174393178826e-16)</code></pre><p>whereas</p><pre><code class="nohighlight">ngon(0, 0, 4, 4, 0, :close) # draws a polygon</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L169-L200">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.ngonside" href="#Luxor.ngonside"><code>Luxor.ngonside</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">ngonside(centerpoint::Point, sidelength::Real, sides::Int=5, orientation=0,
    action=:none; kwargs...)</code></pre><p>Draw a regular polygon centered at <code>centerpoint</code> with <code>sides</code> sides of length <code>sidelength</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L204-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.noise-Union{Tuple{Any}, Tuple{T}} where T&lt;:Integer" href="#Luxor.noise-Union{Tuple{Any}, Tuple{T}} where T&lt;:Integer"><code>Luxor.noise</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">noise(x)          ; detail = 1, persistence = 1.0) # 1D
noise(x, y)       ; detail = 1, persistence = 1.0) # 2D
noise(x, y, z)    ; detail = 1, persistence = 1.0) # 3D
noise(x, y, z, w) ; detail = 1, persistence = 1.0) # 4D</code></pre><p>Generate a noise value between 0.0 and 1.0 corresponding to the <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code> values. An <code>x</code> value on its own produces 1D noise, <code>x</code> and <code>y</code> make 2D noise, and so on.</p><p>The <code>detail</code> value is an integer (&gt;= 1) specifying how many octaves of noise you want.</p><p>The <code>persistence</code> value, typically between 0.0 and 1.0, controls how quickly the amplitude diminishes for each successive octave for values of <code>detail</code> greater than 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/noise.jl#L5-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.offsetlinesegment-NTuple{5, Any}" href="#Luxor.offsetlinesegment-NTuple{5, Any}"><code>Luxor.offsetlinesegment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">offsetlinesegment(p1, p2, p3, d1, d2)</code></pre><p>Given three points, find another 3 points that are offset by d1 at the start and d2 at the end.</p><p>Negative d values put the offset on the left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L544-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.offsetpoly-Tuple{Any, Function}" href="#Luxor.offsetpoly-Tuple{Any, Function}"><code>Luxor.offsetpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><p>offsetpoly(plist, shape::Function)</p><p>Return a closed polygon that is offset from and encloses an polyline.</p><p>The incoming set of points <code>plist</code> is treated as an polyline, and another set of points is created, which form a closed polygon offset from the source poly.</p><p>This method for <code>offsetpoly()</code> treats the list of points as <code>n</code> vertices connected with <code>n - 1</code> lines. (The other method <code>offsetpoly(plist, d)</code> treats the list of points as <code>n</code> vertices connected with <code>n</code> lines.)</p><p>The supplied function determines the width of the line. <code>f(0, θ)</code> gives the width at the start (the slope of the curve at that point is supplied in θ), <code>f(1, θ)</code> provides the width at the end, and <code>f(n, θ)</code> is the width of point <code>n/l</code>.</p><p><strong>Examples</strong></p><p>This example draws a tilde, with the ends starting at 20 (10 + 10) units wide, swelling to 50 (10 + 10 + 15 + 15) in the middle, as f(0.5) = 25.</p><pre><code class="nohighlight">f(x, θ) =  10 + 15sin(x * π)
sinecurve = [Point(50x, 50sin(x)) for x in -π:π/24:π]
pgon = offsetpoly(sinecurve, f)
poly(pgon, :fill)</code></pre><p>This example enhances the vertical part of the curve, and thins the horizontal parts.</p><pre><code class="nohighlight">g(x, θ) = rescale(abs(sin(θ)), 0, 1, 0.1, 30)
sinecurve = [Point(50x, 50sin(x)) for x in -π:π/24:π]
pgon = offsetpoly(sinecurve, g)
poly(pgon, :fill)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L678-L721">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.offsetpoly-Tuple{Any}" href="#Luxor.offsetpoly-Tuple{Any}"><code>Luxor.offsetpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">offsetpoly(plist;
    startoffset = 10,
    endoffset   = 10,
    easingfunction = lineartween)</code></pre><p>Return a closed polygon that is offset from and encloses an open polygon.</p><p>The incoming set of points <code>plist</code> is treated as an open polygon, and another set of points is created, which form a polygon lying <code>...offset</code> units away from the source poly.</p><p>This method for <code>offsetpoly()</code> treats the list of points as <code>n</code> vertices connected with <code>n - 1</code> lines. It allows you to vary the offset from the start of the line to the end.</p><p>The other method <code>offsetpoly(plist, d)</code> treats the list of points as <code>n</code> vertices connected with <code>n</code> lines.</p><p><strong>Extended help</strong></p><p>This function accepts a keyword argument that allows you to control the offset using a function, using the easing functionality built in to Luxor. By default the function is <code>lineartween()</code>, so the offset changes linearly between the <code>startoffset</code> and the <code>endoffset</code>. The function:</p><pre><code class="nohighlight">f(a, b, c, d) = 2sin((a * π))</code></pre><p>runs from 0 to 2 and back as <code>a</code> runs from 0 to 1. The offsets are scaled by this amount.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L591-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.offsetpoly-Union{Tuple{T}, Tuple{Vector{Point}, T}} where T&lt;:Number" href="#Luxor.offsetpoly-Union{Tuple{T}, Tuple{Vector{Point}, T}} where T&lt;:Number"><code>Luxor.offsetpoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">offsetpoly(plist::Array{Point, 1}, d) where T&lt;:Number</code></pre><p>Return a polygon that is offset from a polygon by <code>d</code> units.</p><p>The incoming set of points <code>plist</code> is treated as a polygon, and another set of points is created, which form a polygon lying <code>d</code> units away from the source poly.</p><p>Polygon offsetting is a topic on which people have written PhD theses and published academic papers, so this short brain-dead routine will give good results for simple polygons up to a point (!). There are a number of issues to be aware of:</p><ul><li><p>very short lines tend to make the algorithm &#39;flip&#39; and produce larger lines</p></li><li><p>small polygons that are counterclockwise and larger offsets may make the new</p></li></ul><p>polygon appear the wrong side of the original</p><ul><li><p>very sharp vertices will produce even sharper offsets, as the calculated intersection point veers off to infinity</p></li><li><p>duplicated adjacent points might cause the routine to scratch its head and wonder how to draw a line parallel to them</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L479-L501">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.origin-Tuple{Any}" href="#Luxor.origin-Tuple{Any}"><code>Luxor.origin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">origin(pt:Point)</code></pre><p>Reset the current matrix, then move the <code>0/0</code> position to <code>pt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L19-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.origin-Tuple{}" href="#Luxor.origin-Tuple{}"><code>Luxor.origin</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">origin()</code></pre><p>Reset the current matrix, and then set the 0/0 origin to the center of the drawing (otherwise it will stay at the top left corner, the default).</p><p>You can refer to the 0/0 point as <code>O</code>. (O = <code>Point(0, 0)</code>),</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.paint-Tuple{}" href="#Luxor.paint-Tuple{}"><code>Luxor.paint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">paint()</code></pre><p>Paint the current clip region with the current settings.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L171-L175">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pathtobezierpaths-Tuple{}" href="#Luxor.pathtobezierpaths-Tuple{}"><code>Luxor.pathtobezierpaths</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pathtobezierpaths(
    ; flat=true)</code></pre><p>Convert the current path (which may consist of one or more paths) to an array of Bezier paths. Each Bezier path is, in turn, an array of path segments. Each path segment is a tuple of four points. A straight line is converted to a Bezier segment in which the control points are set to be the same as the end points.</p><p>If <code>flat</code> is true, use <code>getpathflat()</code> rather than <code>getpath()</code>.</p><p><strong>Example</strong></p><p>This code draws the Bezier segments and shows the control points as &quot;handles&quot;, like a vector-editing program might.</p><pre><code class="nohighlight">@svg begin
    fontface(&quot;MyanmarMN-Bold&quot;)
    st = &quot;goo&quot;
    thefontsize = 100
    fontsize(thefontsize)
    sethue(&quot;red&quot;)
    fontsize(thefontsize)
    textpath(st)
    nbps = pathtobezierpaths()
    for nbp in nbps
        setline(.15)
        sethue(&quot;grey50&quot;)
        drawbezierpath(nbp, :stroke)
        for p in nbp
            sethue(&quot;red&quot;)
            circle(p[2], 0.16, :fill)
            circle(p[3], 0.16, :fill)
            line(p[2], p[1], :stroke)
            line(p[3], p[4], :stroke)
            if p[1] != p[4]
                sethue(&quot;black&quot;)
                circle(p[1], 0.26, :fill)
                circle(p[4], 0.26, :fill)
            end
        end
    end
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L292-L338">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pathtopoly-Tuple{}" href="#Luxor.pathtopoly-Tuple{}"><code>Luxor.pathtopoly</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pathtopoly()</code></pre><p>Convert the current path to an array of polygons.</p><p>Returns an array of polygons, corresponding to the paths and subpaths of the original path.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L802-L808">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.perpendicular-Tuple{Point, Point, Any}" href="#Luxor.perpendicular-Tuple{Point, Point, Any}"><code>Luxor.perpendicular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perpendicular(p1, p2, k)</code></pre><p>Return a point <code>p3</code> that is <code>k</code> units away from <code>p1</code>, such that a line <code>p1 p3</code> is perpendicular to <code>p1 p2</code>.</p><p>Convention? to the right?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L165-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.perpendicular-Tuple{Point, Point}" href="#Luxor.perpendicular-Tuple{Point, Point}"><code>Luxor.perpendicular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perpendicular(p1, p2)</code></pre><p>Return two points <code>p3</code> and <code>p4</code> such that a line from <code>p3</code> to <code>p4</code> is perpendicular to a line from <code>p1</code> to <code>p2</code>, the same length, and the lines intersect at their midpoints.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L186-L191">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.perpendicular-Tuple{Point}" href="#Luxor.perpendicular-Tuple{Point}"><code>Luxor.perpendicular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">perpendicular(p::Point)</code></pre><p>Returns point <code>Point(p.y, -p.x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pie" href="#Luxor.pie"><code>Luxor.pie</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pie(x, y, radius, startangle, endangle, action=:none)</code></pre><p>Draw a pie shape centered at <code>x</code>/<code>y</code>. Angles start at the positive x-axis and are measured clockwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L355-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pie" href="#Luxor.pie"><code>Luxor.pie</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pie(radius, startangle, endangle, action=:none)</code></pre><p>Draw a pie shape centered at the origin</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L383-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pie-Tuple{Point, Any, Any, Any, Any}" href="#Luxor.pie-Tuple{Point, Any, Any, Any, Any}"><code>Luxor.pie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pie(centerpoint, radius, startangle, endangle, action=:none)</code></pre><p>Draw a pie shape centered at <code>centerpoint</code>.</p><p>Angles start at the positive x-axis and are measured clockwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L373-L379">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.placeimage" href="#Luxor.placeimage"><code>Luxor.placeimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">placeimage(svgimg, pos=O; centered=false)</code></pre><p>Place an SVG image stored in <code>svgimg</code> on the drawing at <code>pos</code>. Use <code>readsvg()</code> to read an SVG image from file, or from SVG code.</p><p>Use keyword <code>centered=true</code> to place the center of the image at the position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/images.jl#L161-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.placeimage" href="#Luxor.placeimage"><code>Luxor.placeimage</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">placeimage(matrix::AbstractMatrix{UInt32}, pos=O;
    alpha=1, centered=false)</code></pre><p>Place an image matrix on the drawing at <code>pos</code> with opacity/transparency <code>alpha</code>.</p><p>Use keyword <code>centered=true</code> to place the center of the image at the position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/images.jl#L181-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.placeimage-Tuple{Cairo.CairoSurface, Any, Any, Any}" href="#Luxor.placeimage-Tuple{Cairo.CairoSurface, Any, Any, Any}"><code>Luxor.placeimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">placeimage(img, pt::Point=O, alpha; centered=false)
placeimage(pngimg, xpos, ypos, alpha; centered=false)</code></pre><p>Place a PNG image <code>pngimg</code> on the drawing at <code>pt</code> or <code>Point(xpos, ypos)</code> with opacity/transparency <code>alpha</code>. The image has been previously loaded using <code>readpng()</code>.</p><p>Use keyword <code>centered=true</code> to place the center of the image at the position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/images.jl#L50-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.placeimage-Tuple{Cairo.CairoSurface, Any, Any}" href="#Luxor.placeimage-Tuple{Cairo.CairoSurface, Any, Any}"><code>Luxor.placeimage</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">placeimage(pngimg, pos=O; centered=false)
placeimage(pngimg, xpos, ypos; centered=false)</code></pre><p>Place the PNG image on the drawing at <code>pos</code>, or (<code>xpos</code>/<code>ypos</code>). The image <code>img</code> has been previously read using <code>readpng()</code>.</p><p>Use keyword <code>centered=true</code> to place the center of the image at the position.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/images.jl#L29-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pointcircletangent-Tuple{Point, Point, Any}" href="#Luxor.pointcircletangent-Tuple{Point, Point, Any}"><code>Luxor.pointcircletangent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pointcircletangent(point::Point, circlecenter::Point, circleradius)</code></pre><p>Find the two points on a circle that lie on tangent lines passing through an external point.</p><p>If both points are O, the external point is inside the circle, and the result is <code>(O, O)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L926-L934">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pointcrossesboundingbox-Tuple{Any, BoundingBox}" href="#Luxor.pointcrossesboundingbox-Tuple{Any, BoundingBox}"><code>Luxor.pointcrossesboundingbox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pointcrossesboundingbox(pt, bbox::BoundingBox)</code></pre><p>Find and return the point where a line from the center of bounding box <code>bbox</code> to point <code>pt</code> would, if continued, cross the edges of the box.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L432-L437">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pointinverse-Tuple{Point, Any, Any}" href="#Luxor.pointinverse-Tuple{Point, Any, Any}"><code>Luxor.pointinverse</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pointinverse(A::Point, centerpoint::Point, rad)</code></pre><p>Find <code>A′</code>, the inverse of a point A with respect to a circle <code>centerpoint</code>/<code>rad</code>, such that:</p><pre><code class="nohighlight">distance(centerpoint, A) * distance(centerpoint, A′) == rad^2</code></pre><p>Return (true, A′) or (false, A).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L513-L523">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.pointlinedistance-Tuple{Point, Point, Point}" href="#Luxor.pointlinedistance-Tuple{Point, Point, Point}"><code>Luxor.pointlinedistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pointlinedistance(p::Point, a::Point, b::Point)</code></pre><p>Find the distance between a point <code>p</code> and a line between two points <code>a</code> and <code>b</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L105-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polar-Tuple{Any, Any}" href="#Luxor.polar-Tuple{Any, Any}"><code>Luxor.polar</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polar(r, theta)</code></pre><p>Convert point in polar form (radius and angle) to a Point.</p><pre><code class="nohighlight">polar(10, pi/4)</code></pre><p>produces</p><pre><code class="nohighlight">Luxor.Point(7.071067811865475, 7.0710678118654755)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L418-L428">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.poly" href="#Luxor.poly"><code>Luxor.poly</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Draw a polygon.</p><pre><code class="nohighlight">poly(pointlist::Array{Point, 1}, action = :none;
    close=false,
    reversepath=false)</code></pre><p>A polygon is an Array of Points. By default <code>poly()</code> doesn&#39;t close or fill the polygon, to allow for clipping.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L3-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.poly" href="#Luxor.poly"><code>Luxor.poly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">poly(bbox::BoundingBox, :action; kwargs...)</code></pre><p>Make a polygon around the BoundingBox in <code>bbox</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L232-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyarea-Tuple{Vector{Point}}" href="#Luxor.polyarea-Tuple{Vector{Point}}"><code>Luxor.polyarea</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polyarea(p::Array)</code></pre><p>Find the area of a simple polygon. It works only for polygons that don&#39;t self-intersect. See also <code>polyorientation()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1018-L1023">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polycentroid-Tuple{Vector{Point}}" href="#Luxor.polycentroid-Tuple{Vector{Point}}"><code>Luxor.polycentroid</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Find the centroid of simple polygon.</p><pre><code class="nohighlight">polycentroid(pointlist)</code></pre><p>Returns a point. This only works for simple (non-intersecting) polygons.</p><p>You could test the point using <code>isinside()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L34-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polycross" href="#Luxor.polycross"><code>Luxor.polycross</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polycross(pt::Point, radius, npoints::Int, ratio=0.5, orientation=0.0, action=:none;
    splay       = 0.5,
    vertices    = false,
    reversepath = false)</code></pre><p>Make a cross-shaped polygon with <code>npoints</code> arms to fit inside a circle of radius <code>radius</code> centered at <code>pt</code>.</p><p><code>ratio</code> specifies the ratio of the two sides of each arm. <code>splay</code> makes the arms ... splayed.</p><p>Use <code>vertices=true</code> to return the vertices of the shape instead of drawing it.</p><p>(Adapted from Compose.jl.xgon()))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L316-L329">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polydistances-Tuple{Vector{Point}}" href="#Luxor.polydistances-Tuple{Vector{Point}}"><code>Luxor.polydistances</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polydistances(p::Array{Point, 1}; closed=true)</code></pre><p>Return an array of the cumulative lengths of a polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L841-L845">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyfit" href="#Luxor.polyfit"><code>Luxor.polyfit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyfit(plist::Array, npoints=30)</code></pre><p>Build a polygon that constructs a B-spine approximation to it. The resulting list of points makes a smooth path that runs between the first and last points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L765-L770">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyintersect-Tuple{AbstractVector{Point}, AbstractVector{Point}}" href="#Luxor.polyintersect-Tuple{AbstractVector{Point}, AbstractVector{Point}}"><code>Luxor.polyintersect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polyintersect(p1::AbstractArray{Point, 1}, p2::AbstractArray{Point, 1};
    closed=true)</code></pre><p>TODO: Fix/test/improve this experimental polygon intersection routine.</p><p>Return the points where polygon p1 and polygon p2 cross.</p><p>If <code>closed</code> is false, the intersection points must lie on the first <code>n - 1</code> lines of each polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1260-L1270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyintersections-Tuple{Vector{Point}, Vector{Point}}" href="#Luxor.polyintersections-Tuple{Vector{Point}, Vector{Point}}"><code>Luxor.polyintersections</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polyintersections(S::Array{Point, 1}, C::Array{Point, 1})</code></pre><p>Return an array of the points in polygon S plus the points where polygon S crosses polygon C. Calls <code>intersectlinepoly()</code>.</p><p>TODO This code is experimental...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1055-L1062">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polymove!-Tuple{Any, Point, Point}" href="#Luxor.polymove!-Tuple{Any, Point, Point}"><code>Luxor.polymove!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polymove!(pgon, frompoint::Point, topoint::Point)</code></pre><p>Move (permanently) a polygon from <code>frompoint</code> to <code>topoints</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1159-L1163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyorientation-Tuple{Vector{Point}}" href="#Luxor.polyorientation-Tuple{Vector{Point}}"><code>Luxor.polyorientation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polyorientation(pgon)</code></pre><p>Returns a number which is positive if the polygon is clockwise in Luxor...</p><p>TODO This code is still experimental...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1078-L1084">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyperimeter-Tuple{Vector{Point}}" href="#Luxor.polyperimeter-Tuple{Vector{Point}}"><code>Luxor.polyperimeter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polyperimeter(p::Array{Point, 1}; closed=true)</code></pre><p>Find the total length of the sides of polygon <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L861-L865">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyportion" href="#Luxor.polyportion"><code>Luxor.polyportion</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyportion(p::Array{Point, 1}, portion=0.5; closed=true, pdist=[])</code></pre><p>Return a portion of a polygon, starting at a value between 0.0 (the beginning) and 1.0 (the end). 0.5 returns the first half of the polygon, 0.25 the first quarter, 0.75 the first three quarters, and so on.</p><p>Use <code>closed=false</code> to exclude the line joining the final point to the first point from the calculations.</p><p>If you already have a list of the distances between each point in the polygon (the &quot;polydistances&quot;), you can pass them in <code>pdist</code>, otherwise they&#39;ll be calculated afresh, using <code>polydistances(p, closed=closed)</code>.</p><p>Use the complementary <code>polyremainder()</code> function to return the other part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L889-L907">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyreflect!" href="#Luxor.polyreflect!"><code>Luxor.polyreflect!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyreflect!(pgon, pt1 = O, pt2 = O + (0, 100)</code></pre><p>Reflect (permanently) a polygon in a line (default to the y-axis) joining two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1219-L1225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyremainder" href="#Luxor.polyremainder"><code>Luxor.polyremainder</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polyremainder(p::Array{Point, 1}, portion=0.5; closed=true, pdist=[])</code></pre><p>Return the rest of a polygon, starting at a value between 0.0 (the beginning) and 1.0 (the end). 0.5 returns the last half of the polygon, 0.25 the last three quarters, 0.75 the last quarter, and so on.</p><p>Use <code>closed=false</code> to exclude the line joining the final point to the first point from the calculations.</p><p>If you already have a list of the distances between each point in the polygon (the &quot;polydistances&quot;), you can pass them in <code>pdist</code>, otherwise they&#39;ll be calculated afresh, using <code>polydistances(p, closed=closed)</code>.</p><p>Use the complementary <code>polyportion()</code> function to return the other part.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L937-L952">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyremovecollinearpoints-Tuple{Vector{Point}}" href="#Luxor.polyremovecollinearpoints-Tuple{Vector{Point}}"><code>Luxor.polyremovecollinearpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polyremovecollinearpoints(pgon::Array{Point, 1})</code></pre><p>Return copy of polygon with no collinear points.</p><p>Caution: may return an empty polygon... !</p><p>TODO This code is still experimental...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1135-L1143">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyrotate!-Tuple{Any, Any}" href="#Luxor.polyrotate!-Tuple{Any, Any}"><code>Luxor.polyrotate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polyrotate!(pgon, θ;
    center=O)</code></pre><p>Rotate (permanently) a polygon around <code>center</code> by <code>θ</code> radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1201-L1206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysample-Tuple{Vector{Point}, Integer}" href="#Luxor.polysample-Tuple{Vector{Point}, Integer}"><code>Luxor.polysample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polysample(p::Array{Point, 1}, npoints::T where T &lt;: Integer;
        closed=true)</code></pre><p>Sample the polygon <code>p</code>, returning a polygon with <code>npoints</code> to represent it. The first sampled point is:</p><pre><code class="nohighlight"> 1/`npoints` * `perimeter of p`</code></pre><p>away from the original first point of <code>p</code>.</p><p>If <code>npoints</code> is the same as <code>length(p)</code> the returned polygon is the same as the original, but the first point finishes up at the end (so <code>new=circshift(old, 1)</code>).</p><p>If <code>closed</code> is true, the entire polygon (including the edge joining the last point to the first point) is sampled.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L980-L997">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyscale!-Tuple{Any, Any, Any}" href="#Luxor.polyscale!-Tuple{Any, Any, Any}"><code>Luxor.polyscale!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polyscale!(pgon, sh, sv;
    center=O)</code></pre><p>Scale (permanently) a polygon by <code>sh</code> horizontally and <code>sv</code> vertically, relative to <code>center</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1186-L1192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polyscale!-Tuple{Any, Any}" href="#Luxor.polyscale!-Tuple{Any, Any}"><code>Luxor.polyscale!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polyscale!(pgon, s;
   center=O)</code></pre><p>Scale (permanently) a polygon by <code>s</code>, relative to <code>center</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1172-L1177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysmooth" href="#Luxor.polysmooth"><code>Luxor.polysmooth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">polysmooth(points, radius, action=:action; debug=false)</code></pre><p>Make a closed path from the <code>points</code> and round the corners by making them arcs with the given radius. Execute the action when finished.</p><p>The arcs are sometimes different sizes: if the given radius is bigger than the length of the shortest side, the arc can&#39;t be drawn at its full radius and is therefore drawn as large as possible (as large as the shortest side allows).</p><p>The <code>debug</code> option also draws the construction circles at each corner.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L438-L449">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysortbyangle" href="#Luxor.polysortbyangle"><code>Luxor.polysortbyangle</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Sort the points of a polygon into order. Points are sorted according to the angle they make with a specified point.</p><pre><code class="nohighlight">polysortbyangle(pointlist::Array, refpoint=minimum(pointlist))</code></pre><p>The <code>refpoint</code> can be chosen, but the minimum point is usually OK too:</p><pre><code class="nohighlight">polysortbyangle(parray, polycentroid(parray))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L83-L92">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysortbydistance-Tuple{Vector{Point}, Point}" href="#Luxor.polysortbydistance-Tuple{Vector{Point}, Point}"><code>Luxor.polysortbydistance</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Sort a polygon by finding the nearest point to the starting point, then the nearest point to that, and so on.</p><pre><code class="nohighlight">polysortbydistance(p, starting::Point)</code></pre><p>You can end up with convex (self-intersecting) polygons, unfortunately.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L101-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polysplit-Tuple{Vector{Point}, Point, Point}" href="#Luxor.polysplit-Tuple{Vector{Point}, Point, Point}"><code>Luxor.polysplit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polysplit(p, p1, p2)</code></pre><p>Split a polygon into two where it intersects with a line. It returns two polygons:</p><pre><code class="nohighlight">(poly1, poly2)</code></pre><p>This doesn&#39;t always work, of course. For example, a polygon the shape of the letter &quot;E&quot; might end up being divided into more than two parts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L228-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.polytriangulate-Tuple{Vector{Point}}" href="#Luxor.polytriangulate-Tuple{Vector{Point}}"><code>Luxor.polytriangulate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">polytriangulate(plist::Array{Point,1}; epsilon = -0.01)</code></pre><p>Triangulate the polygon in <code>plist</code>.</p><p>This uses the Bowyer–Watson/Delaunay algorithm to make triangles. It returns an array of triangular polygons.</p><p>TODO: This experimental polygon function is not very efficient, because it first copies the list of points (to avoid modifying the original), and sorts it, before making triangles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L1334-L1342">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.prettypoly" href="#Luxor.prettypoly"><code>Luxor.prettypoly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prettypoly(points::Array{Point, 1}, action=:none, vertexfunction = () -&gt; circle(O, 2, :stroke);
    close=false,
    reversepath=false,
    vertexlabels = (n, l) -&gt; ()
    )</code></pre><p>Draw the polygon defined by <code>points</code>, possibly closing and reversing it, using the current parameters, and then evaluate the <code>vertexfunction</code> function at every vertex of the polygon.</p><p>The default vertexfunction draws a 2 pt radius circle.</p><p>To mark each vertex of a polygon with a randomly colored filled circle:</p><pre><code class="nohighlight">p = star(O, 70, 7, 0.6, 0, vertices=true)
prettypoly(p, :fill, () -&gt;
    begin
        randomhue()
        circle(O, 10, :fill)
    end,
    close=true)</code></pre><p>The optional keyword argument <code>vertexlabels</code> lets you supply a function with two arguments that can access the current vertex number and the total number of vertices at each vertex. For example, you can label the vertices of a triangle &quot;1 of 3&quot;, &quot;2 of 3&quot;, and &quot;3 of 3&quot; using:</p><pre><code class="nohighlight">prettypoly(triangle, :stroke,
    vertexlabels = (n, l) -&gt; (text(string(n, &quot; of &quot;, l))))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L278-L307">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.prettypoly" href="#Luxor.prettypoly"><code>Luxor.prettypoly</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prettypoly(bbox::BoundingBox, :action; kwargs...)</code></pre><p>Make a decorated polygon around the BoundingBox in <code>bbox</code>. The vertices are in the order: bottom left, top left, top right, and bottom right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L240-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.preview-Tuple{}" href="#Luxor.preview-Tuple{}"><code>Luxor.preview</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">preview()</code></pre><p>If working in a notebook (eg Jupyter/IJulia), display a PNG or SVG file in the notebook.</p><p>If working in Juno, display a PNG or SVG file in the Plot pane.</p><p>Drawings of type :image should be converted to a matrix with <code>image_as_matrix()</code> before calling <code>finish()</code>.</p><p>Otherwise:</p><ul><li>on macOS, open the file in the default application, which is probably the Preview.app for PNG and PDF, and Safari for SVG</li><li>on Unix, open the file with <code>xdg-open</code></li><li>on Windows, refer to <code>COMSPEC</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L502-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randomcolor-Tuple{}" href="#Luxor.randomcolor-Tuple{}"><code>Luxor.randomcolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randomcolor()</code></pre><p>Set a random color. This may change the current alpha opacity too.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L213-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randomhue-Tuple{}" href="#Luxor.randomhue-Tuple{}"><code>Luxor.randomhue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randomhue()</code></pre><p>Set a random hue, without changing the current alpha opacity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L202-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompoint-NTuple{4, Any}" href="#Luxor.randompoint-NTuple{4, Any}"><code>Luxor.randompoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randompoint(lowx, lowy, highx, highy)</code></pre><p>Return a random point somewhere inside a rectangle defined by the four values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L236-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompoint-Tuple{Any, Any}" href="#Luxor.randompoint-Tuple{Any, Any}"><code>Luxor.randompoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randompoint(lowpt, highpt)</code></pre><p>Return a random point somewhere inside the rectangle defined by the two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L227-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompointarray-NTuple{5, Any}" href="#Luxor.randompointarray-NTuple{5, Any}"><code>Luxor.randompointarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randompointarray(lowx, lowy, highx, highy, n)</code></pre><p>Return an array of <code>n</code> random points somewhere inside the rectangle defined by the four coordinates.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L258-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.randompointarray-Tuple{Any, Any, Any}" href="#Luxor.randompointarray-Tuple{Any, Any, Any}"><code>Luxor.randompointarray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">randompointarray(lowpt, highpt, n)</code></pre><p>Return an array of <code>n</code> random points somewhere inside the rectangle defined by two points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L245-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.readpng-Tuple{Any}" href="#Luxor.readpng-Tuple{Any}"><code>Luxor.readpng</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">readpng(pathname)</code></pre><p>Read a PNG file.</p><p>This returns a image object suitable for placing on the current drawing with <code>placeimage()</code>. You can access its <code>width</code> and <code>height</code> fields:</p><pre><code class="nohighlight">image = readpng(&quot;test-image.png&quot;)
w = image.width
h = image.height</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/images.jl#L5-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.readsvg-Tuple{Any}" href="#Luxor.readsvg-Tuple{Any}"><code>Luxor.readsvg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">readsvg(str)</code></pre><p>Read an SVG image. <code>str</code> is either pathname or pure SVG code. This returns an SVG image object suitable for placing on the current drawing with <code>placeimage()</code>.</p><p>Placing an SVG file:</p><pre><code class="nohighlight">@draw begin
    mycoollogo = readsvg(&quot;mylogo.svg&quot;)
    placeimage(mycoollogo)
end</code></pre><p>Placing SVG code:</p><pre><code class="nohighlight"># from https://github.com/edent/SuperTinyIcons
julialogocode = &quot;&quot;&quot;&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;
    aria-label=&quot;Julia&quot; role=&quot;img&quot;
    viewBox=&quot;0 0 512 512&quot;&gt;
    &lt;rect width=&quot;512&quot; height=&quot;512&quot; rx=&quot;15%&quot; fill=&quot;#fff&quot;/&gt;
    &lt;circle fill=&quot;#389826&quot; cx=&quot;256&quot; cy=&quot;137&quot; r=&quot;83&quot;/&gt;
    &lt;circle fill=&quot;#cb3c33&quot; cx=&quot;145&quot; cy=&quot;329&quot; r=&quot;83&quot;/&gt;
    &lt;circle fill=&quot;#9558b2&quot; cx=&quot;367&quot; cy=&quot;329&quot; r=&quot;83&quot;/&gt;
&lt;/svg&gt;&quot;&quot;&quot;

@draw begin
    julia_logo = readsvg(julialogocode)
    placeimage(julia_logo, centered=true)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/images.jl#L114-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rect" href="#Luxor.rect"><code>Luxor.rect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rect(xmin, ymin, w, h, action)</code></pre><p>Create a rectangle with one corner at (<code>xmin</code>/<code>ymin</code>) with width <code>w</code> and height <code>h</code> and then do an action.</p><p>See <code>box()</code> for more ways to do similar things, such as supplying two opposite corners, placing by centerpoint and dimensions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rect" href="#Luxor.rect"><code>Luxor.rect</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rect(cornerpoint, w, h, action;
    vertices=false)</code></pre><p>Create a rectangle with one corner at <code>cornerpoint</code> with width <code>w</code> and height <code>h</code> and do an action.</p><p>Use <code>vertices=true</code> to return an array of the four corner points: bottom left, top left, top right, bottom right.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L18-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rescale" href="#Luxor.rescale"><code>Luxor.rescale</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rescale(x, from_min, from_max, to_min=0.0, to_max=1.0)</code></pre><p>Convert <code>x</code> from one linear scale (<code>from_min</code> to <code>from_max</code>) to another (<code>to_min</code> to <code>to_max</code>).</p><p>The scales can also be supplied in tuple form:</p><pre><code class="nohighlight">rescale(x, (from_min, from_max), (to_min, to_max))</code></pre><pre><code class="nohighlight">using Luxor
julia&gt; rescale(15, 0, 100, 0, 1)
0.15

julia&gt; rescale(15, (0, 100), (0, 1))
0.15

julia&gt; rescale(pi/20, 0, 2pi, 0, 1)
0.025

julia&gt; rescale(pi/20, (0, 2pi), (0, 1))
0.025

julia&gt; rescale(25, 0, 1, 0, 1.609344)
40.2336

julia&gt; rescale(15, (0, 100), (1000, 0))
850.0
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L29-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rline-Tuple{Any, Any}" href="#Luxor.rline-Tuple{Any, Any}"><code>Luxor.rline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rline(pt)</code></pre><p>Draw a line relative to the current position to the <code>pt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L383-L387">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rmove-Tuple{Any, Any}" href="#Luxor.rmove-Tuple{Any, Any}"><code>Luxor.rmove</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rmove(pt)</code></pre><p>Move relative to current position by the <code>pt</code>&#39;s x and y:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L356-L360">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rotate-Tuple{Any}" href="#Luxor.rotate-Tuple{Any}"><code>Luxor.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotate(a::Float64)</code></pre><p>Rotate workspace by <code>a</code> radians clockwise (from positive x-axis to positive y-axis).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L546-L550">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rotate_point_around_point-Tuple{Any, Any, Any}" href="#Luxor.rotate_point_around_point-Tuple{Any, Any, Any}"><code>Luxor.rotate_point_around_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotate_point_around_point(targetpt, pt, angle)</code></pre><p>Rotate a point around another by an angle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L631-L635">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rotationmatrix-Tuple{Any}" href="#Luxor.rotationmatrix-Tuple{Any}"><code>Luxor.rotationmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rotationmatrix(a)</code></pre><p>Return a 3x3 Julia matrix that will apply a rotation through <code>a</code> radians.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/matrix.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rule" href="#Luxor.rule"><code>Luxor.rule</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rule(pos, theta;
    boundingbox=BoundingBox(),
    vertices=false)</code></pre><p>Draw a straight line through <code>pos</code> at an angle <code>theta</code> from the x axis.</p><p>By default, the line spans the entire drawing, but you can supply a BoundingBox to change the extent of the line.</p><pre><code class="nohighlight">rule(O)       # draws an x axis
rule(O, pi/2) # draws a  y axis</code></pre><p>The function:</p><pre><code class="nohighlight">rule(O, pi/2, boundingbox=BoundingBox()/2)</code></pre><p>draws a line that spans a bounding box half the width and height of the drawing, and returns a Set of end points. If you just want the vertices and don&#39;t want to draw anything, use <code>vertices=true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L391-L413">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rulers-Tuple{}" href="#Luxor.rulers-Tuple{}"><code>Luxor.rulers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">rulers()</code></pre><p>Draw and label two rulers starting at <code>O</code>, the current 0/0, and continuing out along the current positive x and y axes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L610-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.scale-Tuple{Real, Real}" href="#Luxor.scale-Tuple{Real, Real}"><code>Luxor.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scale(x, y)</code></pre><p>Scale workspace by <code>x</code> and <code>y</code>.</p><p>Example:</p><pre><code class="nohighlight">scale(0.2, 0.3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L525-L536">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.scale-Tuple{Real}" href="#Luxor.scale-Tuple{Real}"><code>Luxor.scale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scale(f)</code></pre><p>Scale workspace by <code>f</code> in both <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L539-L543">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.scalingmatrix-Tuple{Any, Any}" href="#Luxor.scalingmatrix-Tuple{Any, Any}"><code>Luxor.scalingmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">scalingmatrix(sx, sy)</code></pre><p>Return a 3x3 Julia matrix that will apply a scaling by <code>sx</code> and <code>sy</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/matrix.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sector" href="#Luxor.sector"><code>Luxor.sector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real,
   cornerradius::Real, action::Symbol=:none)</code></pre><p>Draw an annular sector with rounded corners, centered at the current origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L345-L350">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sector" href="#Luxor.sector"><code>Luxor.sector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real,
   action::Symbol=:none)</code></pre><p>Draw an annular sector centered at the origin.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L256-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sector" href="#Luxor.sector"><code>Luxor.sector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sector(centerpoint::Point, innerradius, outerradius, startangle, endangle,
    cornerradius, action:none)</code></pre><p>Draw an annular sector with rounded corners, basically a bent sausage shape, centered at <code>centerpoint</code>.</p><p>TODO: The results aren&#39;t 100% accurate at the moment. There are small discontinuities where the curves join.</p><p>The cornerradius is reduced from the supplied value if neceesary to prevent overshoots.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L266-L277">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sector" href="#Luxor.sector"><code>Luxor.sector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">sector(centerpoint::Point, innerradius, outerradius, startangle, endangle, action:none)</code></pre><p>Draw an annular sector centered at <code>centerpoint</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L234-L239">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setantialias-Tuple{Any}" href="#Luxor.setantialias-Tuple{Any}"><code>Luxor.setantialias</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setantialias(n)</code></pre><p>Set the current antialiasing to a value between 0 and 6:</p><pre><code class="nohighlight">antialias_default  = 0, the default antialiasing for the subsystem and target device
antialias_none     = 1, use a bilevel alpha mask
antialias_gray     = 2, use single-color antialiasing (using shades of gray for black text on a white background, for example)
antialias_subpixel = 3, take advantage of the order of subpixel elements on devices such as LCD panels
antialias_fast     = 4, perform some antialiasing but prefer speed over quality
antialias_good     = 5, balance quality against performance
antialias_best     = 6, render at the highest quality, sacrificing speed if necessary</code></pre><p>This affects graphics, but not text, and it doesn&#39;t apply to all types of output file.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L117-L131">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setbezierhandles-Tuple{BezierPathSegment}" href="#Luxor.setbezierhandles-Tuple{BezierPathSegment}"><code>Luxor.setbezierhandles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setbezierhandles(bps::BezierPathSegment;
        angles  = [0.05, -0.1],
        handles = [0.3, 0.3])</code></pre><p>Return a new Bezier path segment with new locations for the Bezier control points in the Bezier path segment <code>bps</code>.</p><p><code>angles</code> are the two angles that the &quot;handles&quot; make with the line direciton.</p><p><code>handles</code> are the lengths of the &quot;handles&quot;. 0.3 is a typical value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L484-L495">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setbezierhandles-Tuple{BezierPath}" href="#Luxor.setbezierhandles-Tuple{BezierPath}"><code>Luxor.setbezierhandles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setbezierhandles(bezpath::BezierPath;
        angles=[0 .05, -0.1],
        handles=[0.3, 0.3])</code></pre><p>Return a new Bezierpath with new locations for the Bezier control points in every Bezier path segment of the BezierPath in <code>bezpath</code>.</p><p><code>angles</code> are the two angles that the &quot;handles&quot; make with the line direciton.</p><p><code>handles</code> are the lengths of the &quot;handles&quot;. 0.3 is a typical value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L507-L518">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setblend-Tuple{Cairo.CairoPattern}" href="#Luxor.setblend-Tuple{Cairo.CairoPattern}"><code>Luxor.setblend</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setblend(blend)</code></pre><p>Start using the named blend for filling graphics.</p><p>This aligns the original coordinates of the blend definition with the current axes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/blends.jl#L110-L116">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setcolor-Tuple{AbstractString}" href="#Luxor.setcolor-Tuple{AbstractString}"><code>Luxor.setcolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setcolor(&quot;gold&quot;)
setcolor(&quot;darkturquoise&quot;)</code></pre><p>Set the current color to a named color. This use the definitions in Colors.jl to convert a string to RGBA eg <code>setcolor(&quot;gold&quot;)</code> or &quot;green&quot;, &quot;darkturquoise&quot;, &quot;lavender&quot;, etc. The list is at <code>Colors.color_names</code>.</p><p>Use <code>sethue()</code> for changing colors without changing current opacity level.</p><p><code>sethue()</code> and <code>setcolor()</code> return the three or four values that were used:</p><pre><code class="nohighlight">julia&gt; setcolor(sethue(&quot;red&quot;)..., .8)

(1.0, 0.0, 0.0, 0.8)

julia&gt; sethue(setcolor(&quot;red&quot;)[1:3]...)

(1.0, 0.0, 0.0)</code></pre><p>You can also do:</p><pre><code class="nohighlight">using Colors
sethue(colorant&quot;red&quot;)</code></pre><p>See also <a href="#Luxor.setcolor-Tuple{AbstractString}"><code>setcolor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L1-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setcolor-Tuple{ColorTypes.Colorant}" href="#Luxor.setcolor-Tuple{ColorTypes.Colorant}"><code>Luxor.setcolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setcolor(r, g, b)
setcolor(r, g, b, alpha)
setcolor(color)
setcolor(col::Colors.Colorant)
setcolor(sethue(&quot;red&quot;)..., .2)</code></pre><p>Set the current color.</p><p>Examples:</p><pre><code class="nohighlight">setcolor(convert(Colors.HSV, Colors.RGB(0.5, 1, 1)))
setcolor(.2, .3, .4, .5)
setcolor(convert(Colors.HSV, Colors.RGB(0.5, 1, 1)))

for i in 1:15:360
   setcolor(convert(Colors.RGB, Colors.HSV(i, 1, 1)))
   ...
end</code></pre><p>See also <a href="#Luxor.sethue-Tuple{AbstractString}"><code>sethue</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L40-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setcolor-Tuple{NTuple{4, Number}}" href="#Luxor.setcolor-Tuple{NTuple{4, Number}}"><code>Luxor.setcolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setcolor((r, g, b, a))</code></pre><p>Set the color to the tuple&#39;s values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setcolor-Tuple{Tuple{Number, Number, Number}}" href="#Luxor.setcolor-Tuple{Tuple{Number, Number, Number}}"><code>Luxor.setcolor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setcolor((r, g, b))</code></pre><p>Set the color to the tuple&#39;s values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L165-L169">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setdash" href="#Luxor.setdash"><code>Luxor.setdash</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setdash(dashes::Vector, offset=0.0)</code></pre><p>Set the dash pattern to the values in <code>dashes</code>. The first number is the length of the ink, the second the gap, and so on.</p><p>The <code>offset</code> specifies an offset into the pattern at which the stroke begins. So an offset of 10 means that the stroke starts at <code>dashes[1] + 10</code> into the pattern.</p><p>Or use <code>setdash(&quot;dot&quot;)</code> etc.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L317-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setdash-Tuple{AbstractString}" href="#Luxor.setdash-Tuple{AbstractString}"><code>Luxor.setdash</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setdash(&quot;dot&quot;)</code></pre><p>Set the dash pattern to one of: &quot;solid&quot;, &quot;dotted&quot;, &quot;dot&quot;, &quot;dotdashed&quot;, &quot;longdashed&quot;, &quot;shortdashed&quot;, &quot;dash&quot;, &quot;dashed&quot;, &quot;dotdotdashed&quot;, &quot;dotdotdotdashed&quot;.</p><p>Use <code>setdash(dashes::Vector)</code> to specify the pattern numerically.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L304-L312">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setfont-Tuple{AbstractString, Any}" href="#Luxor.setfont-Tuple{AbstractString, Any}"><code>Luxor.setfont</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setfont(family, fontsize)</code></pre><p>Select a font and specify the size.</p><p>Example:</p><pre><code class="nohighlight">setfont(&quot;Helvetica&quot;, 24)
settext(&quot;Hello in Helvetica 24 using the Pro API&quot;, Point(0, 10))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L344-L353">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setgray-Tuple{Any}" href="#Luxor.setgray-Tuple{Any}"><code>Luxor.setgray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setgray(n)
setgrey(n)</code></pre><p>Set the color to a gray level of <code>n</code>, where <code>n</code> is between 0 and 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L193-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sethue-Tuple{AbstractString}" href="#Luxor.sethue-Tuple{AbstractString}"><code>Luxor.sethue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sethue(&quot;black&quot;)
sethue(0.3, 0.7, 0.9)
setcolor(sethue(&quot;red&quot;)..., .2)</code></pre><p>Set the color without changing opacity.</p><p><code>sethue()</code> is like <code>setcolor()</code>, but we sometimes want to change the current color without changing alpha/opacity. Using <code>sethue()</code> rather than <code>setcolor()</code> doesn&#39;t change the current alpha opacity.</p><p>See also <a href="#Luxor.setcolor-Tuple{AbstractString}"><code>setcolor</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L97-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sethue-Tuple{Any, Any, Any}" href="#Luxor.sethue-Tuple{Any, Any, Any}"><code>Luxor.sethue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sethue(0.3, 0.7, 0.9)</code></pre><p>Set the color&#39;s <code>r</code>, <code>g</code>, <code>b</code> values. Use <code>setcolor(r, g, b, a)</code> to set transparent colors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L137-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sethue-Tuple{ColorTypes.Colorant}" href="#Luxor.sethue-Tuple{ColorTypes.Colorant}"><code>Luxor.sethue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sethue(col::Colors.Colorant)</code></pre><p>Set the color without changing the current alpha/opacity:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L122-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sethue-Tuple{NTuple{4, Number}}" href="#Luxor.sethue-Tuple{NTuple{4, Number}}"><code>Luxor.sethue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sethue((r, g, b, a))</code></pre><p>Set the color to the tuple&#39;s values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L158-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.sethue-Tuple{Tuple{Number, Number, Number}}" href="#Luxor.sethue-Tuple{Tuple{Number, Number, Number}}"><code>Luxor.sethue</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sethue((r, g, b))</code></pre><p>Set the color to the tuple&#39;s values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L151-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setline-Tuple{Any}" href="#Luxor.setline-Tuple{Any}"><code>Luxor.setline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setline(n)</code></pre><p>Set the line width, in points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L254-L258">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setlinecap" href="#Luxor.setlinecap"><code>Luxor.setlinecap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setlinecap(s)</code></pre><p>Set the line ends. <code>s</code> can be &quot;butt&quot; or <code>:butt</code> (the default), &quot;square&quot; or <code>:square</code>, or &quot;round&quot; or <code>:round</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L261-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setlinejoin" href="#Luxor.setlinejoin"><code>Luxor.setlinejoin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">setlinejoin(&quot;miter&quot;)
setlinejoin(&quot;round&quot;)
setlinejoin(&quot;bevel&quot;)</code></pre><p>Set the line join style, or how to render the junction of two lines when stroking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L287-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setmatrix-Tuple{Array}" href="#Luxor.setmatrix-Tuple{Array}"><code>Luxor.setmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setmatrix(m::Array)</code></pre><p>Change the current matrix to matrix <code>m</code>. Use <code>getmatrix()</code> to get the current matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/matrix.jl#L78-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setmesh-Tuple{Cairo.CairoPattern}" href="#Luxor.setmesh-Tuple{Cairo.CairoPattern}"><code>Luxor.setmesh</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setmesh(mesh::Mesh)</code></pre><p>Select a mesh previously created with <code>mesh()</code> for filling shapes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/mesh.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setmode-Tuple{AbstractString}" href="#Luxor.setmode-Tuple{AbstractString}"><code>Luxor.setmode</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setmode(mode::AbstractString)</code></pre><p>Set the compositing/blending mode. <code>mode</code> can be one of:</p><ul><li><code>&quot;clear&quot;</code> Where the second object is drawn, the first is completely removed.</li><li><code>&quot;source&quot;</code> The second object is drawn as if nothing else were below.</li><li><code>&quot;over&quot;</code> The default mode: like two transparent slides overlapping.</li><li><code>&quot;in&quot;</code> The first object is removed completely, the second is only drawn where the first was.</li><li><code>&quot;out&quot;</code> The second object is drawn only where the first one wasn&#39;t.</li><li><code>&quot;atop&quot;</code> The first object is mostly intact, but mixes both objects in the overlapping area. The second object object is not drawn elsewhere.</li><li><code>&quot;dest&quot;</code> Discard the second object completely.</li><li><code>&quot;dest_over&quot;</code> Like &quot;over&quot; but draw second object below the first</li><li><code>&quot;dest_in&quot;</code> Keep the first object whereever the second one overlaps.</li><li><code>&quot;dest_out&quot;</code> The second object is used to reduce the visibility of the first where they overlap.</li><li><code>&quot;dest_atop&quot;</code> Like &quot;over&quot; but draw second object below the first.</li><li><code>&quot;xor&quot;</code> XOR where the objects overlap</li><li><code>&quot;add&quot;</code> Add the overlapping areas together</li><li><code>&quot;saturate&quot;</code> Increase Saturation where objects overlap</li><li><code>&quot;multiply&quot;</code> Multiply where objects overlap</li><li><code>&quot;screen&quot;</code> Input colors are complemented and multiplied, the product is complemented again. The result is at least as light as the lighter of the input colors.</li><li><code>&quot;overlay&quot;</code> Multiplies or screens colors, depending on the lightness of the destination color.</li><li><code>&quot;darken&quot;</code> Selects the darker of the color values in each component.</li><li><code>&quot;lighten&quot;</code> Selects the lighter of the color values in each component.</li></ul><p>See the <a href="https://www.cairographics.org/operators/">Cairo documentation</a> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L235-L261">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setopacity-Tuple{Any}" href="#Luxor.setopacity-Tuple{Any}"><code>Luxor.setopacity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setopacity(alpha)</code></pre><p>Set the current opacity to a value between 0 and 1. This modifies the alpha value of the current color.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/colors_styles.jl#L179-L184">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setstrokescale-Tuple{Bool}" href="#Luxor.setstrokescale-Tuple{Bool}"><code>Luxor.setstrokescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setstrokescale(state::Bool)</code></pre><p>Enable/disable stroke scaling for the current drawing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L340-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.setstrokescale-Tuple{}" href="#Luxor.setstrokescale-Tuple{}"><code>Luxor.setstrokescale</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">setstrokescale()</code></pre><p>Return the current stroke scaling setting.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L332-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.settext-Tuple{AbstractString, Point}" href="#Luxor.settext-Tuple{AbstractString, Point}"><code>Luxor.settext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">settext(text, pos;
    halign = &quot;left&quot;,
    valign = &quot;bottom&quot;,
    angle  = 0, # degrees!
    markup = false)

settext(text;
    kwargs)</code></pre><p>Draw the <code>text</code> at <code>pos</code> (if omitted defaults to <code>0/0</code>). If no font is specified, on macOS the default font is Times Roman.</p><p>To align the text, use <code>halign</code>, one of &quot;left&quot;, &quot;center&quot;, or &quot;right&quot;, and <code>valign</code>, one of &quot;top&quot;, &quot;center&quot;, or &quot;bottom&quot;.</p><p><code>angle</code> is the rotation - in counterclockwise degrees, rather than Luxor&#39;s default clockwise (+x-axis to +y-axis) radians.</p><p>If <code>markup</code> is <code>true</code>, then the string can contain some HTML-style markup. Supported tags include:</p><pre><code class="nohighlight">&lt;b&gt;, &lt;i&gt;, &lt;s&gt;, &lt;sub&gt;, &lt;sup&gt;, &lt;small&gt;, &lt;big&gt;, &lt;u&gt;, &lt;tt&gt;, and &lt;span&gt;</code></pre><p>The <code>&lt;span&gt;</code> tag can contains things like this:</p><pre><code class="nohighlight">&lt;span font=&#39;26&#39; background=&#39;green&#39; foreground=&#39;red&#39;&gt;unreadable text&lt;/span&gt;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L361-L388">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.shiftbezierhandles-Tuple{BezierPathSegment}" href="#Luxor.shiftbezierhandles-Tuple{BezierPathSegment}"><code>Luxor.shiftbezierhandles</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shiftbezierhandles(bps::BezierPathSegment;
    angles=[0.1, -0.1], handles=[1.1, 1.1])</code></pre><p>Return a new BezierPathSegment that modifies the Bezier path in <code>bps</code> by moving the control handles. The values in <code>angles</code> increase the angle of the handles; the values in <code>handles</code> modifies the lengths: 1 preserves the length, 0.5 halves the length of the  handles, 2 doubles them.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L529-L537">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.simplify" href="#Luxor.simplify"><code>Luxor.simplify</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Simplify a polygon:</p><pre><code class="nohighlight">simplify(pointlist::Array, detail=0.1)</code></pre><p><code>detail</code> is the maximum approximation error of simplified polygon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/polygons.jl#L160-L166">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.slope-Tuple{Any, Any}" href="#Luxor.slope-Tuple{Any, Any}"><code>Luxor.slope</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">slope(pointA::Point, pointB::Point)</code></pre><p>Find angle of a line starting at <code>pointA</code> and ending at <code>pointB</code>.</p><p>Return a value between 0 and 2pi. Value will be relative to the current axes.</p><pre><code class="nohighlight">slope(O, Point(0, 100)) |&gt; rad2deg # y is positive down the page
90.0

slope(Point(0, 100), O) |&gt; rad2deg
270.0</code></pre><p>The slope isn&#39;t the same as the gradient. A vertical line going up has a slope of 3π/2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L331-L348">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.snapshot-Tuple{}" href="#Luxor.snapshot-Tuple{}"><code>Luxor.snapshot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">snapshot(;
    fname = :png,
    cb = missing,
    scalefactor = 1.0)

snapshot(fname, cb, scalefactor)
-&gt; finished snapshot drawing, for display</code></pre><p>Take a snapshot and save to &#39;fname&#39; name and suffix. This requires that the current drawing is a recording surface. You can continue drawing on the same recording surface.</p><p><strong>Arguments</strong></p><p><code>fname</code> the file name or symbol, see <a href="#Luxor.Drawing"><code>Drawing</code></a></p><p><code>cb</code> crop box::BoundingBox - what&#39;s inside is copied to snapshot</p><p><code>scalefactor</code> snapshot width/crop box width. Same for height.</p><p><strong>Examples</strong></p><pre><code class="nohighlight">snapshot()
snapshot(fname = &quot;temp.png&quot;)
snaphot(fname = :svg)
cb = BoundingBox(Point(0, 0), Point(102.4, 96))
snapshot(cb = cb)
pngdrawing = snapshot(fname = &quot;temp.png&quot;, cb = cb, scalefactor = 10)</code></pre><p>The last example would return and also write a png drawing with 1024 x 960 pixels to storage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L378-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.spiral" href="#Luxor.spiral"><code>Luxor.spiral</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">spiral(a, b, action::Symbol=:none;
                 stepby = 0.01,
                 period = 4pi,
                 vertices = false,
                 log=false)</code></pre><p>Make a spiral. The two primary parameters <code>a</code> and <code>b</code> determine the start radius, and the tightness.</p><p>For linear spirals (<code>log=false</code>), <code>b</code> values are:</p><pre><code class="nohighlight">lituus: -2

hyperbolic spiral: -1

Archimedes&#39; spiral: 1

Fermat&#39;s spiral: 2</code></pre><p>For logarithmic spirals (<code>log=true</code>):</p><pre><code class="nohighlight">golden spiral: b = ln(phi)/ (pi/2) (about 0.30)</code></pre><p>Values of <code>b</code> around 0.1 produce tighter, staircase-like spirals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L607-L632">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.splittext-Tuple{Any}" href="#Luxor.splittext-Tuple{Any}"><code>Luxor.splittext</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">splittext(s)</code></pre><p>Split the text in string <code>s</code> into an array, but keep all the separators attached to the preceding word.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L494-L499">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.squircle" href="#Luxor.squircle"><code>Luxor.squircle</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">squircle(center::Point, hradius, vradius, action=:none;
    rt = 0.5, stepby = pi/40, vertices=false)</code></pre><p>Make a squircle or superellipse (basically a rectangle with rounded corners). Specify the center position, horizontal radius (distance from center to a side), and vertical radius (distance from center to top or bottom):</p><p>The root (<code>rt</code>) option defaults to 0.5, and gives an intermediate shape. Values less than 0.5 make the shape more rectangular. Values above make the shape more round. The horizontal and vertical radii can be different.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/curves.jl#L108-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.star" href="#Luxor.star"><code>Luxor.star</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">star(center, radius, npoints=5, ratio=0.5, orientation=0, action=:none;
    vertices = false, reversepath=false)</code></pre><p>Draw a star centered at a position:</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L248-L253">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.star" href="#Luxor.star"><code>Luxor.star</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">star(xcenter, ycenter, radius, npoints=5, ratio=0.5, orientation=0, action=:none;
    vertices = false,
    reversepath=false)</code></pre><p>Make a star. <code>ratio</code> specifies the height of the smaller radius of the star relative to the larger.</p><p>Use <code>vertices=true</code> to return the vertices of a star instead of drawing it.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/shapes.jl#L216-L225">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.strokepath-Tuple{}" href="#Luxor.strokepath-Tuple{}"><code>Luxor.strokepath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">strokepath()</code></pre><p>Stroke the current path with the current line width, line join, line cap, dash, and stroke scaling settings. The current path is then cleared.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L156-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.strokepreserve-Tuple{}" href="#Luxor.strokepreserve-Tuple{}"><code>Luxor.strokepreserve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">strokepreserve()</code></pre><p>Stroke the current path with current line width, line join, line cap, dash, and stroke scaling settings, but then keep the path current.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L178-L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.svgstring-Tuple{}" href="#Luxor.svgstring-Tuple{}"><code>Luxor.svgstring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">svgstring()</code></pre><p>Return the current and recently completed SVG drawing as a string of SVG commands.</p><p>Returns <code>&quot;&quot;</code> if there is no SVG information available.</p><p>To display the SVG string as a graphic, try the <code>HTML()</code> function in Base.</p><pre><code class="nohighlight">...
HTML(svgstring())</code></pre><p>In a Pluto notebook, you can also display the SVG using:</p><pre><code class="nohighlight"># using PlutoUI
...
PlutoUI.Show(MIME&quot;image/svg+xml&quot;(), svgstring())</code></pre><p>(This lets you right-click to save the SVG.)</p><p><strong>Example</strong></p><p>This example manipulates the raw SVG code representing the Julia logo:</p><pre><code class="nohighlight">Drawing(500, 500, :svg)
origin()
julialogo()
finish()
s = svgstring()
eachmatch(r&quot;rgb.*?;&quot;, s) |&gt; collect
    6-element Vector{RegexMatch}:
    RegexMatch(&quot;rgb(100%,100%,100%);&quot;)
    RegexMatch(&quot;rgb(0%,0%,0%);&quot;)
    RegexMatch(&quot;rgb(79.6%,23.5%,20%);&quot;)
    RegexMatch(&quot;rgb(25.1%,38.8%,84.7%);&quot;)
    RegexMatch(&quot;rgb(58.4%,34.5%,69.8%);&quot;)
    RegexMatch(&quot;rgb(22%,59.6%,14.9%);&quot;)</code></pre><pre><code class="nohighlight">@drawsvg begin
    background(&quot;midnightblue&quot;)
    fontface(&quot;JuliaMono-Regular&quot;)
    fontsize(20)
    sethue(&quot;gold&quot;)
    text(&quot;JuliaMono: a monospaced font &quot;, halign=:center)
    text(&quot;with reasonable Unicode support&quot;, O + (0, 22), halign=:center)
end 500 150
write(&quot;txt.svg&quot;, svgstring())
# minimize SVG
run(`svgo txt.svg -o txt-min.svg`)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L1056-L1113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.text-Tuple{Any, Point}" href="#Luxor.text-Tuple{Any, Point}"><code>Luxor.text</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">text(str)
text(str, pos)
text(str, pos, angle=pi/2)
text(str, x, y)
text(str, pos, halign=:left)
text(str, valign=:baseline)
text(str, valign=:baseline, halign=:left)
text(str, pos, valign=:baseline, halign=:left)</code></pre><p>Draw the text in the string <code>str</code> at <code>x</code>/<code>y</code> or <code>pt</code>, placing the start of the string at the point. If you omit the point, it&#39;s placed at the current <code>0/0</code>.</p><p><code>angle</code> specifies the rotation of the text relative to the current x-axis.</p><p>Horizontal alignment <code>halign</code> can be <code>:left</code>, <code>:center</code>, (also <code>:centre</code>) or <code>:right</code>.  Vertical alignment <code>valign</code> can be <code>:baseline</code>, <code>:top</code>, <code>:middle</code>, or <code>:bottom</code>.</p><p>The default alignment is <code>:left</code>, <code>:baseline</code>.</p><p>This uses <code>textextents()</code> to query the dimensions of the text. This returns values of the built in to the font. You can&#39;t find</p><p>This uses Cairo&#39;s Toy text API.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L5-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textbox" href="#Luxor.textbox"><code>Luxor.textbox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">textbox(s::AbstractString, pos::Point=O;
    leading = 12,
    linefunc::Function = (linenumber, linetext, startpos, height) -&gt; (),
    alignment=:left)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L605-L610">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textbox" href="#Luxor.textbox"><code>Luxor.textbox</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">textbox(lines::Array, pos::Point=O;
    leading = 12,
    linefunc::Function = (linenumber, linetext, startpos, height) -&gt; (),
    alignment=:left)</code></pre><p>Draw the strings in the array <code>lines</code> vertically downwards. <code>leading</code> controls the spacing between each line (default 12), and <code>alignment</code> determines the horizontal alignment (default <code>:left</code>).</p><p>Optionally, before each line, execute the function <code>linefunc(linenumber, linetext, startpos, height)</code>.</p><p>Returns the position of what would have been the next line.</p><p>See also <code>textwrap()</code>, which modifies the text so that the lines fit into a specified width.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L568-L585">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textcurve" href="#Luxor.textcurve"><code>Luxor.textcurve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">textcurve(the_text, start_angle, start_radius, x_pos = 0, y_pos = 0;
      # optional keyword arguments:
      spiral_ring_step = 0,    # step out or in by this amount
      letter_spacing = 0,      # tracking/space between chars, tighter is (-), looser is (+)
      spiral_in_out_shift = 0, # + values go outwards, - values spiral inwards
      clockwise = true
      )</code></pre><p>Place a string of text on a curve. It can spiral in or out.</p><p><code>start_angle</code> is relative to +ve x-axis, arc/circle is centered on <code>(x_pos,y_pos)</code> with radius <code>start_radius</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L232-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textcurvecentered-Tuple{Any, Any, Any, Point}" href="#Luxor.textcurvecentered-Tuple{Any, Any, Any, Point}"><code>Luxor.textcurvecentered</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">textcurvecentered(the_text, the_angle, the_radius, center::Point;
      clockwise = true,
      letter_spacing = 0,
      baselineshift = 0</code></pre><p>This version of the <code>textcurve()</code> function is designed for shorter text strings that need positioning around a circle. (A cheesy effect much beloved of hipster brands and retronauts.)</p><p><code>letter_spacing</code> adjusts the tracking/space between chars, tighter is (-), looser is (+)).  <code>baselineshift</code> moves the text up or down away from the baseline.</p><p>textcurvecentred (UK spelling) is a synonym</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L293-L308">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textextents-Tuple{Any}" href="#Luxor.textextents-Tuple{Any}"><code>Luxor.textextents</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">textextents(str)</code></pre><p>Return an array of six Float64s containing the measurements of the string <code>str</code> when set using the current font settings (Toy API):</p><p>1 x_bearing</p><p>2 y_bearing</p><p>3 width</p><p>4 height</p><p>5 x_advance</p><p>6 y_advance</p><p>The x and y bearings are the displacement from the reference point to the upper-left corner of the bounding box. It is often zero or a small positive value for x displacement, but can be negative x for characters like &quot;j&quot;; it&#39;s almost always a negative value for y displacement.</p><p>The width and height then describe the size of the bounding box. The advance takes you to the suggested reference point for the next letter. Note that bounding boxes for subsequent blocks of text can overlap if the bearing is negative, or the advance is smaller than the width would suggest.</p><p>Example:</p><pre><code class="nohighlight">textextents(&quot;R&quot;)</code></pre><p>returns</p><pre><code class="nohighlight">[1.18652; -9.68335; 8.04199; 9.68335; 9.74927; 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L129-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textlines-Tuple{AbstractString, Real}" href="#Luxor.textlines-Tuple{AbstractString, Real}"><code>Luxor.textlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">textlines(s::AbstractString, width::Real;
     rightgutter=5)</code></pre><p>Split the text in <code>s</code> into lines up to <code>width</code> units wide (in the current font).</p><p>Returns an array of strings. Use <code>textwrap</code> to draw an array of strings.</p><p>TODO: A <code>rightgutter</code> optional keyword adds some padding to the right hand side of the column. This appears to be needed sometimes -— perhaps the algorithm needs improving to take account of the interaction of <code>textextents</code> and spaces?</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L521-L532">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textoutlines" href="#Luxor.textoutlines"><code>Luxor.textoutlines</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">textoutlines(s::AbstractString, pos::Point=O, action::Symbol=:none;
    halign=:left,
    valign=:baseline,
    startnewpath=true)</code></pre><p>Convert text to a graphic path and apply <code>action</code>.</p><p>By default this function discards any current path, unless you use <code>startnewpath=false</code></p><p>See also <code>textpath()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L179-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textpath-Tuple{Any}" href="#Luxor.textpath-Tuple{Any}"><code>Luxor.textpath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">textpath(t)</code></pre><p>Convert the text in string <code>t</code> and adds closed paths to the current path, for subsequent filling/stroking etc...</p><p>Typically you&#39;ll have to use <code>pathtopoly()</code> or <code>getpath()</code> or <code>getpathflat()</code> then work through the one or more path(s). Or use <code>textoutlines()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L167-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.texttrack" href="#Luxor.texttrack"><code>Luxor.texttrack</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">texttrack(txt, pos, tracking, fontsize=12;
    action=:fill,
    halign=:left,
    valign=:baseline,
    startnewpath=true)</code></pre><p>Place the text in <code>txt</code> at <code>pos</code>, left-justified, and letter space (&#39;track&#39;) the text using the value in <code>tracking</code>.</p><p>The tracking units depend on the current font size! 1 is 1/1000 em. In a 6‑point font, 1 em equals 6 points; in a 10‑point font, 1 em equals 10 points.</p><p>A value of -50 would tighten the letter spacing noticeably. A value of 50 would make the text more open.</p><p>The text drawing action applied to each character defaults to <code>textoutlines(... :fill)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L670-L689">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.textwrap-Tuple{AbstractString, Real, Point, Function}" href="#Luxor.textwrap-Tuple{AbstractString, Real, Point, Function}"><code>Luxor.textwrap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">textwrap(s::T where T&lt;:AbstractString, width::Real, pos::Point;
    rightgutter=5,
    leading=0)
textwrap(s::T where T&lt;:AbstractString, width::Real, pos::Point, linefunc::Function;
    rightgutter=5,
    leading=0)</code></pre><p>Draw the string in <code>s</code> by splitting it at whitespace characters into lines, so that each line is no longer than <code>width</code> units. The text starts at <code>pos</code> such that the first line of text is drawn entirely below a line drawn horizontally through that position. Each line is aligned on the left side, below <code>pos</code>.</p><p>See also <code>textbox()</code>.</p><p>Optionally, before each line, execute the function <code>linefunc(linenumber, linetext, startpos, leading)</code>.</p><p>If you don&#39;t supply a value for <code>leading</code>, the font&#39;s built-in extents are used.</p><p>Text with no whitespace characters won&#39;t wrap. You can write a simple chunking function to split a string or array into chunks:</p><pre><code class="nohighlight">chunk(x, n) = [x[i:min(i+n-1,length(x))] for i in 1:n:length(x)]</code></pre><p>For example:</p><pre><code class="nohighlight">textwrap(the_text, 300, boxtopleft(BoundingBox()) + 20,
    (ln, lt, sp, ht) -&gt; begin
        c = count(t -&gt; occursin(r&quot;[[:punct:]]&quot;, t), split(lt, &quot;&quot;))
        @layer begin
            fontface(&quot;Menlo&quot;)
            sethue(&quot;darkred&quot;)
            text(string(&quot;[&quot;, c, &quot;]&quot;), sp + (310, 0))
        end
    end)</code></pre><p>puts a count of the number of punctuation characters in each line at the end of the line.</p><p>Returns the position of what would have been the next line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/text.jl#L613-L657">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.tickline-Tuple{Any, Any}" href="#Luxor.tickline-Tuple{Any, Any}"><code>Luxor.tickline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tickline(startpos, finishpos;
    startnumber         = 0,
    finishnumber        = 1,
    major               = 1,
    minor               = 0,
    major_tick_function = nothing,
    minor_tick_function = nothing,
    rounding            = 2,
    axis                = true, # draw the line?
    log                 = false,
    vertices            = false # just return the points
    )</code></pre><p>Draw a line with ticks. <code>major</code> is the number of ticks required between the start and finish point. So <code>1</code> divides the line in half. <code>minor</code> is the number of ticks between each major tick.</p><p><strong>Examples</strong></p><pre><code class="nohighlight">tickline(Point(0, 0), Point(100, 0))
tickline(Point(0, 0), Point(100, 0), major = 4)
majorticks, minorticks = tickline(Point(0, 0), Point(100, 0), axis=false)</code></pre><p><strong>Custom ticks</strong></p><p>Supply functions to make custom ticks. Custom tick functions should have arguments as follows:</p><pre><code class="nohighlight">function mtick(n, pos;
        startnumber         = 0,
        finishnumber        = 1,
        nticks = 1)
        ...</code></pre><p>and</p><pre><code class="nohighlight">function mntick(n, pos;
        startnumber        = 0,
        finishnumber       = 1,
        nticks             = 1,
        majorticklocations = [])
        ...</code></pre><p>For example:</p><pre><code class="nohighlight">tickline(O - (300, 0), Point(300, 0),
    startnumber  = -10,
    finishnumber = 10,
    minor        = 0,
    major        = 4,
    axis         = false,
    major_tick_function = (n, pos;
        startnumber=30, finishnumber=40, nticks=10) -&gt; begin
        @layer begin
            translate(pos)
            ticklength = get_fontsize()
            line(O, O + polar(ticklength, 3π/2), :stroke)
            k = rescale(n, 0, nticks - 1, startnumber, finishnumber)
            ticklength = get_fontsize() * 1.3
            text(&quot;$(round(k, digits=2))&quot;,
                O + (0, ticklength),
                halign=:center,
                valign=:middle,
                angle = -getrotation())
        end
    end)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/arrows.jl#L561-L636">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.tidysvg-Tuple{Any}" href="#Luxor.tidysvg-Tuple{Any}"><code>Luxor.tidysvg</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">tidysvg(fname)</code></pre><p>Read the SVG image in <code>fname</code> and write it to a file <code>fname-tidy.svg</code> with modified glyph names.</p><p>Return the name of the modified file.</p><p>SVG images use named defs for text, which cause errors problem when used in a notebook. <a href="https://github.com/jupyter/notebook/issues/333">See</a> for example.</p><p>A kludgy workround is to rename the elements...</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L153-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.transform-Tuple{Array}" href="#Luxor.transform-Tuple{Array}"><code>Luxor.transform</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform(a::Array)</code></pre><p>Modify the current matrix by multiplying it by matrix <code>a</code>.</p><p>For example, to skew the current state by 45 degrees in x and move by 20 in y direction:</p><pre><code class="nohighlight">transform([1, 0, tand(45), 1, 0, 20])</code></pre><p>Use <code>getmatrix()</code> to get the current matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/matrix.jl#L98-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.translate-Tuple{Real, Real}" href="#Luxor.translate-Tuple{Real, Real}"><code>Luxor.translate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translate(point)
translate(x::Real, y::Real)</code></pre><p>Translate the workspace to <code>x</code> and <code>y</code> or to <code>pt</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/basics.jl#L553-L558">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.translationmatrix-Tuple{Any, Any}" href="#Luxor.translationmatrix-Tuple{Any, Any}"><code>Luxor.translationmatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">translationmatrix(x, y)</code></pre><p>Return a 3x3 Julia matrix that will apply a translation in <code>x</code> and <code>y</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/matrix.jl#L132-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.trianglecenter-Tuple{Point, Point, Point}" href="#Luxor.trianglecenter-Tuple{Point, Point, Point}"><code>Luxor.trianglecenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trianglecenter(pt1::Point, pt2::Point, pt3::Point)</code></pre><p>Return the centroid of the triangle defined by <code>pt1</code>, <code>pt2</code>, and <code>pt3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/triangles.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.trianglecircumcenter-Tuple{Point, Point, Point}" href="#Luxor.trianglecircumcenter-Tuple{Point, Point, Point}"><code>Luxor.trianglecircumcenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">trianglecircumcenter(pt1::Point, pt2::Point, pt3::Point)</code></pre><p>Return the circumcenter of the triangle defined by <code>pt1</code>, <code>pt2</code>, and <code>pt3</code>. The circumcenter is the center of a circle that passes through the vertices of the triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/triangles.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.triangleincenter-Tuple{Point, Point, Point}" href="#Luxor.triangleincenter-Tuple{Point, Point, Point}"><code>Luxor.triangleincenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">triangleincenter(pt1::Point, pt2::Point, pt3::Point)</code></pre><p>Return the incenter of the triangle defined by <code>pt1</code>, <code>pt2</code>, and <code>pt3</code>. The incenter is the center of a circle inscribed inside the triangle.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/triangles.jl#L30-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.triangleorthocenter-Tuple{Point, Point, Point}" href="#Luxor.triangleorthocenter-Tuple{Point, Point, Point}"><code>Luxor.triangleorthocenter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">triangleorthocenter(pt1::Point, pt2::Point, pt3::Point)</code></pre><p>Return the orthocenter of the triangle defined by <code>pt1</code>, <code>pt2</code>, and <code>pt3</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/triangles.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.unpremultiplyalpha-Tuple{Any}" href="#Luxor.unpremultiplyalpha-Tuple{Any}"><code>Luxor.unpremultiplyalpha</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">unpremultiplyalpha(a)</code></pre><p>Given an array of UInt32 values, divide each value by the alpha value. See alphadivide or reversing premultiplied alpha values.</p><p>Returns an array of arrays, where each array has four Float64 values.</p><p>In a premultiplied image array, a 50% transparent red pixel is stored as 0x80800000, rather than not 0x80ff0000. This function reverses the process,  dividing each RGB value by the alpha value.</p><p>The highest two digits of each incoming element is interpreted as the alpha value.</p><pre><code class="nohighlight">unpremultiplyalpha([0x80800000])
 1-element Array{Array{Float64,1},1}:
 [1.0, 0.0, 0.0, 0.5019607843137255]</code></pre><p>Notice the arithmetic errors introduced as 0x80 gets converted to 0.5019.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L802-L828">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.AnimatedGif" href="#Luxor.AnimatedGif"><code>Luxor.AnimatedGif</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Wraps the location of an animated gif so that it can be displayed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BezierPath" href="#Luxor.BezierPath"><code>Luxor.BezierPath</code></a> — <span class="docstring-category">Type</span></header><section><div><p>BezierPath is an array of BezierPathSegments. <code>segments</code> is <code>Vector{BezierPathSegment}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L40-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BezierPathSegment" href="#Luxor.BezierPathSegment"><code>Luxor.BezierPathSegment</code></a> — <span class="docstring-category">Type</span></header><section><div><p>BezierPathSegment is an array of four points:</p><p><code>p1</code>  - start point <code>cp1</code> - control point for start point <code>cp2</code> - control point for finishpoint <code>p2</code>  - finish point</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/bezierpath.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BoundingBox" href="#Luxor.BoundingBox"><code>Luxor.BoundingBox</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The BoundingBox type holds two Points, <code>corner1</code> and <code>corner2</code>.</p><pre><code class="nohighlight">BoundingBox(;centered=true)     # the bounding box of the Drawing
BoundingBox(s::AbstractString)  # the bounding box of a text string
BoundingBox(pt::Array)          # the bounding box of a polygon</code></pre><p><code>BoundingBox(;centered=true)</code> returns a BoundingBox the same size and position as the current drawing, assuming the origin (0, 0) is at the center.</p><p>The <code>centered</code> option defaults to <code>true</code>, and assumes the drawing is currently centered. If <code>false</code>, the function assumes that the origin is at the top left of the drawing. So this function doesn&#39;t really work if the current matrix has been modified (by <code>translate()</code>, <code>scale()</code>, <code>rotate()</code> etc.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L1-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BoundingBox-Tuple{AbstractString}" href="#Luxor.BoundingBox-Tuple{AbstractString}"><code>Luxor.BoundingBox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoundingBox(str::AbstractString)</code></pre><p>Return a BoundingBox that just encloses a text string, given the current font selection. Uses the Toy text API (ie <code>text()</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L60-L65">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BoundingBox-Tuple{BoxmapTile}" href="#Luxor.BoundingBox-Tuple{BoxmapTile}"><code>Luxor.BoundingBox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoundingBox(tile::BoxmapTile)</code></pre><p>Return a BoundingBox of a BoxmapTile (as created with <code>boxmap()</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Boxmaptile.jl#L168-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.BoundingBox-Tuple{Vector{Point}}" href="#Luxor.BoundingBox-Tuple{Vector{Point}}"><code>Luxor.BoundingBox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">BoundingBox(pointlist::Array)</code></pre><p>Return the BoundingBox of a polygon (array of points).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/BoundingBox.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Drawing" href="#Luxor.Drawing"><code>Luxor.Drawing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Create a new drawing, and optionally specify file type (PNG, PDF, SVG, EPS), file-based or in-memory, and dimensions.</p><pre><code class="nohighlight">Drawing(width=600, height=600, file=&quot;luxor-drawing.png&quot;)</code></pre><p><strong>Extended help</strong></p><pre><code class="nohighlight">Drawing()</code></pre><p>creates a drawing, defaulting to PNG format, default filename &quot;luxor-drawing.png&quot;, default size 800 pixels square.</p><p>You can specify dimensions, and assume the default output filename:</p><pre><code class="nohighlight">Drawing(400, 300)</code></pre><p>creates a drawing 400 pixels wide by 300 pixels high, defaulting to PNG format, default filename &quot;luxor-drawing.png&quot;.</p><pre><code class="nohighlight">Drawing(400, 300, &quot;my-drawing.pdf&quot;)</code></pre><p>creates a PDF drawing in the file &quot;my-drawing.pdf&quot;, 400 by 300 pixels.</p><pre><code class="nohighlight">Drawing(1200, 800, &quot;my-drawing.svg&quot;)</code></pre><p>creates an SVG drawing in the file &quot;my-drawing.svg&quot;, 1200 by 800 pixels.</p><pre><code class="nohighlight">Drawing(width, height, surfacetype | filename)</code></pre><p>creates a new drawing of the given surface type (e.g. :svg, :png), storing the picture only in memory if no filename is provided.</p><pre><code class="nohighlight">Drawing(1200, 1200/Base.Mathconstants.golden, &quot;my-drawing.eps&quot;)</code></pre><p>creates an EPS drawing in the file &quot;my-drawing.eps&quot;, 1200 wide by 741.8 pixels (= 1200 ÷ ϕ) high. Only for PNG files must the dimensions be integers.</p><pre><code class="nohighlight">Drawing(&quot;A4&quot;, &quot;my-drawing.pdf&quot;)</code></pre><p>creates a drawing in ISO A4 size (595 wide by 842 high) in the file &quot;my-drawing.pdf&quot;. Other sizes available are: &quot;A0&quot;, &quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;A4&quot;, &quot;A5&quot;, &quot;A6&quot;, &quot;Letter&quot;, &quot;Legal&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;. Append &quot;landscape&quot; to get the landscape version.</p><pre><code class="nohighlight">Drawing(&quot;A4landscape&quot;)</code></pre><p>creates the drawing A4 landscape size.</p><p>PDF files default to a white background, but PNG defaults to transparent, unless you specify one using <code>background()</code>.</p><pre><code class="nohighlight">Drawing(width, height, :image)</code></pre><p>creates the drawing in an image buffer in memory. You can obtain the data as a matrix with <code>image_as_matrix()</code>.</p><pre><code class="nohighlight">Drawing(width, height, :rec)</code></pre><p>creates the drawing in a recording surface in memory. <code>snapshot(fname, ...)</code> to any file format and bounding box, or render as pixels with <code>image_as_matrix()</code>.</p><pre><code class="nohighlight">Drawing(width, height, strokescale=true)</code></pre><p>creates the drawing and enables stroke scaling (strokes will be scaled according to the current transformation). (Stroke scaling is disabled by default.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L243-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.GridHex" href="#Luxor.GridHex"><code>Luxor.GridHex</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GridHex(startpoint, radius, width=1200.0, height=1200.0)</code></pre><p>Define a hexagonal grid, to start at <code>startpoint</code> and proceed along the x-axis and then along the y-axis, <code>radius</code> is the radius of a circle that encloses each hexagon. The distance in <code>x</code> between the centers of successive hexagons is:</p><p><span>$\frac{\sqrt{(3)} radius}{2}$</span></p><p>To get the next point from the grid, use <code>nextgridpoint(g::Grid)</code>.</p><p>When you run out of grid points, you&#39;ll wrap round and start again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/tiles-grids.jl#L162-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.GridRect" href="#Luxor.GridRect"><code>Luxor.GridRect</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GridRect(startpoint, xspacing, yspacing, width, height)</code></pre><p>Define a rectangular grid, to start at <code>startpoint</code> and proceed along the x-axis in steps of <code>xspacing</code>, then along the y-axis in steps of <code>yspacing</code>.</p><pre><code class="nohighlight">GridRect(startpoint, xspacing=100.0, yspacing=100.0, width=1200.0, height=1200.0)</code></pre><p>For a column, set the <code>xspacing</code> to 0:</p><pre><code class="nohighlight">grid = GridRect(O, 0, 40)</code></pre><p>To get points from the grid, use <code>nextgridpoint(g::Grid)</code>.</p><pre><code class="nohighlight">julia&gt; grid = GridRect(O, 0, 40);
julia&gt; nextgridpoint(grid)
Luxor.Point(0.0, 0.0)

julia&gt; nextgridpoint(grid)
Luxor.Point(0.0, 40.0)</code></pre><p>When you run out of grid points, you&#39;ll wrap round and start again.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/tiles-grids.jl#L120-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Movie" href="#Luxor.Movie"><code>Luxor.Movie</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The <code>Movie</code> and <code>Scene</code> types and the <code>animate()</code> function are designed to help you create the frames that can be used to make an animated GIF or movie.</p><p>1 Provide width, height, title, and optionally a frame range to the Movie constructor:</p><pre><code class="nohighlight">demo = Movie(400, 400, &quot;test&quot;, 1:500)</code></pre><p>2 Define one or more scenes and scene-drawing functions.</p><p>3 Run the <code>animate()</code> function, calling those scenes.</p><p>Example</p><pre><code class="nohighlight">bang = Movie(400, 100, &quot;bang&quot;)

backdrop(scene, framenumber) =  background(&quot;black&quot;)

function frame1(scene, framenumber)
    background(&quot;white&quot;)
    sethue(&quot;black&quot;)
    eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)
    circle(O, 40 * eased_n, :fill)
end

animate(bang, [
    Scene(bang, backdrop, 0:200),
    Scene(bang, frame1, 0:200, easingfunction=easeinsine)],
    creategif=true,
    pathname=&quot;/tmp/animationtest.gif&quot;)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L1-L34">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Movie-Tuple{Any, Any, AbstractString}" href="#Luxor.Movie-Tuple{Any, Any, AbstractString}"><code>Luxor.Movie</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Movie(width, height, movietitle)</code></pre><p>Define a movie, specifying the width, height, and a title. The title will be used to make the output file name. The range defaults to <code>1:250</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L42-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Partition" href="#Luxor.Partition"><code>Luxor.Partition</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">p = Partition(areawidth, areaheight, tilewidth, tileheight)</code></pre><p>A Partition is an iterator that, for each iteration, returns a tuple of:</p><ul><li>the <code>x</code>/<code>y</code> point of the center of each tile in a set of tiles that divide up a</li></ul><p>rectangular space such as a page into rows and columns (relative to current 0/0)</p><ul><li>the number of the tile</li></ul><p><code>areawidth</code> and <code>areaheight</code> are the dimensions of the area to be tiled, <code>tilewidth</code>/<code>tileheight</code> are the dimensions of the tiles.</p><p>Tiler and Partition are similar:</p><ul><li><p>Partition lets you specify the width and height of a cell</p></li><li><p>Tiler lets you specify how many rows and columns of cells you want, and a margin</p></li></ul><pre><code class="nohighlight">tiles = Partition(1200, 1200, 30, 30)
for (pos, n) in tiles
    # the point pos is the center of the tile
end</code></pre><p>You can access the calculated tile width and height like this:</p><pre><code class="nohighlight">tiles = Partition(1200, 1200, 30, 30)
for (pos, n) in tiles
    ellipse(pos.x, pos.y, tiles.tilewidth, tiles.tileheight, :fill)
end</code></pre><p>It&#39;s sometimes useful to know which row and column you&#39;re currently on:</p><pre><code class="nohighlight">tiles.currentrow
tiles.currentcol</code></pre><p>should have that information for you.</p><p>Unless the tilewidth and tileheight are exact multiples of the area width and height, you&#39;ll see a border at the right and bottom where the tiles won&#39;t fit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/tiles-grids.jl#L245-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Point" href="#Luxor.Point"><code>Luxor.Point</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Point type holds two coordinates. It&#39;s immutable, you can&#39;t change the values of the x and y values directly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L4-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Scene" href="#Luxor.Scene"><code>Luxor.Scene</code></a> — <span class="docstring-category">Type</span></header><section><div><p>The Scene type defines a function to be used to render a range of frames in a movie.</p><ul><li>the <code>movie</code> created by Movie()</li><li>the <code>framefunction</code> is a function taking two arguments: the scene and the framenumber.</li><li>the <code>framerange</code> determines which frames are processed by the function. Defaults to the entire movie.</li><li>the optional <code>easingfunction</code> can be accessed by the framefunction to vary the transition speed</li><li>the optional <code>opts</code> which is a single argument of an abstract type which can be accessed within the framefunction</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L55-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Scene-Tuple{Movie, Function}" href="#Luxor.Scene-Tuple{Movie, Function}"><code>Luxor.Scene</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Scene(movie, function, range;
    easingfunction=easinoutquad,
    optarg=nothing)</code></pre><p>Use the Scene() constructor function to create a scene. Supply a movie, a function to generate the scene, and a range of frames. Optionally you can supply an easing function, and other information, in <code>optarg</code>, which can be accessed as <code>scene.opts</code>.</p><p><strong>Example</strong></p><pre><code class="nohighlight">function initial(scene, framenumber)
    balls = scene.opts
    ...
end

animate(poolmovie, [
    Scene(poolmovie, initial, optarg=balls,   1:20),
    ...
    ])</code></pre><p>To use an easing function inside the frame-generating function, you can create a normalized value with, for example:</p><pre><code class="nohighlight">eased_n = scene.easingfunction(framenumber, 0, 1, scene.framerange.stop)</code></pre><p>Or, if the scene doesn&#39;t start at frame 1, calculate normalized easing function like this:</p><pre><code class="nohighlight">eased_n = scene.easingfunction(framenumber - scene.framerange.start,
    0, 1, scene.framerange.stop - scene.framerange.start)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/animate.jl#L72-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Table" href="#Luxor.Table"><code>Luxor.Table</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">t = Table(nrows, ncols)
t = Table(nrows, ncols, colwidth, rowheight)
t = Table(rowheights, columnwidths)</code></pre><p>Tables are centered at <code>O</code>, but you can supply a point after the specifications.</p><pre><code class="nohighlight">t = Table(nrows, ncols, centerpoint)
t = Table(nrows, ncols, colwidth, rowheight, centerpoint)
t = Table(rowheights, columnwidths, centerpoint)</code></pre><p>Examples</p><p>Simple tables</p><pre><code class="nohighlight">t = Table(4, 3) # 4 rows and 3 cols, default is 100w, 50 h
t = Table(4, 3, 80, 30)   # 4 rows of 30pts high, 3 cols of 80pts wide
t = Table(4, 3, (80, 30)) # same
t = Table((4, 3), (80, 30)) # same</code></pre><p>Specify row heights and column widths instead of quantities:</p><pre><code class="nohighlight">t = Table([60, 40, 100], 50) # 3 different height rows, 1 column 50 wide
t = Table([60, 40, 100], [100, 60, 40]) # 3 rows, 3 columns
t = Table(fill(30, (10)), [50, 50, 50]) # 10 rows 30 high, 3 columns 10 wide
t = Table(50, [60, 60, 60]) # just 1 row (50 high), 3 columns 60 wide
t = Table([50], [50]) # just 1 row, 1 column, both 50 units wide
t = Table(50, 50, 10, 5) # 50 rows, 50 columns, 10 units wide, 5 units high
t = Table([6, 11, 16, 21, 26, 31, 36, 41, 46], [6, 11, 16, 21, 26, 31, 36, 41, 46])
t = Table(15:5:55, vcat(5:2:15, 15:-2:5))
 #  table has 108 cells, with:
 #  row heights: 15 20 25 30 35 40 45 50 55
 #  col widths:  5 7 9 11 13 15 15 13 11 9 7 5
t = Table(vcat(5:10:60, 60:-10:5), vcat(5:10:60, 60:-10:5))
t = Table(vcat(5:10:60, 60:-10:5), 50) # 1 column 50 units wide
t = Table(vcat(5:10:60, 60:-10:5), 1:5:50)</code></pre><p>A Table is an iterator that, for each iteration, returns a tuple of:</p><ul><li><p>the <code>x</code>/<code>y</code> point of the center of cells arranged in rows and columns (relative to current 0/0)</p></li><li><p>the number of the cell (left to right, then top to bottom)</p></li></ul><p><code>nrows</code>/<code>ncols</code> are the number of rows and columns required.</p><p>It&#39;s sometimes useful to know which row and column you&#39;re currently on while iterating:</p><pre><code class="nohighlight">t.currentrow
t.currentcol</code></pre><p>and row heights and column widths are available in:</p><pre><code class="nohighlight">t.rowheights
t.colwidths</code></pre><p><code>box(t::Table, r, c)</code> can be used to fill table cells:</p><pre><code class="nohighlight">@svg begin
    for (pt, n) in (t = Table(8, 3, 30, 15))
        randomhue()
        box(t, t.currentrow, t.currentcol, :fill)
        sethue(&quot;white&quot;)
        text(string(n), pt)
    end
end</code></pre><p>or without iteration, using cellnumber:</p><pre><code class="nohighlight">@svg begin
    t = Table(8, 3, 30, 15)
    for n in eachindex(t)
        randomhue()
        box(t, n, :fill)
        sethue(&quot;white&quot;)
        text(string(n), t[n])
    end
end</code></pre><p>To use a Table to make grid points:</p><pre><code class="nohighlight">julia&gt; first.(collect(Table(10, 6)))
60-element Array{Luxor.Point,1}:
 Luxor.Point(-10.0, -18.0)
 Luxor.Point(-6.0, -18.0)
 Luxor.Point(-2.0, -18.0)
 ⋮
 Luxor.Point(2.0, 18.0)
 Luxor.Point(6.0, 18.0)
 Luxor.Point(10.0, 18.0)</code></pre><p>which returns an array of points that are the center points of the cells in the table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Table.jl#L13-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Tiler" href="#Luxor.Tiler"><code>Luxor.Tiler</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">tiles = Tiler(areawidth, areaheight, nrows, ncols, margin=20)</code></pre><p>A Tiler is an iterator that, for each iteration, returns a tuple of:</p><ul><li><p>the <code>x</code>/<code>y</code> point of the center of each tile in a set of tiles that divide up a rectangular space such as a page into rows and columns (relative to current 0/0)</p></li><li><p>the number of the tile</p></li></ul><p><code>areawidth</code> and <code>areaheight</code> are the dimensions of the area to be tiled, <code>nrows</code>/<code>ncols</code> are the number of rows and columns required, and <code>margin</code> is applied to all four edges of the area before the function calculates the tile sizes required.</p><p>Tiler and Partition are similar:</p><ul><li><p>Partition lets you specify the width and height of a cell</p></li><li><p>Tiler lets you specify how many rows and columns of cells you want, and a margin:</p></li></ul><pre><code class="nohighlight">tiles = Tiler(1000, 800, 4, 5, margin=20)
for (pos, n) in tiles
    # the point pos is the center of the tile
end</code></pre><p>You can access the calculated tile width and height like this:</p><pre><code class="nohighlight">tiles = Tiler(1000, 800, 4, 5, margin=20)
for (pos, n) in tiles
    ellipse(pos.x, pos.y, tiles.tilewidth, tiles.tileheight, :fill)
end</code></pre><p>It&#39;s sometimes useful to know which row and column you&#39;re currently on. <code>tiles.currentrow</code> and <code>tiles.currentcol</code> should have that information for you.</p><p>To use a Tiler to make grid points:</p><pre><code class="nohighlight">first.(collect(Tiler(800, 800, 4, 4))</code></pre><p>which returns an array of points that are the center points of the grid.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/tiles-grids.jl#L1-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.Turtle" href="#Luxor.Turtle"><code>Luxor.Turtle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Turtle()
Turtle(O)
Turtle(0, 0)
Turtle(O, pendown=true, orientation=0, pencolor=(1.0, 0.25, 0.25))</code></pre><p>Create a Turtle. You can command a turtle to move and draw &quot;turtle graphics&quot;.</p><p>The commands (unusually for Julia) start with a capital letter, and angles are specified in degrees.</p><p>Basic commands are <code>Forward()</code>, <code>Turn()</code>, <code>Pendown()</code>, <code>Penup()</code>, <code>Pencolor()</code>, <code>Penwidth()</code>, <code>Circle()</code>, <code>Orientation()</code>, <code>Rectangle()</code>, and <code>Reposition()</code>.</p><p>Others include <code>Push()</code>, <code>Pop()</code>, <code>Message()</code>, <code>HueShift()</code>, <code>Randomize_saturation()</code>, <code>Reposition()</code>, and <code>Pen_opacity_random()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/Turtle.jl#L20-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.O" href="#Luxor.O"><code>Luxor.O</code></a> — <span class="docstring-category">Constant</span></header><section><div><p>O is a shortcut for the current origin, <code>0/0</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/point.jl#L13-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.paper_sizes" href="#Luxor.paper_sizes"><code>Luxor.paper_sizes</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">paper_sizes</code></pre><p>The <code>paper_sizes</code> Dictionary holds a few paper sizes, width is first, so default is Portrait:</p><pre><code class="nohighlight">&quot;A0&quot;      =&gt; (2384, 3370),
&quot;A1&quot;      =&gt; (1684, 2384),
&quot;A2&quot;      =&gt; (1191, 1684),
&quot;A3&quot;      =&gt; (842, 1191),
&quot;A4&quot;      =&gt; (595, 842),
&quot;A5&quot;      =&gt; (420, 595),
&quot;A6&quot;      =&gt; (298, 420),
&quot;A&quot;       =&gt; (612, 792),
&quot;Letter&quot;  =&gt; (612, 792),
&quot;Legal&quot;   =&gt; (612, 1008),
&quot;Ledger&quot;  =&gt; (792, 1224),
&quot;B&quot;       =&gt; (612, 1008),
&quot;C&quot;       =&gt; (1584, 1224),
&quot;D&quot;       =&gt; (2448, 1584),
&quot;E&quot;       =&gt; (3168, 2448))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/3a2b75efe248b8c5dff2f959115e862824dd950f/src/drawings.jl#L203-L225">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../functionindex/">« Alphabetical function list</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.3 on <span class="colophon-date" title="Monday 19 July 2021 08:13">Monday 19 July 2021</span>. Using Julia version 1.6.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

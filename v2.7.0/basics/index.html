<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Basic concepts · Luxor</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="Luxor logo"/></a><div class="docs-package-name"><span class="docs-autofit">Luxor</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction to Luxor</a></li><li><a class="tocitem" href="../examples/">A few examples</a></li><li><a class="tocitem" href="../tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Basic concepts</a><ul class="internal"><li><a class="tocitem" href="#Points-and-coordinates"><span>Points and coordinates</span></a></li><li><a class="tocitem" href="#Drawings"><span>Drawings</span></a></li><li><a class="tocitem" href="#Quick-drawings-with-macros"><span>Quick drawings with macros</span></a></li><li><a class="tocitem" href="#The-drawing-surface"><span>The drawing surface</span></a></li><li><a class="tocitem" href="#Save-and-restore"><span>Save and restore</span></a></li><li><a class="tocitem" href="#Return-the-current-drawing"><span>Return the current drawing</span></a></li><li><a class="tocitem" href="#Drawing-as-image-matrix"><span>Drawing as image matrix</span></a></li></ul></li><li><a class="tocitem" href="../simplegraphics/">Simple shapes</a></li><li><a class="tocitem" href="../moregraphics/">More graphics</a></li><li><a class="tocitem" href="../geometrytools/">Geometry tools</a></li><li><a class="tocitem" href="../tables-grids/">Tables and grids</a></li><li><a class="tocitem" href="../colors-styles/">Colors and styles</a></li><li><a class="tocitem" href="../polygons/">Polygons and paths</a></li><li><a class="tocitem" href="../text/">Text</a></li><li><a class="tocitem" href="../transforms/">Transforms and matrices</a></li><li><a class="tocitem" href="../clipping/">Clipping</a></li><li><a class="tocitem" href="../images/">Images</a></li><li><a class="tocitem" href="../turtle/">Turtle graphics</a></li><li><a class="tocitem" href="../animation/">Animation</a></li><li><a class="tocitem" href="../livegraphics/">Live graphics</a></li><li><a class="tocitem" href="../moreexamples/">More examples</a></li><li><a class="tocitem" href="../functionindex/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Basic concepts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Basic concepts</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaGraphics/Luxor.jl/blob/master/docs/src/basics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-basics"><a class="docs-heading-anchor" href="#The-basics">The basics</a><a id="The-basics-1"></a><a class="docs-heading-anchor-permalink" href="#The-basics" title="Permalink"></a></h1><p>The underlying drawing model is that you make shapes, and add points to paths, and these are filled and/or stroked, using the current <em>graphics state</em>, which specifies colors, line thicknesses, and opacity. You can modify the current graphics state by transforming/rotating/scaling it, and setting style parameters, and so on. Subsequent graphics use the new state, but the graphics you&#39;ve already drawn are unchanged.</p><p>You can specify points on the drawing surface using <code>Point(x, y)</code>. The default origin is at the top left of the drawing area, but you can reposition it at any time. Many of the drawing functions have an <em>action</em> argument. This can be <code>:none</code>, <code>:fill</code>, <code>:stroke</code>, <code>:fillstroke</code>, <code>:fillpreserve</code>, <code>:strokepreserve</code>, <code>:clip</code>, or <code>:path</code>. The default is <code>:none</code>.</p><p>Y coordinates increase downwards, so <code>Point(0, 100)</code> is below <code>Point(0, 0)</code>. This is the preferred coordinate system for computer graphics software, but mathematicians and scientists may well be used to the y-axis increasing upwards...</p><p>The main types you&#39;ll encounter in Luxor are:</p><table><tr><th style="text-align: right">Name of type</th><th style="text-align: right">Purpose</th></tr><tr><td style="text-align: right">Drawing</td><td style="text-align: right">holds the current drawing</td></tr><tr><td style="text-align: right">Point</td><td style="text-align: right">specifies 2D points</td></tr><tr><td style="text-align: right">BoundingBox</td><td style="text-align: right">defines a bounding box</td></tr><tr><td style="text-align: right">Table</td><td style="text-align: right">defines a table with different column widths and row  heights</td></tr><tr><td style="text-align: right">Partition</td><td style="text-align: right">defines a table defined by cell width and height</td></tr><tr><td style="text-align: right">Tiler</td><td style="text-align: right">defines a rectangular grid of tiles</td></tr><tr><td style="text-align: right">BezierPathSegment</td><td style="text-align: right">a Bezier path segment defined by 4 points</td></tr><tr><td style="text-align: right">BezierPath</td><td style="text-align: right">contains a series of BezierPathSegments</td></tr><tr><td style="text-align: right">GridRect</td><td style="text-align: right">defines a rectangular grid</td></tr><tr><td style="text-align: right">GridHex</td><td style="text-align: right">defines a hexagonal grid</td></tr><tr><td style="text-align: right">Scene</td><td style="text-align: right">used to define a scene for an animation</td></tr><tr><td style="text-align: right">Turtle</td><td style="text-align: right">represents a turtle for drawing turtle graphics</td></tr></table><h2 id="Points-and-coordinates"><a class="docs-heading-anchor" href="#Points-and-coordinates">Points and coordinates</a><a id="Points-and-coordinates-1"></a><a class="docs-heading-anchor-permalink" href="#Points-and-coordinates" title="Permalink"></a></h2><p>The Point type holds two coordinates, <code>x</code> and <code>y</code>. For example:</p><pre><code class="language-julia">julia&gt; P = Point(12.0, 13.0)
Luxor.Point(12.0, 13.0)

julia&gt; P.x
12.0

julia&gt; P.y
13.0</code></pre><p>Points are immutable, so you can&#39;t change P&#39;s x or y values directly. But it&#39;s easy to make new points based on existing ones.</p><p>Points can be added together:</p><pre><code class="language-julia">julia&gt; Q = Point(4, 5)
Luxor.Point(4.0, 5.0)

julia&gt; P + Q
Luxor.Point(16.0, 18.0)</code></pre><p>You can add or multiply Points and scalars:</p><pre><code class="language-julia">julia&gt; 10P
Luxor.Point(120.0, 130.0)

julia&gt; P + 100
Luxor.Point(112.0, 113.0)</code></pre><p>You can also make new points by mixing Points and tuples:</p><pre><code class="language-julia">julia&gt; P + (10, 0)
Luxor.Point(22.0, 13.0)

julia&gt; Q * (0.5, 0.5)
Luxor.Point(2.0, 2.5)</code></pre><p>You can also create points from tuples:</p><pre><code class="language-none">julia&gt; Point((1.0, 14))
Point(1.0, 14.0)

julia&gt; plist = (1.0, 2.0), (-10, 10), (14.2, 15.4));

julia&gt; Point.(plist)
3-element Array{Point,1}:
 Point(1.0, 2.0)
 Point(-10.0, 10.0)
 Point(14.2, 15.4)</code></pre><p>You can use the letter <strong>O</strong> as a shortcut to refer to the current Origin, <code>Point(0, 0)</code>.</p><pre><code class="language-julia">rulers()
box.([O + (i, 0) for i in range(0, stop=200, length=5)], 20, 20, :stroke)</code></pre><p><img src="../assets/figures/point-ex.png" alt="point example"/></p><p>Angles are usually supplied in radians, measured starting at the positive x-axis turning towards the positive y-axis (which usually points &#39;down&#39; the page or canvas, so &#39;clockwise&#39;). (The main exception is for turtle graphics, which conventionally let you supply angles in degrees.)</p><p>Coordinates are interpreted as PostScript points, where a point is 1/72 of an inch.</p><p>Because Julia allows you to combine numbers and variables directly, you can supply units with dimensions and have them converted to points (assuming the current scale is 1:1):</p><ul><li>inch (<code>in</code> is unavailable, being used by <code>for</code> syntax)</li><li>cm   (centimeters)</li><li>mm   (millimeters)</li></ul><p>For example:</p><pre><code class="language-none">rect(Point(20mm, 2cm), 5inch, (22/7)inch, :fill)</code></pre><h2 id="Drawings"><a class="docs-heading-anchor" href="#Drawings">Drawings</a><a id="Drawings-1"></a><a class="docs-heading-anchor-permalink" href="#Drawings" title="Permalink"></a></h2><h3 id="Drawings-and-files"><a class="docs-heading-anchor" href="#Drawings-and-files">Drawings and files</a><a id="Drawings-and-files-1"></a><a class="docs-heading-anchor-permalink" href="#Drawings-and-files" title="Permalink"></a></h3><p>To create a drawing, and optionally specify the filename, type, and dimensions, use the <code>Drawing</code> constructor function.</p><article class="docstring"><header><a class="docstring-binding" id="Luxor.Drawing" href="#Luxor.Drawing"><code>Luxor.Drawing</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Create a new drawing, and optionally specify file type (PNG, PDF, SVG, EPS), file-based or in-memory, and dimensions.</p><pre><code class="language-none">Drawing(width=600, height=600, file=&quot;luxor-drawing.png&quot;)</code></pre><p><strong>Extended help</strong></p><pre><code class="language-none">Drawing()</code></pre><p>creates a drawing, defaulting to PNG format, default filename &quot;luxor-drawing.png&quot;, default size 800 pixels square.</p><p>You can specify dimensions, and assume the default output filename:</p><pre><code class="language-none">Drawing(400, 300)</code></pre><p>creates a drawing 400 pixels wide by 300 pixels high, defaulting to PNG format, default filename &quot;luxor-drawing.png&quot;.</p><pre><code class="language-none">Drawing(400, 300, &quot;my-drawing.pdf&quot;)</code></pre><p>creates a PDF drawing in the file &quot;my-drawing.pdf&quot;, 400 by 300 pixels.</p><pre><code class="language-none">Drawing(1200, 800, &quot;my-drawing.svg&quot;)</code></pre><p>creates an SVG drawing in the file &quot;my-drawing.svg&quot;, 1200 by 800 pixels.</p><pre><code class="language-none">Drawing(width, height, surfacetype | filename)</code></pre><p>creates a new drawing of the given surface type (e.g. :svg, :png), storing the picture only in memory if no filename is provided.</p><pre><code class="language-none">Drawing(1200, 1200/Base.Mathconstants.golden, &quot;my-drawing.eps&quot;)</code></pre><p>creates an EPS drawing in the file &quot;my-drawing.eps&quot;, 1200 wide by 741.8 pixels (= 1200 ÷ ϕ) high. Only for PNG files must the dimensions be integers.</p><pre><code class="language-none">Drawing(&quot;A4&quot;, &quot;my-drawing.pdf&quot;)</code></pre><p>creates a drawing in ISO A4 size (595 wide by 842 high) in the file &quot;my-drawing.pdf&quot;. Other sizes available are: &quot;A0&quot;, &quot;A1&quot;, &quot;A2&quot;, &quot;A3&quot;, &quot;A4&quot;, &quot;A5&quot;, &quot;A6&quot;, &quot;Letter&quot;, &quot;Legal&quot;, &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;. Append &quot;landscape&quot; to get the landscape version.</p><pre><code class="language-none">Drawing(&quot;A4landscape&quot;)</code></pre><p>creates the drawing A4 landscape size.</p><p>PDF files default to a white background, but PNG defaults to transparent, unless you specify one using <code>background()</code>.</p><pre><code class="language-none">Drawing(width, height, :image)</code></pre><p>creates the drawing in an image buffer in memory. You can obtain the data as a matrix with <code>image_as_matrix()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.paper_sizes" href="#Luxor.paper_sizes"><code>Luxor.paper_sizes</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">paper_sizes</code></pre><p>The <code>paper_sizes</code> Dictionary holds a few paper sizes, width is first, so default is Portrait:</p><pre><code class="language-none">&quot;A0&quot;      =&gt; (2384, 3370),
&quot;A1&quot;      =&gt; (1684, 2384),
&quot;A2&quot;      =&gt; (1191, 1684),
&quot;A3&quot;      =&gt; (842, 1191),
&quot;A4&quot;      =&gt; (595, 842),
&quot;A5&quot;      =&gt; (420, 595),
&quot;A6&quot;      =&gt; (298, 420),
&quot;A&quot;       =&gt; (612, 792),
&quot;Letter&quot;  =&gt; (612, 792),
&quot;Legal&quot;   =&gt; (612, 1008),
&quot;Ledger&quot;  =&gt; (792, 1224),
&quot;B&quot;       =&gt; (612, 1008),
&quot;C&quot;       =&gt; (1584, 1224),
&quot;D&quot;       =&gt; (2448, 1584),
&quot;E&quot;       =&gt; (3168, 2448))</code></pre></div></section></article><p>To finish a drawing and close the file, use <code>finish()</code>, and, to launch an external application to view it, use <code>preview()</code>.</p><p>If you&#39;re using a notebook environment, such as Jupyter (IJulia) or Pluto, <code>preview()</code> tries to display PNG and SVG files in the next notebook cell.</p><p><img src="../assets/figures/jupyter.png" alt="jupyter"/></p><p>If you&#39;re using Juno or VS Code, then PNG and SVG files should appear in the Plots pane.</p><p><img src="../assets/figures/juno.png" alt="juno"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.finish" href="#Luxor.finish"><code>Luxor.finish</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">finish()</code></pre><p>Finish the drawing, and close the file. You may be able to open it in an external viewer application with <code>preview()</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.preview" href="#Luxor.preview"><code>Luxor.preview</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">preview()</code></pre><p>If working in a notebook (eg Jupyter/IJulia), display a PNG or SVG file in the notebook.</p><p>If working in Juno, display a PNG or SVG file in the Plot pane.</p><p>Drawings of type :image should be converted to a matrix with <code>image_as_matrix()</code> before calling <code>finish()</code>.</p><p>Otherwise:</p><ul><li>on macOS, open the file in the default application, which is probably the Preview.app for PNG and PDF, and Safari for SVG</li><li>on Unix, open the file with <code>xdg-open</code></li><li>on Windows, refer to <code>COMSPEC</code>.</li></ul></div></section></article><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>SVGs are text based, and can get quite big. Up to a certain size, SVGs will be previewable as easily and quickly as PNGs. But very large drawings in SVG format won&#39;t necessarily  be displayed.</p></div></div><h2 id="Quick-drawings-with-macros"><a class="docs-heading-anchor" href="#Quick-drawings-with-macros">Quick drawings with macros</a><a id="Quick-drawings-with-macros-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-drawings-with-macros" title="Permalink"></a></h2><p>The <code>@draw</code>, <code>@svg</code>, <code>@png</code>, and <code>@pdf</code> macros are designed to let you quickly create graphics without having to provide the usual boiler-plate functions. For example, the Julia code:</p><pre><code class="language-julia">@svg circle(Point(0, 0), 20, :stroke) 50 50</code></pre><p>expands to</p><pre><code class="language-julia">Drawing(50, 50, &quot;luxor-drawing-(timestamp).svg&quot;)
origin()
background(&quot;white&quot;)
sethue(&quot;black&quot;)
circle(Point(0, 0), 20, :stroke)
finish()
preview()</code></pre><p>They&#39;re short-cuts - designed to save typing. You can omit the width and height (defaulting to 600 by 600, except for <code>@imagematrix</code>), and you don&#39;t have to specify a filename (you&#39;ll get time-stamped files in the current working directory). For multiple lines, use either:</p><pre><code class="language-julia">@svg begin
    setline(10)
    sethue(&quot;purple&quot;)
    circle(Point(0, 0), 20, :fill)
end</code></pre><p>or (less nicely):</p><pre><code class="language-julia">@svg (setline(10);
      sethue(&quot;purple&quot;);
      circle(Point(0, 0), 20, :fill)
     )</code></pre><p>The <code>@draw</code> macro creates an in-memory drawing. You should see it displayed if you&#39;re working in a capable environment (Juno, VSCode, Jupyter, Pluto).</p><article class="docstring"><header><a class="docstring-binding" id="Luxor.@svg" href="#Luxor.@svg"><code>Luxor.@svg</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@svg drawing-instructions [width] [height] [filename]</code></pre><p>Create and preview an SVG drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as <code>filename</code> if supplied, or <code>luxor-drawing-(timestamp).svg</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">@svg circle(O, 20, :fill)

@svg circle(O, 20, :fill) 400

@svg circle(O, 20, :fill) 400 1200

@svg circle(O, 20, :fill) 400 1200 &quot;/tmp/test&quot;

@svg circle(O, 20, :fill) 400 1200 &quot;/tmp/test.svg&quot;

@svg begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end

@svg begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end 1200 1200</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@png" href="#Luxor.@png"><code>Luxor.@png</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@png drawing-instructions [width] [height] [filename]</code></pre><p>Create and preview an PNG drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as <code>filename</code>, if supplied, or <code>luxor-drawing(timestamp).png</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">@png circle(O, 20, :fill)

@png circle(O, 20, :fill) 400

@png circle(O, 20, :fill) 400 1200

@png circle(O, 20, :fill) 400 1200 &quot;/tmp/round&quot;

@png circle(O, 20, :fill) 400 1200 &quot;/tmp/round.png&quot;

@png begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end


@png begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end 1200 1200</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@pdf" href="#Luxor.@pdf"><code>Luxor.@pdf</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@pdf drawing-instructions [width] [height] [filename]</code></pre><p>Create and preview an PDF drawing, optionally specifying width and height (the default is 600 by 600). The file is saved in the current working directory as <code>filename</code> if supplied, or <code>luxor-drawing(timestamp).pdf</code>.</p><p><strong>Examples</strong></p><pre><code class="language-none">@pdf circle(O, 20, :fill)

@pdf circle(O, 20, :fill) 400

@pdf circle(O, 20, :fill) 400 1200

@pdf circle(O, 20, :fill) 400 1200 &quot;/tmp/A0-version&quot;

@pdf circle(O, 20, :fill) 400 1200 &quot;/tmp/A0-version.pdf&quot;

@pdf begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end

@pdf begin
        setline(10)
        sethue(&quot;purple&quot;)
        circle(O, 20, :fill)
     end 1200 1200</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@draw" href="#Luxor.@draw"><code>Luxor.@draw</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@draw drawing-instructions [width] [height]</code></pre><p>Preview an PNG drawing, optionally specifying width and height (the default is 600 by 600). The drawing is stored in memory, not in a file on disk.</p><p><strong>Examples</strong></p><pre><code class="language-none">@draw circle(O, 20, :fill)

@draw circle(O, 20, :fill) 400

@draw circle(O, 20, :fill) 400 1200


@draw begin
         setline(10)
         sethue(&quot;purple&quot;)
         circle(O, 20, :fill)
      end


@draw begin
         setline(10)
         sethue(&quot;purple&quot;)
         circle(O, 20, :fill)
      end 1200 1200</code></pre></div></section></article><p>If you don&#39;t specify a size, the defaults are 600 by 600. If you don&#39;t specify a file name, files created with the macros are placed in your current working directory as <code>luxor-drawing-</code> followed by a time stamp. You don&#39;t have to specify the suffix:</p><pre><code class="language-none">@svg juliacircles(150) 400 400 &quot;test&quot; # saves in &quot;test.svg&quot;</code></pre><p>If you want to create drawings with transparent backgrounds, or located other than in the center, use the longer form rather than the macros:</p><pre><code class="language-julia">Drawing()
background(1, 1, 1, 0)
origin()
setline(30)
sethue(&quot;green&quot;) # assumes current opacity
box(BoundingBox() - 50, :stroke)
finish()
preview()</code></pre><p><img src="../assets/figures/transparentbackground.png" alt="transparent background"/></p><h3 id="Drawings-in-memory"><a class="docs-heading-anchor" href="#Drawings-in-memory">Drawings in memory</a><a id="Drawings-in-memory-1"></a><a class="docs-heading-anchor-permalink" href="#Drawings-in-memory" title="Permalink"></a></h3><p>You can choose to store the drawing in memory. The advantage is that in-memory drawings are quicker, and can be passed as Julia data. It&#39;s useful in some environments to not have to worry about writing files. This syntax for the <code>Drawing()</code> function:</p><pre><code class="language-none">Drawing(width, height, surfacetype, [filename])</code></pre><p>lets you supply <code>surfacetype</code> as a symbol (<code>:svg</code> or <code>:png</code>). This creates a new drawing of the given surface type and stores the image only in memory if no <code>filename</code> is supplied. The <code>@draw</code> macro creates PNG files in memory.</p><p>You can specify <code>:image</code> as the surface type. This allows you to copy the current drawing into a 2D matrix (using <code>image_as_matrix()</code>). See the Images chapter for more information.</p><h3 id="Interactive-graphics-with-IJulia-and-Interact"><a class="docs-heading-anchor" href="#Interactive-graphics-with-IJulia-and-Interact">Interactive graphics with IJulia and Interact</a><a id="Interactive-graphics-with-IJulia-and-Interact-1"></a><a class="docs-heading-anchor-permalink" href="#Interactive-graphics-with-IJulia-and-Interact" title="Permalink"></a></h3><p>Currently, you should use an in-memory SVG drawing to display graphics if you&#39;re using Interact.jl. This example provides an HSB color widget.</p><pre><code class="language-julia">using Interact, Colors, Luxor
@manipulate for h in 0:360, s in 0:0.01:1, b in 0:0.01:1
    d = Drawing(300, 300, :svg)
    sethue(Colors.HSB(h, s, b))
    origin()
    circle(Point(0, 0), 100, :fill)  
    circle(polar(110, deg2rad(h)), 10, :fill)
    sethue(&quot;black&quot;)
    label(string(h, &quot;°&quot;), deg2rad(h), polar(120, deg2rad(h)))
        finish()
    d
end</code></pre><p><img src="../assets/figures/interact.png" alt="interactive"/></p><h2 id="The-drawing-surface"><a class="docs-heading-anchor" href="#The-drawing-surface">The drawing surface</a><a id="The-drawing-surface-1"></a><a class="docs-heading-anchor-permalink" href="#The-drawing-surface" title="Permalink"></a></h2><p>The origin (0/0) starts off at the top left: the x axis runs left to right across the page, and the y axis runs top to bottom down the page.</p><p>The <code>origin()</code> function moves the 0/0 point to the center of the drawing. It&#39;s often convenient to do this at the beginning of a program.</p><p>You can use functions like <code>scale()</code>, <code>rotate()</code>, and <code>translate()</code> to change the coordinate system.</p><p><code>background()</code> fills the drawing with a color, covering any previous contents. By default, PDF drawings have a white background, whereas PNG drawings have no background so that the background appears transparent in other applications. If there is a current clipping region, <code>background()</code> fills just that region. In the next example, the first <code>background()</code> fills the entire drawing with magenta, but the calls in the loop fill only the active clipping region, a table cell defined by the <code>Table</code> iterator:</p><pre><code class="language-julia">background(&quot;magenta&quot;)
origin()
table = Table(5, 5, 100, 50)
for (pos, n) in table
    box(pos,
        table.colwidths[table.currentcol],
        table.rowheights[table.currentrow],
        :clip)
    background(randomhue()...)
    clipreset()
end</code></pre><p><img src="../assets/figures/backgrounds.png" alt="background"/></p><p>The <code>rulers()</code> function draws a couple of rulers to indicate the position and orientation of the current axes.</p><pre><code class="language-julia">background(&quot;gray80&quot;)
origin()
rulers()</code></pre><p><img src="../assets/figures/axes.png" alt="axes"/></p><article class="docstring"><header><a class="docstring-binding" id="Luxor.background" href="#Luxor.background"><code>Luxor.background</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">background(color)</code></pre><p>Fill the canvas with a single color. Returns the (red, green, blue, alpha) values.</p><p>Examples:</p><pre><code class="language-none">background(&quot;antiquewhite&quot;)
background(1, 0.0, 1.0)
background(1, 0.0, 1.0, .5)</code></pre><p>If Colors.jl is installed:</p><pre><code class="language-none">background(RGB(0, 1, 0))
background(RGBA(0, 1, 0))
background(RGBA(0, 1, 0, .5))
background(Luv(20, -20, 30))</code></pre><p>If you don&#39;t specify a background color for a PNG drawing, the background will be transparent. You can set a partly or completely transparent background for PNG files by passing a color with an alpha value, such as this &#39;transparent black&#39;:</p><pre><code class="language-none">background(RGBA(0, 0, 0, 0))</code></pre><p>or</p><pre><code class="language-none">background(0, 0, 0, 0)</code></pre><p>Returns a tuple <code>(r, g, b, a)</code> of the color that was used to paint the background.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.rulers" href="#Luxor.rulers"><code>Luxor.rulers</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">rulers()</code></pre><p>Draw and label two rulers starting at <code>O</code>, the current 0/0, and continuing out along the current positive x and y axes.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.origin" href="#Luxor.origin"><code>Luxor.origin</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">origin()</code></pre><p>Reset the current matrix, and then set the 0/0 origin to the center of the drawing (otherwise it will stay at the top left corner, the default).</p><p>You can refer to the 0/0 point as <code>O</code>. (O = <code>Point(0, 0)</code>),</p></div></section><section><div><pre><code class="language-none">origin(pt:Point)</code></pre><p>Reset the current matrix, then move the <code>0/0</code> position to <code>pt</code>.</p></div></section></article><h2 id="Save-and-restore"><a class="docs-heading-anchor" href="#Save-and-restore">Save and restore</a><a id="Save-and-restore-1"></a><a class="docs-heading-anchor-permalink" href="#Save-and-restore" title="Permalink"></a></h2><p><code>gsave()</code> saves a copy of the current graphics settings (current axis rotation, position, scale, line and text settings, color, and so on). When the next <code>grestore()</code> is called, all changes you&#39;ve made to the graphics settings will be discarded, and the previous settings are restored, so things return to how they were when you last used <code>gsave()</code>. <code>gsave()</code> and <code>grestore()</code> should always be balanced in pairs.</p><p>The <code>@layer</code> macro is a synonym for a <code>gsave()</code>...<code>grestore()</code> pair.</p><pre><code class="language-julia">@svg begin
    circle(Point(0, 0), 100, :stroke)
    @layer (sethue(&quot;red&quot;); rule(Point(0, 0)); rule(O, π/2))
    circle(Point(0, 0), 200, :stroke)
end</code></pre><p>or</p><pre><code class="language-julia">@svg begin
    circle(Point(0, 0), 100, :stroke)
    @layer begin
        sethue(&quot;red&quot;)
        rule(Point(0, 0))
        rule(Point(0, 0), pi/2)
    end
    circle(Point(0, 0), 200, :stroke)
end</code></pre><article class="docstring"><header><a class="docstring-binding" id="Luxor.gsave" href="#Luxor.gsave"><code>Luxor.gsave</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gsave()</code></pre><p>Save the current color settings on the stack.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.grestore" href="#Luxor.grestore"><code>Luxor.grestore</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">grestore()</code></pre><p>Replace the current graphics state with the one on top of the stack.</p></div></section></article><h2 id="Return-the-current-drawing"><a class="docs-heading-anchor" href="#Return-the-current-drawing">Return the current drawing</a><a id="Return-the-current-drawing-1"></a><a class="docs-heading-anchor-permalink" href="#Return-the-current-drawing" title="Permalink"></a></h2><p>In some situations you&#39;ll want to explicitly return the current drawing to the calling function.</p><article class="docstring"><header><a class="docstring-binding" id="Luxor.currentdrawing" href="#Luxor.currentdrawing"><code>Luxor.currentdrawing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">currentdrawing()</code></pre><p>Return the current Luxor drawing, if there currently is one.</p></div></section></article><h2 id="Drawing-as-image-matrix"><a class="docs-heading-anchor" href="#Drawing-as-image-matrix">Drawing as image matrix</a><a id="Drawing-as-image-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Drawing-as-image-matrix" title="Permalink"></a></h2><p>While drawing, you can copy the data in the form of a matrix, using the <code>image_as_matrix()</code> function.</p><p><code>image_as_matrix()</code> returns a array of ARGB32 values that encode the Red, Green, Blue, and Alpha values of each pixel.</p><p>The following example draws a red rectangle, then copies the drawing into a matrix called <code>mat1</code>. Then it adds a blue triangle, and copies the updated drawing into <code>mat2</code>. Then, the second drawing reads the values in from the two matrices and draws some square tiles depending on the corresponding values in the two matrices ... a very primitive Boolean operation.</p><pre><code class="language-julia">Drawing(40, 40, :png)
origin()
background(&quot;black&quot;)
sethue(&quot;red&quot;)
box(Point(0, 0), 40, 15, :fill)
mat1 = image_as_matrix()
sethue(&quot;blue&quot;)
setline(10)
setopacity(0.6)
ngon(Point(0, 0), 10, 3, 0, :stroke)
mat2 = image_as_matrix()
finish()

# second drawing

Drawing(400, 400, &quot;assets/figures/image-drawings.svg&quot;)
background(&quot;grey20&quot;)
origin()
t = Table(40, 40, 4, 4)
sethue(&quot;white&quot;)
rc = CartesianIndices(mat1)
for i in rc
    r, c = Tuple(i)
    pixel1 = convert(Colors.RGBA, mat1[r, c])
    pixel2 = convert(Colors.RGBA, mat2[r, c])
    if red(pixel1) &gt; .5 &amp;&amp; blue(pixel2) &gt; .5
        randomhue()
        box(t, r, c, :fillstroke)
    end
end</code></pre><p><img src="../assets/figures/image-drawing-intermediate.png" alt="intermediate"/></p><p><img src="../assets/figures/image-drawings.svg" alt="image drawings"/></p><p>(You can use <code>collect()</code> to gather the re-interpreted values together.)</p><p>If you&#39;re working with Images.jl, you will probably want to transpose the array:</p><pre><code class="language-none">using Luxor, Images

# in Luxor

Drawing(50, 50, :png)
origin()
background(randomhue()...)
sethue(&quot;white&quot;)
fontsize(40)
fontface(&quot;Georgia&quot;)
text(&quot;42&quot;, halign=:center, valign=:middle)
mat = image_as_matrix();
finish()

# in Images

img = Gray.(mat)
display(imresize(img, 150, 150))</code></pre><article class="docstring"><header><a class="docstring-binding" id="Luxor.@imagematrix" href="#Luxor.@imagematrix"><code>Luxor.@imagematrix</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@imagematrix(body, width=256, height=256)</code></pre><p>Create a drawing and return a matrix of the image.</p><p>This macro returns a matrix of pixels that represent the drawing produced by the vector graphics instructions. It uses the <code>image_as_matrix()</code> function.</p><p>The default drawing is 256 by 256 points.</p><p>You don&#39;t need <code>finish()</code> (the macro calls it), and it&#39;s not previewed by <code>preview()</code>.</p><pre><code class="language-none">m = @imagematrix begin
        sethue(&quot;red&quot;)
        box(O, 20, 20, :fill)
    end 60 60

julia&gt;  m[1220:1224] |&gt; show
    ARGB32[ARGB32(0.0N0f8,0.0N0f8,0.0N0f8,0.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8),
           ARGB32(1.0N0f8,0.0N0f8,0.0N0f8,1.0N0f8)]
</code></pre><p>If, for some strange reason you want to draw the matrix as another Luxor drawing again, use code such as this:</p><pre><code class="language-none">m = @imagematrix begin
        sethue(&quot;red&quot;)
        box(O, 20, 20, :fill)
        sethue(&quot;blue&quot;)
        box(O, 10, 40, :fill)
    end 60 60

function convertmatrixtocolors(m)
    return convert.(Colors.RGBA, m)
end

function drawimagematrix(m)
    d = Drawing(500, 500, &quot;/tmp/temp.png&quot;)
    origin()
    w, h = size(m)
    t = Tiler(500, 500, w, h)
    mi = convertmatrixtocolors(m)
    @show mi[30, 30]
    for (pos, n) in t
        c = mi[t.currentrow, t.currentcol]
        setcolor(c)
        box(pos, t.tilewidth -1, t.tileheight - 1, :fill)
    end
    finish()
    return d
end

drawimagematrix(m)</code></pre><p>Transparency</p><p>The default value for the cells in an image matrix is transparent black. (Luxor&#39;s default color is opaque black.)</p><pre><code class="language-none">julia&gt; @imagematrix begin
       end 2 2
2×2 reinterpret(ARGB32, ::Array{UInt32,2}):
 ARGB32(0.0,0.0,0.0,0.0)  ARGB32(0.0,0.0,0.0,0.0)
 ARGB32(0.0,0.0,0.0,0.0)  ARGB32(0.0,0.0,0.0,0.0)</code></pre><p>Setting the background to a partially or completely transparent value may give unexpected results:</p><pre><code class="language-none">julia&gt; @imagematrix begin
       background(1, 0.5, 0.0, 0.5) # semi-transparent orange
       end 2 2
2×2 reinterpret(ARGB32, ::Array{UInt32,2}):
 ARGB32(0.502,0.251,0.0,0.502)  ARGB32(0.502,0.251,0.0,0.502)
 ARGB32(0.502,0.251,0.0,0.502)  ARGB32(0.502,0.251,0.0,0.502)</code></pre><p>here the semi-transparent orange color has been partially applied to the transparent background.</p><pre><code class="language-none">julia&gt; @imagematrix begin
           sethue(1., 0.5, 0.0)
       paint()
       end 2 2
2×2 reinterpret(ARGB32, ::Array{UInt32,2}):
 ARGB32(1.0,0.502,0.0,1.0)  ARGB32(1.0,0.502,0.0,1.0)
 ARGB32(1.0,0.502,0.0,1.0)  ARGB32(1.0,0.502,0.0,1.0)</code></pre><p>picks up the default alpha of 1.0.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.@imagematrix!" href="#Luxor.@imagematrix!"><code>Luxor.@imagematrix!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@imagematrix!(buffer, body, width=256, height=256)</code></pre><p>Like <code>@imagematrix</code>, but use an existing UInt32 buffer.</p><pre><code class="language-none">w = 200
h  = 150
buffer = zeros(UInt32, w, h)
m = @imagematrix! buffer juliacircles(40) 200 150;
Images.RGB.(m)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.image_as_matrix" href="#Luxor.image_as_matrix"><code>Luxor.image_as_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">image_as_matrix()</code></pre><p>Return an Array of the current state of the picture as an array of ARGB32.</p><p>A matrix 50 wide and 30 high =&gt; a table 30 rows by 50 cols</p><pre><code class="language-none">using Luxor, Images

Drawing(50, 50, :png)
origin()
background(randomhue()...)
sethue(&quot;white&quot;)
fontsize(40)
fontface(&quot;Georgia&quot;)
text(&quot;42&quot;, halign=:center, valign=:middle)
mat = image_as_matrix()
finish()</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Luxor.image_as_matrix!" href="#Luxor.image_as_matrix!"><code>Luxor.image_as_matrix!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">image_as_matrix!(buffer)</code></pre><p>Like <code>image_as_matrix()</code>, but use an existing UInt32 buffer.</p><p><code>buffer</code> is a buffer of UInt32.</p><pre><code class="language-none">w = 200
h = 150
buffer = zeros(UInt32, w, h)
Drawing(w, h, :image)
origin()
juliacircles(50)
m = image_as_matrix!(buffer)
finish()
# collect(m)) is Array{ARGB32,2}
Images.RGB.(m)</code></pre></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../tutorial/">« Tutorial</a><a class="docs-footer-nextpage" href="../simplegraphics/">Simple shapes »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 7 January 2021 12:31">Thursday 7 January 2021</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

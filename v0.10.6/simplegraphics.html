<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Simple graphics · Luxor</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="index.html"><img class="logo" src="assets/logo.png" alt="Luxor logo"/></a><h1>Luxor</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Introduction to Luxor</a></li><li><a class="toctext" href="examples.html">A few examples</a></li><li><a class="toctext" href="tutorial.html">Tutorial</a></li><li><a class="toctext" href="basics.html">Basic concepts</a></li><li class="current"><a class="toctext" href="simplegraphics.html">Simple graphics</a><ul class="internal"><li><a class="toctext" href="#Rectangles-and-boxes-1">Rectangles and boxes</a></li><li><a class="toctext" href="#Circles-and-ellipses-1">Circles and ellipses</a></li><li><a class="toctext" href="#More-curved-shapes:-sectors,-spirals,-and-squircles-1">More curved shapes: sectors, spirals, and squircles</a></li><li><a class="toctext" href="#Paths-and-positions-1">Paths and positions</a></li><li><a class="toctext" href="#Lines-1">Lines</a></li><li><a class="toctext" href="#Arcs-and-curves-1">Arcs and curves</a></li><li><a class="toctext" href="#Geometry-tools-1">Geometry tools</a></li><li><a class="toctext" href="#Arrows-1">Arrows</a></li><li><a class="toctext" href="#Julia-graphics-1">Julia graphics</a></li><li><a class="toctext" href="#Bounding-boxes-1">Bounding boxes</a></li><li><a class="toctext" href="#Miscellaneous-1">Miscellaneous</a></li></ul></li><li><a class="toctext" href="tables-grids.html">Tables and grids</a></li><li><a class="toctext" href="colors-styles.html">Colors and styles</a></li><li><a class="toctext" href="polygons.html">Polygons and paths</a></li><li><a class="toctext" href="text.html">Text</a></li><li><a class="toctext" href="transforms.html">Transforms and matrices</a></li><li><a class="toctext" href="clipping.html">Clipping</a></li><li><a class="toctext" href="images.html">Images</a></li><li><a class="toctext" href="turtle.html">Turtle graphics</a></li><li><a class="toctext" href="animation.html">Animation</a></li><li><a class="toctext" href="moreexamples.html">More examples</a></li><li><a class="toctext" href="functionindex.html">Index</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="simplegraphics.html">Simple graphics</a></li></ul><a class="edit-page" href="https://github.com/JuliaGraphics/Luxor.jl/blob/master/docs/src/simplegraphics.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Simple graphics</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Simple-graphics-1" href="#Simple-graphics-1">Simple graphics</a></h1><p>In Luxor, there are different ways of working with graphical items. Some, such as lines, rectangles and circles, are drawn immediately (ie placed on the drawing and then &quot;forgotten&quot;). Others can be constructed and then converted to lists of points for further processing. For these, watch out for a <code>vertices=true</code> option.</p><h2><a class="nav-anchor" id="Rectangles-and-boxes-1" href="#Rectangles-and-boxes-1">Rectangles and boxes</a></h2><p>The simple rectangle and box shapes can be made in different ways.</p><div><pre><code class="language-julia">axes()
sethue(&quot;red&quot;)
rect(O, 100, 100, :stroke)
sethue(&quot;blue&quot;)
box(O, 100, 100, :stroke)</code></pre></div><p><img src="assets/figures/basicrects.png" alt="rect vs box"/></p><p><code>rect()</code> rectangles are positioned by a corner, but a box made with <code>box()</code> can either be defined by its center and dimensions, or by two opposite corners.</p><p><img src="assets/figures/rects.png" alt="rects"/></p><p>If you want the coordinates of the corners of a box, rather than draw one immediately, use:</p><pre><code class="language-julia">box(centerpoint, width, height, vertices=true)</code></pre><p>or</p><pre><code class="language-julia">box(corner1,  corner2, vertices=true)</code></pre><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.rect" href="#Luxor.rect"><code>Luxor.rect</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rect(xmin, ymin, w, h, action)</code></pre><p>Create a rectangle with one corner at (<code>xmin</code>/<code>ymin</code>) with width <code>w</code> and height <code>h</code> and then do an action.</p><p>See <code>box()</code> for more ways to do similar things, such as supplying two opposite corners, placing by centerpoint and dimensions.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/shapes.jl#L1-L9">source</a><div><pre><code class="language-none">rect(cornerpoint, w, h, action)</code></pre><p>Create a rectangle with one corner at <code>cornerpoint</code> with width <code>w</code> and height <code>h</code> and do an action.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/shapes.jl#L18-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.box" href="#Luxor.box"><code>Luxor.box</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">box(cornerpoint1, cornerpoint2, action=:nothing; vertices=false)</code></pre><p>Create a rectangle between two points and do an action. Use <code>vertices=true</code> to return an array of the four corner points rather than draw the box.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/shapes.jl#L27-L32">source</a><div><pre><code class="language-none">box(points::AbstractArray, action=:nothing)</code></pre><p>Create a box/rectangle using the first two points of an array of Points to defined opposite corners.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/shapes.jl#L45-L50">source</a><div><pre><code class="language-none">box(pt::Point, width, height, action=:nothing; vertices=false)</code></pre><p>Create a box/rectangle centered at point <code>pt</code> with width and height. Use <code>vertices=true</code> to return an array of the four corner points rather than draw the box.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/shapes.jl#L53-L58">source</a><div><pre><code class="language-none">box(x, y, width, height, action=:nothing)</code></pre><p>Create a box/rectangle centered at point <code>x/y</code> with width and height.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/shapes.jl#L69-L73">source</a><div><pre><code class="language-none">box(x, y, width, height, cornerradius, action=:nothing)</code></pre><p>Create a box/rectangle centered at point <code>x/y</code> with <code>width</code> and <code>height</code>. Round each corner by <code>cornerradius</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/shapes.jl#L77-L82">source</a><div><pre><code class="language-none">box(t::Table, r::Int, c::Int, action::Symbol=:nothing)</code></pre><p>Draw a box in table <code>t</code> at row <code>r</code> and column <code>c</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/Table.jl#L246-L250">source</a><div><pre><code class="language-none">box(t::Table, cellnumber::Int, action::Symbol=:nothing; vertices=false)</code></pre><p>Draw box <code>cellnumber</code> in table <code>t</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/Table.jl#L256-L260">source</a><div><pre><code class="language-none">box(bbox::BoundingBox, :action)</code></pre><p>Make a box using the bounds in <code>bbox</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/BoundingBox.jl#L203-L207">source</a></section><p>For regular polygons, see the next section on Polygons.</p><h2><a class="nav-anchor" id="Circles-and-ellipses-1" href="#Circles-and-ellipses-1">Circles and ellipses</a></h2><p>There are various ways to make circles, including by center and radius, or passing through two points:</p><div><pre><code class="language-julia">p1 = O
p2 = Point(100, 0)
sethue(&quot;red&quot;)
circle(p1, 40, :fill)
sethue(&quot;green&quot;)
circle(p1, p2, :stroke)
sethue(&quot;black&quot;)
arrow(O, Point(0, -40))
map(p -&gt; circle(p, 4, :fill), [p1, p2])</code></pre></div><p><img src="assets/figures/circles.png" alt="circles"/></p><p>Or passing through three points. The <code>center3pts()</code> function returns the center position and radius of a circle passing through three points:</p><div><pre><code class="language-julia">sethue(&quot;black&quot;)
p1 = Point(0, -50)
p2 = Point(100, 0)
p3 = Point(0, 65)
map(p -&gt; circle(p, 4, :fill), [p1, p2, p3])
sethue(&quot;orange&quot;)
circle(center3pts(p1, p2, p3)..., :stroke)</code></pre></div><p><img src="assets/figures/center3.png" alt="center and radius of 3 points"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.circle" href="#Luxor.circle"><code>Luxor.circle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">circle(x, y, r, action=:nothing)</code></pre><p>Make a circle of radius <code>r</code> centered at <code>x</code>/<code>y</code>.</p><p><code>action</code> is one of the actions applied by <code>do_action</code>, defaulting to <code>:nothing</code>. You can also use <code>ellipse()</code> to draw circles and place them by their centerpoint.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L3-L10">source</a><div><pre><code class="language-none">circle(pt, r, action=:nothing)</code></pre><p>Make a circle centered at <code>pt</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L19-L23">source</a><div><pre><code class="language-none">circle(pt1::Point, pt2::Point, action=:nothing)</code></pre><p>Make a circle that passes through two points that define the diameter:</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L27-L31">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.center3pts" href="#Luxor.center3pts"><code>Luxor.center3pts</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">center3pts(a::Point, b::Point, c::Point)</code></pre><p>Find the radius and center point for three points lying on a circle.</p><p>returns <code>(centerpoint, radius)</code> of a circle. Then you can use <code>circle()</code> to place a circle, or <code>arc()</code> to draw an arc passing through those points.</p><p>If there&#39;s no such circle, then you&#39;ll see an error message in the console and the function returns <code>(Point(0,0), 0)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L38-L48">source</a></section><p>With <code>ellipse()</code> you can place ellipses (and circles) by defining the center point and the width and height.</p><div><pre><code class="language-julia">tiles = Tiler(500, 300, 5, 5)
width = 20
height = 25
for (pos, n) in tiles
    randomhue()
    ellipse(pos, width, height, :fill)
    sethue(&quot;black&quot;)
    label = string(round(width/height, 2))
    textcentered(label, pos.x, pos.y + 25)
    width += 2
end</code></pre></div><p><img src="assets/figures/ellipses.png" alt="ellipses"/></p><p><code>ellipse()</code> can also construct polygons that are approximations to ellipses. You supply two focal points and a length which is the sum of the distances of a point on the perimeter to the two focii.</p><div><pre><code class="language-julia">fontface(&quot;Menlo&quot;)

f1 = Point(-100, 0)
f2 = Point(100, 0)

circle.([f1, f2], 3, :fill)

epoly = ellipse(f1, f2, 250, vertices=true)
poly(epoly, :stroke,  close=true)

pt = epoly[rand(1:end)]

poly([f1, pt, f2], :stroke)

label(&quot;f1&quot;, :W, f1, offset=10)
label(&quot;f2&quot;, :E, f2, offset=10)

label(string(round(norm(f1, pt), 1)), :SE, midpoint(f1, pt))
label(string(round(norm(pt, f2), 1)), :SW, midpoint(pt, f2))

label(&quot;ellipse(f1, f2, 250)&quot;, :S, Point(0, 75))</code></pre></div><p><img src="assets/figures/ellipses_1.png" alt="more ellipses"/></p><p>The advantage of this method is that there&#39;s a <code>vertices=true|false</code> option, allowing further scope for polygon manipulation.</p><div><pre><code class="language-julia">f1 = Point(-100, 0)
f2 = Point(100, 0)
ellipsepoly = ellipse(f1, f2, 170, :none, vertices=true)
[ begin
    setgray(rescale(c, 150, 1, 0, 1))
    poly(offsetpoly(ellipsepoly, c), close=true, :fill);
    rotate(pi/20)
  end
     for c in 150:-10:1 ]</code></pre></div><p><img src="assets/figures/ellipses_2.png" alt="even more ellipses"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.ellipse" href="#Luxor.ellipse"><code>Luxor.ellipse</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ellipse(xc, yc, w, h, action=:none)</code></pre><p>Make an ellipse, centered at <code>xc/yc</code>, fitting in a box of width <code>w</code> and height <code>h</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L69-L73">source</a><div><pre><code class="language-none">ellipse(cpt, w, h, action=:none)</code></pre><p>Make an ellipse, centered at point <code>c</code>, with width <code>w</code>, and height <code>h</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L93-L97">source</a><div><pre><code class="language-none">ellipse(focus1::Point, focus2::Point, k, action=:none;
        stepvalue=pi/100,
        vertices=false,
        reversepath=false)</code></pre><p>Build a polygon approximation to an ellipse, given two points and a distance, <code>k</code>, which is the sum of the distances to the focii of any points on the ellipse (or the shortest length of string required to go from one focus to the perimeter and on to the other focus).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L441-L450">source</a></section><p><code>circlepath()</code> constructs a circular path from Bézier curves, which allows you to use circles as paths.</p><div><pre><code class="language-julia">setline(4)
tiles = Tiler(600, 250, 1, 5)
for (pos, n) in tiles
    randomhue()
    circlepath(pos, tiles.tilewidth/2, :path)
    newsubpath()
    circlepath(pos, rand(5:tiles.tilewidth/2 - 1), :fill, reversepath=true)
end</code></pre></div><p><img src="assets/figures/circle-path.png" alt="circles as paths"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.circlepath" href="#Luxor.circlepath"><code>Luxor.circlepath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">circlepath(center::Point, radius, action=:none;
    reversepath=false,
    kappa = 0.5522847498307936)</code></pre><p>Draw a circle using Bézier curves.</p><p>The magic value, <code>kappa</code>, is <code>4.0 * (sqrt(2.0) - 1.0) / 3.0</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L374-L382">source</a></section><h2><a class="nav-anchor" id="More-curved-shapes:-sectors,-spirals,-and-squircles-1" href="#More-curved-shapes:-sectors,-spirals,-and-squircles-1">More curved shapes: sectors, spirals, and squircles</a></h2><p>A sector (technically an &quot;annular sector&quot;) has an inner and outer radius, as well as start and end angles.</p><div><pre><code class="language-julia">sethue(&quot;tomato&quot;)
sector(50, 90, pi/2, 0, :fill)
sethue(&quot;olive&quot;)
sector(Point(O.x + 200, O.y), 50, 90, 0, pi/2, :fill)</code></pre></div><p><img src="assets/figures/sector.png" alt="sector"/></p><p>You can also supply a value for a corner radius. The same sector is drawn but with rounded corners.</p><div><pre><code class="language-julia">sethue(&quot;tomato&quot;)
sector(50, 90, pi/2, 0, 15, :fill)
sethue(&quot;olive&quot;)
sector(Point(O.x + 200, O.y), 50, 90, 0, pi/2, 15, :fill)</code></pre></div><p><img src="assets/figures/sectorrounded.png" alt="sector"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.sector" href="#Luxor.sector"><code>Luxor.sector</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">sector(centerpoint::Point, innerradius, outerradius, startangle, endangle, action:none)</code></pre><p>Draw an annular sector centered at <code>centerpoint</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L208-L212">source</a><div><pre><code class="language-none">sector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real,
   action::Symbol=:none)</code></pre><p>Draw an annular sector centered at the origin.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L228-L233">source</a><div><pre><code class="language-none">sector(centerpoint::Point, innerradius, outerradius, startangle, endangle,
    cornerradius, action:none)</code></pre><p>Draw an annular sector with rounded corners, basically a bent sausage shape, centered at <code>centerpoint</code>.</p><p>TODO: The results aren&#39;t 100% accurate at the moment. There are small discontinuities where the curves join.</p><p>The cornerradius is reduced from the supplied value if neceesary to prevent overshoots.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L238-L249">source</a><div><pre><code class="language-none">sector(innerradius::Real, outerradius::Real, startangle::Real, endangle::Real,
   cornerradius::Real, action::Symbol=:none)</code></pre><p>Draw an annular sector with rounded corners, centered at the current origin.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L316-L321">source</a></section><p>A pie (or wedge) has start and end angles.</p><div><pre><code class="language-julia">pie(0, 0, 100, pi/2, pi, :fill)</code></pre></div><p><img src="assets/figures/pie.png" alt="pie"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.pie" href="#Luxor.pie"><code>Luxor.pie</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pie(x, y, radius, startangle, endangle, action=:none)</code></pre><p>Draw a pie shape centered at <code>x</code>/<code>y</code>. Angles start at the positive x-axis and are measured clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L326-L331">source</a><div><pre><code class="language-none">pie(centerpoint, radius, startangle, endangle, action=:none)</code></pre><p>Draw a pie shape centered at <code>centerpoint</code>.</p><p>Angles start at the positive x-axis and are measured clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L344-L350">source</a><div><pre><code class="language-none">pie(radius, startangle, endangle, action=:none)</code></pre><p>Draw a pie shape centered at the origin</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L354-L359">source</a></section><p>To construct spirals, use the <code>spiral()</code> function. These can be drawn directly, or used as polygons. The default is to draw Archimedes (non-logarithmic) spirals.</p><div><pre><code class="language-julia">spiraldata = [
  (-2, &quot;Lituus&quot;,      50),
  (-1, &quot;Hyperbolic&quot;, 100),
  ( 1, &quot;Archimedes&quot;,   1),
  ( 2, &quot;Fermat&quot;,       5)]

grid = GridRect(O - (200, 0), 130, 50)

for aspiral in spiraldata
    @layer begin
        translate(nextgridpoint(grid))
        spiral(last(aspiral), first(aspiral), period=20pi, :stroke)
        label(aspiral[2], :S, offset=100)
    end
end</code></pre></div><p><img src="assets/figures/spiral.png" alt="spiral"/></p><p>Use the <code>log=true</code> option to draw logarithmic (Bernoulli or Fibonacci) spirals.</p><div><pre><code class="language-julia">spiraldata = [
    (10,  0.05),
    (4,   0.10),
    (0.5, 0.17)]

grid = GridRect(O - (200, 0), 175, 50)
for aspiral in spiraldata
    @layer begin
        translate(nextgridpoint(grid))
        spiral(first(aspiral), last(aspiral), log=true, period=10pi, :stroke)
        label(string(aspiral), :S, offset=100)
    end
end</code></pre></div><p>Modify the <code>stepby</code> and <code>period</code> parameters to taste, or collect the vertices for further processing.</p><p><img src="assets/figures/spiral-log.png" alt="spiral log"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.spiral" href="#Luxor.spiral"><code>Luxor.spiral</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">spiral(a, b, action::Symbol=:none;
                 stepby = 0.01,
                 period = 4pi,
                 vertices = false,
                 log=false)</code></pre><p>Make a spiral. The two primary parameters <code>a</code> and <code>b</code> determine the start radius, and the tightness.</p><p>For linear spirals (<code>log=false</code>), <code>b</code> values are:</p><pre><code class="language-none">lituus: -2

hyperbolic spiral: -1

Archimedes&#39; spiral: 1

Fermat&#39;s spiral: 2</code></pre><p>For logarithmic spirals (<code>log=true</code>):</p><pre><code class="language-none">golden spiral: b = ln(phi)/ (pi/2) (about 0.30)</code></pre><p>Values of <code>b</code> around 0.1 produce tighter, staircase-like spirals.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L560-L585">source</a></section><p>A <em>squircle</em> is a cross between a square and a circle. You can adjust the squariness and circularity of it to taste by supplying a value for the root (keyword <code>rt</code>):</p><div><pre><code class="language-julia">setline(2)
tiles = Tiler(600, 250, 1, 3)
for (pos, n) in tiles
    sethue(&quot;lavender&quot;)
    squircle(pos, 80, 80, rt=[0.3, 0.5, 0.7][n], :fillpreserve)
    sethue(&quot;grey20&quot;)
    strokepath()
    textcentered(&quot;rt = $([0.3, 0.5, 0.7][n])&quot;, pos)
end</code></pre></div><p><img src="assets/figures/squircle.png" alt="squircles"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.squircle" href="#Luxor.squircle"><code>Luxor.squircle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">squircle(center::Point, hradius, vradius, action=:none;
    rt = 0.5, stepby = pi/40, vertices=false)</code></pre><p>Make a squircle or superellipse (basically a rectangle with rounded corners). Specify the center position, horizontal radius (distance from center to a side), and vertical radius (distance from center to top or bottom):</p><p>The root (<code>rt</code>) option defaults to 0.5, and gives an intermediate shape. Values less than 0.5 make the shape more rectangular. Values above make the shape more round. The horizontal and vertical radii can be different.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L100-L111">source</a></section><p>To draw a simple rounded rectangle, supply a corner radius:</p><div><pre><code class="language-julia">setline(4)
box(O, 200, 150, 10, :stroke)</code></pre></div><p><img src="assets/figures/round-rect-1.png" alt="rounded rect 1"/></p><p>Or you could smooth the corners of a box, like so:</p><div><pre><code class="language-julia">setline(4)
polysmooth(box(O, 200, 150, vertices=true), 10, :stroke)</code></pre></div><p><img src="assets/figures/round-rect.png" alt="rounded rect"/></p><h2><a class="nav-anchor" id="Paths-and-positions-1" href="#Paths-and-positions-1">Paths and positions</a></h2><p>A path is a sequence of lines and curves. You can add lines and curves to the current path, then use <code>closepath()</code> to join the last point to the first.</p><p>A path can have subpaths, created with<code>newsubpath()</code>, which can form holes.</p><p>There is a &#39;current position&#39; which you can set with <code>move()</code>, and can use implicitly in functions like <code>line()</code>, <code>rline()</code>, <code>text()</code>, <code>arc()</code> and <code>curve()</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.move" href="#Luxor.move"><code>Luxor.move</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">move(x, y)
move(pt)</code></pre><p>Move to a point.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/basics.jl#L322-L327">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.rmove" href="#Luxor.rmove"><code>Luxor.rmove</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rmove(x, y)</code></pre><p>Move by an amount from the current point. Move relative to current position by <code>x</code> and <code>y</code>:</p><p>Move relative to current position by the <code>pt</code>&#39;s x and y:</p><pre><code class="language-none">rmove(pt)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/basics.jl#L331-L339">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.newpath" href="#Luxor.newpath"><code>Luxor.newpath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">newpath()</code></pre><p>Create a new path. This is Cairo&#39;s <code>new_path()</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/basics.jl#L156-L160">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.newsubpath" href="#Luxor.newsubpath"><code>Luxor.newsubpath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">newsubpath()</code></pre><p>Add a new subpath to the current path. This is Cairo&#39;s <code>new_sub_path()</code> function. It can be used for example to make holes in shapes.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/basics.jl#L163-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.closepath" href="#Luxor.closepath"><code>Luxor.closepath</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">closepath()</code></pre><p>Close the current path. This is Cairo&#39;s <code>close_path()</code> function.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/basics.jl#L171-L175">source</a></section><h2><a class="nav-anchor" id="Lines-1" href="#Lines-1">Lines</a></h2><p>Use <code>line()</code> and <code>rline()</code> to draw straight lines. <code>line(pt1, pt2, action)</code> draws a line between two points. <code>line(pt)</code> adds a line to the current path going from the current position to the point. <code>rline(pt)</code> adds a line relative to the current position.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.line" href="#Luxor.line"><code>Luxor.line</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">line(x, y)
line(x, y)
line(pt)</code></pre><p>Create a line from the current position to the <code>x/y</code> position.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/basics.jl#L343-L349">source</a><div><pre><code class="language-none">line(pt1::Point, pt2::Point, action=:nothing)</code></pre><p>Make a line between two points, <code>pt1</code> and <code>pt2</code> and do an action.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/basics.jl#L353-L357">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.rline" href="#Luxor.rline"><code>Luxor.rline</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rline(x, y)
rline(x, y)
rline(pt)</code></pre><p>Create a line relative to the current position to the <code>x/y</code> position.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/basics.jl#L364-L370">source</a></section><p>You can use <code>rule()</code> to draw a line across the entire drawing through a point, at an angle to the current x-axis.</p><div><pre><code class="language-julia">y = 10
for x in logspace(0, 2.75, 40)
    circle(Point(x, y), 2, :fill)
    rule(Point(x, y), -pi/2)
    y += 2
end</code></pre></div><p><img src="assets/figures/rule.png" alt="arc"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.rule" href="#Luxor.rule"><code>Luxor.rule</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">rule(pos::Point, theta=0.0)</code></pre><p>Draw a line across the entire drawing passing through <code>pos</code>, at an angle of <code>theta</code> to the x-axis. Returns the two points.</p><p>The end points are not calculated exactly, they&#39;re just a long way apart.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/basics.jl#L374-L381">source</a></section><h2><a class="nav-anchor" id="Arcs-and-curves-1" href="#Arcs-and-curves-1">Arcs and curves</a></h2><p>There are a few standard arc-drawing commands, such as <code>curve()</code>, <code>arc()</code>, <code>carc()</code>, and <code>arc2r()</code>. Because these are often used when building complex paths, they usually add arc sections to the current path. To construct a sequence of lines and arcs, use the <code>:path</code> action.</p><p><code>curve()</code> constructs Bézier curves from control points:</p><div><pre><code class="language-julia">setline(.5)
pt1 = Point(0, -125)
pt2 = Point(200, 125)
pt3 = Point(200, -125)

label.(string.([&quot;O&quot;, &quot;control point 1&quot;, &quot;control point 2&quot;, &quot;control point 3&quot;]),
    :e,
    [O, pt1, pt2, pt3])

sethue(&quot;red&quot;)
map(p -&gt; circle(p, 4, :fill), [O, pt1, pt2, pt3])

line(O, pt1, :stroke)
line(pt2, pt3, :stroke)

sethue(&quot;black&quot;)
setline(3)

# start a path
move(O)
curve(pt1, pt2, pt3) #  add to current path
strokepath()</code></pre></div><p><img src="assets/figures/curve.png" alt="curve"/></p><p><code>arc2r()</code> draws a circular arc centered at a point that passes through two other points:</p><div><pre><code class="language-julia">tiles = Tiler(700, 200, 1, 6)
for (pos, n) in tiles
    c1, pt2, pt3 = ngon(pos, rand(10:50), 3, rand(0:pi/12:2pi), vertices=true)
    sethue(&quot;black&quot;)
    map(pt -&gt; circle(pt, 4, :fill), [c1, pt3])
    sethue(&quot;red&quot;)
    circle(pt2, 4, :fill)
    randomhue()
    arc2r(c1, pt2, pt3, :stroke)
end</code></pre></div><p><img src="assets/figures/arc2r.png" alt="arc"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.arc" href="#Luxor.arc"><code>Luxor.arc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">arc(xc, yc, radius, angle1, angle2, action=:nothing)</code></pre><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going clockwise, centered at xc, yc.</p><p>Angles are defined relative to the x-axis, positive clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L126-L133">source</a><div><pre><code class="language-none">arc(centerpoint::Point, radius, angle1, angle2, action=:nothing)</code></pre><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going clockwise, centered at <code>centerpoint</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L139-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.arc2r" href="#Luxor.arc2r"><code>Luxor.arc2r</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">  arc2r(c1::Point, p2::Point, p3::Point, action=:nothing)</code></pre><p>Add a circular arc centered at <code>c1</code> that starts at <code>p2</code> and ends at <code>p3</code>, going clockwise, to the current path.</p><p><code>c1</code>-<code>p2</code> really determines the radius. If <code>p3</code> doesn&#39;t lie on the circular path,  it will be used only as an indication of the arc&#39;s length, rather than its position.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L170-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.carc" href="#Luxor.carc"><code>Luxor.carc</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">carc(xc, yc, radius, angle1, angle2, action=:nothing)</code></pre><p>Add an arc to the current path from <code>angle1</code> to <code>angle2</code> going counterclockwise, centered at <code>xc</code>/<code>yc</code>.</p><p>Angles are defined relative to the x-axis, positive clockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L148-L155">source</a><div><pre><code class="language-none">carc(centerpoint::Point, radius, angle1, angle2, action=:nothing)</code></pre><p>Add an arc centered at <code>centerpoint</code> to the current path from <code>angle1</code> to <code>angle2</code>, going counterclockwise.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L161-L166">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.carc2r" href="#Luxor.carc2r"><code>Luxor.carc2r</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">carc2r(c1::Point, p2::Point, p3::Point, action=:nothing)</code></pre><p>Add a circular arc centered at <code>c1</code> that starts at <code>p2</code> and ends at <code>p3</code>, going counterclockwise, to the current path.</p><p><code>c1</code>-<code>p2</code> really determines the radius. If <code>p3</code> doesn&#39;t lie on the circular path, it will be used only as an indication of the arc&#39;s length, rather than its position.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L189-L197">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.curve" href="#Luxor.curve"><code>Luxor.curve</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">curve(x1, y1, x2, y2, x3, y3)
curve(p1, p2, p3)</code></pre><p>Add a Bézier curve.</p><p>The spline starts at the current position, finishing at <code>x3/y3</code> (<code>p3</code>), following two control points <code>x1/y1</code> (<code>p1</code>) and <code>x2/y2</code> (<code>p2</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L362-L370">source</a></section><h2><a class="nav-anchor" id="Geometry-tools-1" href="#Geometry-tools-1">Geometry tools</a></h2><p>You can find the midpoint between two points using <code>midpoint()</code>.</p><p>The following code places a small pentagon (using <code>ngon()</code>) at the midpoint of each side of a larger pentagon:</p><div><pre><code class="language-julia">sethue(&quot;red&quot;)
ngon(O, 100, 5, 0, :stroke)

sethue(&quot;darkgreen&quot;)
p5 = ngon(O, 100, 5, 0, vertices=true)

for i in eachindex(p5)
    pt1 = p5[mod1(i, 5)]
    pt2 = p5[mod1(i + 1, 5)]
    ngon(midpoint(pt1, pt2), 20, 5, 0, :fill)
end</code></pre></div><p><img src="assets/figures/midpoint.png" alt="arc"/></p><p>A more general function, <code>between()</code>, finds for a value <code>x</code> between 0 and 1 the corresponding point on a line defined by two points. So <code>midpoint(p1, p2)</code> and <code>between(p1, p2, 0.5)</code> should return the same point.</p><div><pre><code class="language-julia">sethue(&quot;red&quot;)
p1 = Point(-150, 0)
p2 = Point(150, 40)
line(p1, p2)
strokepath()
for i in -0.5:0.1:1.5
    randomhue()
    circle(between(p1, p2, i), 5, :fill)
end</code></pre></div><p><img src="assets/figures/betweenpoint.png" alt="arc"/></p><p>Values less than 0.0 and greater than 1.0 appear to work well too, placing the point on the line if extended.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.midpoint" href="#Luxor.midpoint"><code>Luxor.midpoint</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">midpoint(p1, p2)</code></pre><p>Find the midpoint between two points.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L119-L123">source</a><div><pre><code class="language-none">midpoint(a)</code></pre><p>Find midpoint between the first two elements of an array of points.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L126-L130">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.between" href="#Luxor.between"><code>Luxor.between</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">between(p1::Point, p2::Point, x)
between((p1::Point, p2::Point), x)</code></pre><p>Find the point between point <code>p1</code> and point <code>p2</code> for <code>x</code>, where <code>x</code> is typically between 0 and 1, so these two should be equivalent:</p><pre><code class="language-none">between(p1, p2, 0.5)</code></pre><p>and</p><pre><code class="language-none">midpoint(p1, p2)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L133-L145">source</a></section><p><code>center3pts()</code> finds the radius and center point of a circle passing through three points which you can then use with functions such as <code>circle()</code> or <code>arc2r()</code>.</p><p><code>intersection()</code> finds the intersection of two lines.</p><div><pre><code class="language-julia">sethue(&quot;black&quot;)
P1, P2, P3, P4 = ngon(O, 100, 5, vertices=true)
label.([&quot;P1&quot;, &quot;P2&quot;, &quot;P3&quot;, &quot;P4&quot;], :N, [P1, P2, P3, P4])
line(P1, P2, :stroke)
line(P4, P3, :stroke)

flag, ip =  intersection(P1, P2, P4, P3)
if flag
    circle(ip, 5, :fill)
end</code></pre></div><p><img src="assets/figures/intersection.png" alt="arc"/></p><p>Notice that the order in which the points define the lines is important (P1 to P2, P4 to P3). The <code>collinearintersect=true</code> option may also help.</p><p><code>intersectionlinecircle()</code> finds the intersection of a line and a circle. There can be 0, 1, or 2 intersection points.</p><div><pre><code class="language-julia">l1 = Point(-100.0, -75.0)
l2 = Point(300.0, 100.0)
rad = 100
cpoint = Point(0, 0)
line(l1, l2, :stroke)
circle(cpoint, rad, :stroke)
nints, ip1, ip2 =  intersectionlinecircle(l1, l2, cpoint, rad)
sethue(&quot;black&quot;)
if nints == 2
    circle(ip1, 8, :stroke)
    circle(ip2, 8, :stroke)
end</code></pre></div><p><img src="assets/figures/intersection_line_circle.png" alt="arc"/></p><p><code>intersection2circles()</code> finds the area of the intersection of two circles, and <code>intersectioncirclecircle()</code> finds the points where they cross.</p><p>This example shows the areas of two circles, and the area of their intersection.</p><div><pre><code class="language-julia">c1 = (O, 150)
c2 = (O + (100, 0), 150)

circle(c1... , :stroke)
circle(c2... , :stroke)

sethue(&quot;purple&quot;)
circle(c1... , :clip)
circle(c2... , :fill)
clipreset()

sethue(&quot;black&quot;)

text(string(150^2 * pi |&gt; round), c1[1] - (125, 0))
text(string(150^2 * pi |&gt; round), c2[1] + (100, 0))
sethue(&quot;white&quot;)
text(string(intersection2circles(c1..., c2...) |&gt; round),
     midpoint(c1[1], c2[1]), halign=:center)

sethue(&quot;red&quot;)
flag, C, D = intersectioncirclecircle(c1..., c2...)
if flag
    circle.([C, D], 5, :fill)
end</code></pre></div><p><img src="assets/figures/intersection2circles.png" alt="intersection of two circles"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.intersection" href="#Luxor.intersection"><code>Luxor.intersection</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">intersection(p1::Point, p2::Point, p3::Point, p4::Point;
    commonendpoints = false,
    crossingonly = false,
    collinearintersect = false)</code></pre><p>Find intersection of two lines <code>p1</code>-<code>p2</code> and <code>p3</code>-<code>p4</code></p><p>This returns a tuple: <code>(boolean, point(x, y))</code>.</p><p>Keyword options and default values:</p><pre><code class="language-none">crossingonly = false</code></pre><p>If <code>crossingonly = true</code>, lines must actually cross. The function returns <code>(false, intersectionpoint)</code> if the lines don&#39;t actually cross, but would eventually intersect at <code>intersectionpoint</code> if continued beyond their current endpoints.</p><p>If <code>false</code>, the function returns <code>(true, Point(x, y))</code> if the lines intersect somewhere eventually at <code>intersectionpoint</code>.</p><pre><code class="language-none">commonendpoints = false</code></pre><p>If <code>commonendpoints= true</code>, will return <code>(false, Point(0, 0))</code> if the lines share a common end point (because that&#39;s not so much an intersection, more a meeting).</p><p>Function returns <code>(false, Point(0, 0))</code> if the lines are undefined.</p><p>If you want collinear points to be considered to intersect, set <code>collinearintersect</code> to <code>true</code>, although it defaults to <code>false</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L286-L316">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.intersectionlinecircle" href="#Luxor.intersectionlinecircle"><code>Luxor.intersectionlinecircle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">intersectionlinecircle(p1::Point, p2::Point, cpoint::Point, r)</code></pre><p>Find the intersection points of a line (extended through points <code>p1</code> and <code>p2</code>) and a circle.</p><p>Return a tuple of <code>(n, pt1, pt2)</code></p><p>where</p><ul><li><p><code>n</code> is the number of intersections, <code>0</code>, <code>1</code>, or <code>2</code></p></li><li><p><code>pt1</code> is first intersection point, or <code>Point(0, 0)</code> if none</p></li><li><p><code>pt2</code> is the second intersection point, or <code>Point(0, 0)</code> if none</p></li></ul><p>The calculated intersection points won&#39;t necessarily lie on the line segment between <code>p1</code> and <code>p2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L423-L437">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.intersection2circles" href="#Luxor.intersection2circles"><code>Luxor.intersection2circles</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">intersection2circles(pt1, r1, pt2, r2)</code></pre><p>Find the area of intersection between two circles, the first centered at <code>pt1</code> with radius <code>r1</code>, the second centered at <code>pt2</code> with radius <code>r2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L625-L630">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.intersectioncirclecircle" href="#Luxor.intersectioncirclecircle"><code>Luxor.intersectioncirclecircle</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">intersectioncirclecircle(cp1, r1, cp2, r2)</code></pre><p>Find the two points where two circles intersect, if they do. The first circle is centered at <code>cp1</code> with radius <code>r1</code>, and the second is centered at <code>cp1</code> with radius <code>r1</code>.</p><p>Returns</p><pre><code class="language-none">(flag, ip1, ip2)</code></pre><p>where <code>flag</code> is a Boolean <code>true</code> if the circles intersect at the points <code>ip1</code> and <code>ip2</code>. If the circles don&#39;t intersect at all, or one is completely inside the other, <code>flag</code> is <code>false</code> and the points are both Point(0, 0).</p><p>Use <code>intersection2circles()</code> to find the area of two overlapping circles.</p><p>In the pure world of maths, it must be possible that two circles &#39;kissing&#39; only have a single intersection point. At present, this unromantic function reports that two kissing circles have no intersection points.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L659-L678">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.boundingboxesintersect" href="#Luxor.boundingboxesintersect"><code>Luxor.boundingboxesintersect</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">boundingboxesintersect(bbox1::BoundingBox, bbox2::BoundingBox)</code></pre><p>Return true if the two bounding boxes intersect.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/BoundingBox.jl#L242-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.ispointonline" href="#Luxor.ispointonline"><code>Luxor.ispointonline</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">ispointonline(pt::Point, pt1::Point, pt2::Point;
    extended = false,
    atol = 10E-5)</code></pre><p>Return <code>true</code> if the point <code>pt</code> lies on a straight line between <code>pt1</code> and <code>pt2</code>.</p><p>If <code>extended</code> is false (the default) the point must lie on the line segment between <code>pt1</code> and <code>pt2</code>. If <code>extended</code> is true, the point lies on the line if extended in either direction.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L244-L254">source</a></section><p><code>getnearestpointonline()</code> finds perpendiculars.</p><div><pre><code class="language-julia">end1, end2, pt3 = ngon(O, 100, 3, vertices=true)
map(pt -&gt; circle(pt, 5, :fill), [end1, end2, pt3])
line(end1, end2, :stroke)
arrow(pt3, getnearestpointonline(end1, end2, pt3))</code></pre></div><p><img src="assets/figures/perpendicular.png" alt="arc"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.getnearestpointonline" href="#Luxor.getnearestpointonline"><code>Luxor.getnearestpointonline</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">getnearestpointonline(pt1::Point, pt2::Point, startpt::Point)</code></pre><p>Given a line from <code>pt1</code> to <code>pt2</code>, and <code>startpt</code> is the start of a perpendicular heading to meet the line, at what point does it hit the line?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L100-L105">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.pointlinedistance" href="#Luxor.pointlinedistance"><code>Luxor.pointlinedistance</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">pointlinedistance(p::Point, a::Point, b::Point)</code></pre><p>Find the distance between a point <code>p</code> and a line between two points <code>a</code> and <code>b</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L85-L89">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.slope" href="#Luxor.slope"><code>Luxor.slope</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">slope(pointA::Point, pointB::Point)</code></pre><p>Find angle of a line starting at <code>pointA</code> and ending at <code>pointB</code>.</p><p>Return a value between 0 and 2pi. Value will be relative to the current axes.</p><pre><code class="language-none">slope(O, Point(0, 100)) |&gt; rad2deg # y is positive down the page
90.0

slope(Point(0, 100), O) |&gt; rad2deg
270.0</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L376-L389">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.perpendicular" href="#Luxor.perpendicular"><code>Luxor.perpendicular</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">perpendicular(p1, p2, k)</code></pre><p>Return a point <code>p3</code> that is <code>k</code> units away from <code>p1</code>, such that a line <code>p1 p3</code> is perpendicular to <code>p1 p2</code>.</p><p>Convention? to the right?</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L155-L162">source</a><div><pre><code class="language-none">perpendicular(p::Point)</code></pre><p>Returns point <code>Point(p.y, -p.x)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L176-L180">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.@polar" href="#Luxor.@polar"><code>Luxor.@polar</code></a> — <span class="docstring-category">Macro</span>.</div><div><pre><code class="language-none">@polar (p)</code></pre><p>Convert a tuple of two numbers to a Point of x, y Cartesian coordinates.</p><pre><code class="language-none">@polar (10, pi/4)
@polar [10, pi/4]</code></pre><p>produces</p><pre><code class="language-none">Luxor.Point(7.0710678118654755,7.071067811865475)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L441-L452">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.polar" href="#Luxor.polar"><code>Luxor.polar</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">polar(r, theta)</code></pre><p>Convert point in polar form (radius and angle) to a Point.</p><pre><code class="language-none">polar(10, pi/4)</code></pre><p>produces</p><pre><code class="language-none">Luxor.Point(7.071067811865475,7.0710678118654755)</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/point.jl#L459-L469">source</a></section><h2><a class="nav-anchor" id="Arrows-1" href="#Arrows-1">Arrows</a></h2><p>You can draw lines or arcs with arrows at the end with <code>arrow()</code>. For straight arrows, supply the start and end points. For arrows as circular arcs, you provide center, radius, and start and finish angles. You can optionally provide dimensions for the <code>arrowheadlength</code> and <code>arrowheadangle</code> of the tip of the arrow (angle in radians between side and center). The default line weight is 1.0, equivalent to <code>setline(1)</code>), but you can specify another.</p><div><pre><code class="language-julia">arrow(O, Point(0, -65))
arrow(O, Point(100, -65), arrowheadlength=20, arrowheadangle=pi/4, linewidth=.3)
arrow(O, 100, pi, pi/2, arrowheadlength=25,   arrowheadangle=pi/12, linewidth=1.25)</code></pre></div><p><img src="assets/figures/arrow.png" alt="arrows"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.arrow" href="#Luxor.arrow"><code>Luxor.arrow</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">arrow(startpoint::Point, endpoint::Point;
    linewidth = 1.0,
    arrowheadlength = 10,
    arrowheadangle = pi/8)</code></pre><p>Draw a line between two points and add an arrowhead at the end. The arrowhead length will be the length of the side of the arrow&#39;s head, and the arrowhead angle is the angle between the sloping side of the arrowhead and the arrow&#39;s shaft.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>), and defaults to 1, but you can specify another value. It doesn&#39;t need stroking/filling, the shaft is stroked and the head filled with the current color.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/arrows.jl#L1-L15">source</a><div><pre><code class="language-none">arrow(centerpos::Point, radius, startangle, endangle;
    linewidth = 1.0,
    arrowheadlength = 10,
    arrowheadangle = pi/8)</code></pre><p>Draw a curved arrow, an arc centered at <code>centerpos</code> starting at <code>startangle</code> and ending at <code>endangle</code> with an arrowhead at the end. Angles are measured clockwise from the positive x-axis.</p><p>Arrows don&#39;t use the current linewidth setting (<code>setline()</code>); you can specify the linewidth.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/arrows.jl#L55-L66">source</a></section><h2><a class="nav-anchor" id="Julia-graphics-1" href="#Julia-graphics-1">Julia graphics</a></h2><p>A couple of functions in Luxor provide you with instant access to the Julia logo, and the three colored circles:</p><div><pre><code class="language-julia">for (pos, n) in Tiler(750, 250, 1, 2)
    gsave()
    translate(pos - Point(150, 100))
    if n == 1
        julialogo()
    elseif n == 2
        julialogo(action=:clip)
        for i in 1:500
            gsave()
            translate(rand(0:400), rand(0:250))
            juliacircles(10)
            grestore()
        end
        clipreset()
    end
    grestore()
end</code></pre></div><p><img src="assets/figures/julia-logo.png" alt="get path"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.julialogo" href="#Luxor.julialogo"><code>Luxor.julialogo</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">julialogo(;action=:fill, color=true)</code></pre><p>Draw the Julia logo. The default action is to fill the logo and use the colors:</p><pre><code class="language-none">julialogo()</code></pre><p>If <code>color</code> is <code>false</code>, the logo will use the current color, and the dots won&#39;t be colored in the usual way.</p><p>The logo&#39;s dimensions are about 330 wide and 240 high, and the <code>0/0</code> point is at the bottom left corner. To place the logo by locating its center, do this:</p><pre><code class="language-none">gsave()
translate(-165, -120)
julialogo() # locate center at 0/0
grestore()</code></pre><p>To use the logo as a clipping mask:</p><pre><code class="language-none">julialogo(action=:clip)</code></pre><p>(In this case the <code>color</code> setting is automatically ignored.)</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/juliagraphics.jl#L24-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.juliacircles" href="#Luxor.juliacircles"><code>Luxor.juliacircles</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">juliacircles(radius=100)</code></pre><p>Draw the three Julia circles in color centered at the origin.</p><p>The distance of the centers of the circles from the origin is <code>radius</code>. The optional keyword arguments <code>outercircleratio</code> (default 0.75) and <code>innercircleratio</code> (default 0.65) control the radius of the individual colored circles relative to the <code>radius</code>. So you can get relatively smaller or larger circles by adjusting the ratios.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/juliagraphics.jl#L209-L218">source</a></section><h2><a class="nav-anchor" id="Bounding-boxes-1" href="#Bounding-boxes-1">Bounding boxes</a></h2><p>The <code>BoundingBox</code> type allows you to use rectangular extents to organize and interact with the 2D drawing area. A <code>BoundingBox</code> instance returns two points, the opposite corners of a bounding box.</p><p><code>BoundingBox()</code> without arguments defines an extent that encloses the drawing (assuming that the origin is at the center of the drawing—see <code>origin()</code>).</p><p>This example draws circles at three points: at two of the drawing&#39;s corners and the midway point between them:</p><div><pre><code class="language-julia">origin()

bb = BoundingBox()
setline(10)
sethue(&quot;orange&quot;)

circle(bb[1], 150, :stroke) # first corner

circle(bb[2], 150, :stroke) # second corner

circle(midpoint(bb...), 150, :stroke) # midpoint

sethue(&quot;blue&quot;)
circle.([bb[1], midpoint(bb[1:2]), bb[2]], 130, :fill)

sethue(&quot;red&quot;)
circle.([first(bb), midpoint(bb...), last(bb)], 100, :fill)</code></pre></div><p><img src="assets/figures/bbox.png" alt="bounding box"/></p><p>You can make a BoundingBox from two points, a text string, an existing polygon, or by modifying an existing one.</p><div><pre><code class="language-julia">p = star(O, 100, 5, 0.1, pi/3.3, vertices=true)
sethue(&quot;antiquewhite&quot;)
box(BoundingBox(p), :fill)

sethue(&quot;black&quot;)
poly(p, :stroke, close=true)</code></pre></div><p><img src="assets/figures/bboxpoly.png" alt="bounding box of polygon"/></p><p>The bounding box objects can be passed to <code>box()</code> or <code>poly()</code> to be drawn.</p><p>You can also do some arithmetic on bounding boxes. In the next example, the text&#39;s bounding box is filled with yellow, increased by 20 units (blue), scaled by 1.3 (green), and shifted by <code>(0, 100)</code> (orange).</p><div><pre><code class="language-julia">translate(-130,0)
fontsize(40)
str = &quot;good afternoon&quot;
sethue(&quot;yellow&quot;)
box(BoundingBox(str), :fill)
sethue(&quot;black&quot;)
text(str)

sethue(&quot;blue&quot;)
modbox = BoundingBox(str) + 40 # add 20 units to all sides
poly(modbox, :stroke, close=true)

sethue(&quot;green&quot;)
modbox = BoundingBox(str) * 1.3
poly(modbox, :stroke, close=true)

sethue(&quot;orange&quot;)
modbox = BoundingBox(str) + (0, 100)
poly(modbox, :fill, close=true)</code></pre></div><p><img src="assets/figures/bbox2.png" alt="bounding boxes 2"/></p><p>You can find the union and intersection of BoundingBoxes, and also find whether a point lies inside one. The following code creates, shrinks, and shifts two bounding boxes (colored yellow and pink), and then draws: their union (a bounding box that includes both), in black outline; and their intersection (a bounding box of their common areas), in red. Then some random points are created and drawn differently depending on whether they&#39;re inside the intersection or outside.</p><div><pre><code class="language-julia">origin()
setopacity(0.75)
setline(8)

bbox1 = BoundingBox()/2 - (50, 30)
sethue(&quot;yellow&quot;)
box(bbox1, :fill)

bbox2 = BoundingBox()/2  + (50, 30)
sethue(&quot;pink&quot;)
box(bbox2, :fill)

sethue(&quot;black&quot;)
box(bbox1 + bbox2, :stroke)

sethue(&quot;red&quot;)
bothboxes = intersectboundingboxes(bbox1, bbox2)
box(bothboxes, :fill)

for i in 1:500
    pt = randompoint(bbox1 + bbox2...)
    if isinside(pt, bothboxes)
        sethue(&quot;white&quot;)
        circle(pt, 3, :fill)
    else
        sethue(&quot;black&quot;)
        circle(pt, 2, :fill)
    end
end</code></pre></div><p><img src="assets/figures/bbox3.png" alt="intersecting bounding boxes"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.BoundingBox" href="#Luxor.BoundingBox"><code>Luxor.BoundingBox</code></a> — <span class="docstring-category">Type</span>.</div><div><p>The BoundingBox type holds two Points, <code>corner1</code> and <code>corner2</code>.</p><pre><code class="language-none">BoundingBox(;centered=true) # the bounding box of the Drawing
BoundingBox(s::String)      # the bounding box of a text string
BoundingBox(pt::Array)      # the bounding box of a polygon</code></pre></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/BoundingBox.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.boxaspectratio" href="#Luxor.boxaspectratio"><code>Luxor.boxaspectratio</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">boxaspectratio(bb::BoundingBox)</code></pre><p>Return the aspect ratio (the height divided by the width) of bounding box <code>bb</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/BoundingBox.jl#L168-L172">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.boxdiagonal" href="#Luxor.boxdiagonal"><code>Luxor.boxdiagonal</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">boxdiagonal(bb::BoundingBox)</code></pre><p>Return the length of the diagonal of bounding box <code>bb</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/BoundingBox.jl#L161-L165">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.boxwidth" href="#Luxor.boxwidth"><code>Luxor.boxwidth</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">boxwidth(bb::BoundingBox)</code></pre><p>Return the width of bounding box <code>bb</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/BoundingBox.jl#L147-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.boxheight" href="#Luxor.boxheight"><code>Luxor.boxheight</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">boxheight(bb::BoundingBox)</code></pre><p>Return the height of bounding box <code>bb</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/BoundingBox.jl#L154-L158">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.intersectboundingboxes" href="#Luxor.intersectboundingboxes"><code>Luxor.intersectboundingboxes</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">intersectionboundingboxes(bb1::BoundingBox, bb2::BoundingBox)</code></pre><p>Returns a bounding box intersection.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/BoundingBox.jl#L250-L254">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.boxtop" href="#Luxor.boxtop"><code>Luxor.boxtop</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">boxtop(bb::BoundingBox)</code></pre><p>Return the top center point of bounding box <code>bb</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/BoundingBox.jl#L175-L179">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.boxbottom" href="#Luxor.boxbottom"><code>Luxor.boxbottom</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">boxbottom(bb::BoundingBox)</code></pre><p>Return the top center point of bounding box <code>bb</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/BoundingBox.jl#L182-L186">source</a></section><h2><a class="nav-anchor" id="Miscellaneous-1" href="#Miscellaneous-1">Miscellaneous</a></h2><h3><a class="nav-anchor" id="Hypotrochoids-1" href="#Hypotrochoids-1">Hypotrochoids</a></h3><p><code>hypotrochoid()</code> makes hypotrochoids. The result is a polygon. You can either draw it directly, or pass it on for further polygon fun, as here, which uses <code>offsetpoly()</code> to trace round it a few times.</p><div><pre><code class="language-julia">origin()
background(&quot;grey15&quot;)
sethue(&quot;antiquewhite&quot;)
setline(1)
p = hypotrochoid(100, 25, 55, :stroke, stepby=0.01, vertices=true)
for i in 0:3:15
    poly(offsetpoly(p, i), :stroke, close=true)
end</code></pre></div><p><img src="assets/figures/hypotrochoid.png" alt="hypotrochoid"/></p><p>There&#39;s a matching <code>epitrochoid()</code> function.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.hypotrochoid" href="#Luxor.hypotrochoid"><code>Luxor.hypotrochoid</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">hypotrochoid(R, r, d, action=:none;
        stepby=0.01,
        period=0,
        vertices=false)</code></pre><p>Make a hypotrochoid with short line segments. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius <code>r</code> rolling around the inside  of a fixed circle of radius <code>R</code>, where the point is a distance <code>d</code> from  the center of the interior circle. Things get interesting if you supply non-integral values.</p><p>Special cases include the hypocycloid, if <code>d</code> = <code>r</code>, and an ellipse, if <code>R</code> = <code>2r</code>.</p><p><code>stepby</code>, the angular step value, controls the amount of detail, ie the smoothness of the polygon,</p><p>If <code>period</code> is not supplied, or 0, the lowest period is calculated for you.</p><p>The function can return a polygon (a list of points), or draw the points directly using the supplied <code>action</code>. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of <code>pi</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L470-L491">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.epitrochoid" href="#Luxor.epitrochoid"><code>Luxor.epitrochoid</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">epitrochoid(R, r, d, action=:none;
        stepby=0.01,
        period=0,
        vertices=false)</code></pre><p>Make a epitrochoid with short line segments. (Like a Spirograph.) The curve is traced by a point attached to a circle of radius <code>r</code> rolling around the outside of a fixed circle of radius <code>R</code>, where the point is a distance <code>d</code> from the center of the circle. Things get interesting if you supply non-integral values.</p><p><code>stepby</code>, the angular step value, controls the amount of detail, ie the smoothness of the polygon.</p><p>If <code>period</code> is not supplied, or 0, the lowest period is calculated for you.</p><p>The function can return a polygon (a list of points), or draw the points directly using the supplied <code>action</code>. If the points are drawn, the function returns a tuple showing how many points were drawn and what the period was (as a multiple of <code>pi</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/curves.jl#L516-L535">source</a></section><h3><a class="nav-anchor" id="Cropmarks-1" href="#Cropmarks-1">Cropmarks</a></h3><p>If you want cropmarks (aka trim marks), use the <code>cropmarks()</code> function, supplying the centerpoint, followed by the width and height:</p><pre><code class="language-none">cropmarks(O, 1200, 1600)
cropmarks(O, paper_sizes[&quot;A0&quot;]...)</code></pre><div><pre><code class="language-julia">sethue(&quot;red&quot;)
box(O, 150, 150, :stroke)
cropmarks(O, 150, 150)</code></pre></div><p><img src="assets/figures/cropmarks.png" alt="cropmarks"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.cropmarks" href="#Luxor.cropmarks"><code>Luxor.cropmarks</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">cropmarks(center, width, height)</code></pre><p>Draw cropmarks (also known as trim marks).</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/shapes.jl#L235-L239">source</a></section><h3><a class="nav-anchor" id="Bars-1" href="#Bars-1">Bars</a></h3><p>For simple bars, use the <code>bars()</code> function, supplying an array of numbers:</p><div><pre><code class="language-julia">fontsize(7)
sethue(&quot;black&quot;)
v = rand(-100:100, 25)
bars(v)</code></pre></div><p><img src="assets/figures/bars.png" alt="bars"/></p><p>To change the way the bars and labels are drawn, define some functions and pass them as keyword arguments to <code>bars()</code>:</p><div><pre><code class="language-julia">function mybarfunction(low::Point, high::Point, value;
    extremes=[0, 1], barnumber=0, bartotal=0)
    @layer begin
        sethue(Colors.HSB(rescale(value, extremes[1], extremes[2], 0, 360), 1.0, 0.5))
        csize = rescale(value, extremes[1], extremes[2], 5, 25)
        circle(high, csize, :fill)
        setline(1)
        sethue(&quot;blue&quot;)
        line(Point(low.x, 0), high + (0, csize), :stroke)
        sethue(&quot;white&quot;)
        text(string(value), high, halign=:center, valign=:middle)
    end
end

function mylabelfunction(low::Point, high::Point, value;
    extremes=[0, 1], barnumber=0, bartotal=0)
    @layer begin
        translate(low)
        text(string(value), O + (0, 10), halign=:center, valign=:middle)
    end
end

v = rand(1:100, 25)
bars(v, xwidth=25, barfunction=mybarfunction, labelfunction=mylabelfunction)</code></pre></div><p><img src="assets/figures/bars1.png" alt="bars 1"/></p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Luxor.bars" href="#Luxor.bars"><code>Luxor.bars</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-none">bars(values::AbstractArray;
        yheight = 200,
        xwidth = 25,
        labels = true,
        barfunction = f,
        labelfunction = f,
    )</code></pre><p>Draw some bars where each bar is the height of a value in the array. The bars will fit in a box <code>yheight</code> high (even if there are negative values).</p><p>To control the drawing of the text and bars, define functions that process the end points:</p><p><code>mybarfunction(bottom::Point, top::Point, value; extremes=[a, b], barnumber=0, bartotal=0)</code></p><p><code>mylabelfunction(bottom::Point, top::Point, value; extremes=[a, b], barnumber=0, bartotal=0)</code></p><p>and pass them like this:</p><pre><code class="language-julia">bars(v, yheight=10, xwidth=10, barfunction=mybarfunction)
bars(v, xwidth=15, yheight=10, labelfunction=mylabelfunction)</code></pre><p>To suppress the text labels, use optional keyword <code>labels=false</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/JuliaGraphics/Luxor.jl/blob/7efb94fe2a5254615e7e65fd597e98c374907c7e/src/bars.jl#L1-L28">source</a></section><footer><hr/><a class="previous" href="basics.html"><span class="direction">Previous</span><span class="title">Basic concepts</span></a><a class="next" href="tables-grids.html"><span class="direction">Next</span><span class="title">Tables and grids</span></a></footer></article></body></html>
